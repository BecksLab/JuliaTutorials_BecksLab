[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Julia and the BEFWM2 using VSCode",
    "section": "",
    "text": "This set of tutorials is designed to help you use an integrated coding tool, VSCode, to run experiments with the Bioenergetic Foodweb Model, built in the coding language Julia.\nIt will cover four core objectives\n\nacquire/install the Julia programming language, the Integrated Development Environment called VSCode, and the Bioenergetic Food Web Model written in the Julia programming language.\nLearn how to work with Julia programming, from installing packages to understanding arithmetic and plotting and data frames\nLearn how to simulate a simple predator-prey (consumer-resource) model using the DifferentialEquations package in Julia\nLearn how to implement and use the multi-species BioenergeticFoodWebModel in Julia\n\nHaving done these, you will then be introduced to further complexities and opportunties.\n\n\nIf you are a user of R and RStudio, you are likely familiar with setting RStudio and R up to use a project file, the .RProject inside a project folder. You are also used to downloading and installing packages into R on your computer, and then invoking their use in each script using the library() function.\nIn the world of VSCode and Julia, we do something similar. You will create project folders, just like we recommend for R. Inside this folder, two files will be created, the Project.toml and the Manifest.toml. These are not really the same as the .RProject file. In Julia, each project has a set of packages that are associated with it. This is different from the more ‘global’ installation of packages in R.\nThere are some parallels… first, adding packages in Julia uses the Pkg toolbox and gets them from the Julia Language Ecosystem. This is like downloading them from CRAN for R. Second, making packages available for use in a Julia script requires the using function, which is a lot like the library() function.\nAnyhow, the goal IS to try and make a workflow for Julia and VSCode that acts like the R and RStudio setup you are familiar with."
  },
  {
    "objectID": "Tutorial-5_Plotting in Julia.html",
    "href": "Tutorial-5_Plotting in Julia.html",
    "title": "Tutorial 5: Plotting in Julia",
    "section": "",
    "text": "In R, the plotting of data is either done in base R or via the ggplot2 package. If you’re a base R person, you’ll probably feel more comfortable with the Plots package. Alternatively, if you prefer ggplot2, the StatsPlots and Gadfly package is the closest thing you’ll find in Julia. We’ll introduce both in the following sections.\nIt is worth noting that Julia is based on a ‘Just in Time’ compiler (or JIT) so the first time you call a function it needs to compile, and can take longer than expected. This is especially true when rendering a plot. Consequently, the first plot you make might take some time but it gets significantly faster after that."
  },
  {
    "objectID": "Tutorial-5_Plotting in Julia.html#plots",
    "href": "Tutorial-5_Plotting in Julia.html#plots",
    "title": "Tutorial 5: Plotting in Julia",
    "section": "Plots",
    "text": "Plots\nAs you saw in Tutorial 2, we can make plots out of variables very easily with the plot function.\n\nRandom.seed!(12345)\nx = 1:100\ny = rand(100)\n\n# label is for the legend/key\n# lw = linewidth\nplot(x, y, label = \"amazing\", title = \"not amazing\", lw = 3)\n\n\n\n\nIf you want to add more data to a plot, the plot!() function is super valuable, and complemented by the xlabel!() and ylabel!() function to update the x-axis\n\ny2 = rand(100) # another 100 randoms\nplot!(x, y2, label = \"less amazing\")\nxlabel!(\"time is not your friend\")\nylabel!(\"ooh la la la\")\n\n\n\n\nRecall too that there is a seriestype argument to shift between the default line and, perhaps a scatterplot. Note that we can deliver both y and y2.\n\nplot(x, y, seriestype = [:line,:scatter], markershape = :diamond, lc = :orange, mc = :black, msc = :orange, label = \"Y\")\nplot!(x, y2, seriestype = [:line,:scatter], markershape = :diamond, lc = :blue, mc = :black,  msc = :blue, label = \"Y2\")\n\n\n\n\nmc is for marker colour, msc is the colour of the line around the marker/shape and lc is for line color.\nOf course, there is a scatter() plot function\n\nscatter(x, y)\n\n\n\n\n\nGrouping Variables in Plots\nJulia’s Plots.jl library does some basic work with grouping variables too, linking to key ideas about tidy data. Let’s look at some sample data where we have 12 data points (stability0 with 4 replicate observations from three networks (Network_1, Network_2 and Network_3).\n\nsample_data = DataFrame([rand(12), repeat([\"Network_1\",\"Network_2\",\"Network_3\"],4)], [\"stability\", \"network\"])\n\n\n12×2 DataFrameRowstabilitynetworkFloat64String10.0491108Network_120.699192Network_230.158122Network_340.470745Network_150.625568Network_260.997392Network_370.572846Network_180.580858Network_290.141685Network_3100.764872Network_1110.690545Network_2120.137958Network_3\n\n\nPlotting the data, by group, is accomplished like this (note the use of the . to connect the dataframe to the variable name)\n\nplot(sample_data.stability, group=sample_data.network)\n\n\n\n\nThis is a pretty silly plot because the x-axis makes no sense. We might have wanted a bar-chart instead.\n\ngroupedbar(sample_data.stability, group = sample_data.network)\n\n\n\n\nWe’ll see below how the package StatsPlots makes this easier and more flexible (a bit more like ggplot2).\n\n\nSaving Plots\nPlots can be saved and outputted using savefig or by using an output marco (e.g. png or pdf). savefig saves the most recent plot (.png is default format) or you can name figures e.g., p1, and use that reference name to save the plot object at any time:\n\n#not run\nsavefig(p1, \"path/to/file/p1.png\")\npng(p1, path/to/file/p1\")\npdf(p1, path/to/file/p1\")\n\nOnce you’ve created a plot it can be viewed or reopened in VS Code by navigating to the Julia explorer: Julia workspace symbol in the activity bar (three circles) and clicking on the plot object (e.g., p1). We advise that you always name and assign your plots (e.g. p1, p2, etc). The Plots package also has it’s own tutorial for plotting in Julia."
  },
  {
    "objectID": "Tutorial-5_Plotting in Julia.html#statsplots",
    "href": "Tutorial-5_Plotting in Julia.html#statsplots",
    "title": "Tutorial 5: Plotting in Julia",
    "section": "StatsPlots",
    "text": "StatsPlots\nAs you saw in the Setup introduction, we can also use the StatsPlots package for plotting. This approach invokes a background macro that allows you to use the DataFrames structure to deliver nice plots.\n\n# make a second data frame with three variables\n# using DataFrame directly to create variables\ndf2 = DataFrame(a=1:10, b=10*rand(10), c=10*rand(10))\ndf2\n\n\n10×3 DataFrameRowabcInt64Float64Float64110.8157936.88707223.753992.40944339.760621.53078449.964353.45292554.19571.77534668.545171.37223777.833734.74956888.69492.89649995.101120.93078910107.899568.68376\n\n\nThe use of the @df macro from StatsPlots is a three step process:\n\ndeclare the @df macro\ndefine the data frame\ndeclare the columns, using the : symbol.\n\n\n# plot the data using the data frame macro\n# declare the df macro, declare the data frame, use : to signify columns\n# note that the default is `x then y`.\n@df df2 plot(:a, :b)\n\n\n\n\nOne of the handy things about the @df macro and StatsPlots is the ability to add two or more variables at once:\n\n# the same, and plotting two y variables (b and c)\n@df df2 plot(:a, [:b, :c])\n\n\n\n\nThere are several helper functions too. For example, instead of the [[:b, :c] approach to multiple columns, there is a cols argument.\n\n@df df2 plot(:a, cols(2:3), colour = [:red :blue])\n\n\n\n\nFinally, coming back to the example above for plots using the sample_data dataframe with a grouping variable, we can see how StatsPlots mimics some of the faceting options and group options from ggplot2.\nFirst, the three groups in the same figure with an informative legend.\n\n@df sample_data plot(:stability, group = :network, legend = :topleft)\n\n\n\n\nSecond, the same data but in three panels.\n\n@df sample_data plot(:stability, group = :network, layout = 3)\n\n\n\n\nAnd following the standard Plots.jl example for grouped bars….\n\n@df sample_data groupedbar(:stability, group = :network)"
  },
  {
    "objectID": "Tutorial-5_Plotting in Julia.html#gadfly",
    "href": "Tutorial-5_Plotting in Julia.html#gadfly",
    "title": "Tutorial 5: Plotting in Julia",
    "section": "Gadfly",
    "text": "Gadfly\nThere is a actively developed package called Gadfly which implements an interpretation of the ggplot2 grammar of graphics. It has been finicky and unstable for us in the past, but you are welcome to try it. To use it, you need to install the package with the ] add Gadfly first step, and then using Gadfly in the top of your script.\nA tutorial and set of examples can be found here"
  },
  {
    "objectID": "Tutorial-1_Dowloads, Setups and Your First Project.html",
    "href": "Tutorial-1_Dowloads, Setups and Your First Project.html",
    "title": "Tutorial 1: Downloads, Setups and Your First Project",
    "section": "",
    "text": "Julia\nNavigate to this page and follow the platform-specific instructions to dowload and install Julia (we recommend installing the current stable release).\nDuring the installation process, you may be prompted to add Julia to the PATH, this box should be ticked.\nVSCode\nNavigate to this page to dowload and install your platform specific Visual Studio Code (not Visual Studio or Visual Studio for Mac)."
  },
  {
    "objectID": "Tutorial-1_Dowloads, Setups and Your First Project.html#setting-up-vscode-to-use-julia",
    "href": "Tutorial-1_Dowloads, Setups and Your First Project.html#setting-up-vscode-to-use-julia",
    "title": "Tutorial 1: Downloads, Setups and Your First Project",
    "section": "Setting Up VSCode to use Julia",
    "text": "Setting Up VSCode to use Julia\nVS Code is a free source-code editor, allowing you to code in multiple coding languages all from a platform that is completely customisable to the user. This flexibility is great but it does mean that you need to spend time telling VS Code what it is you want to do and how. This is where extensions come in; extensions are higher level packages that permit the use of a given coding language like Julia, edit your themes and icons, and provide helpful applications like spell checker or Bracket Pair Colorizer.\nTo install Julia in VS Code do the following (you only need to do this once):\n\nopen VS Code (you’ll see the welcome page)\nnavigate to the ‘Marketplace’ (5th symbol down in the activity bar - vertical panel on the lefthand side of the screen)\n\n\n\n\nThe Marketplace Button\n\n\n\nsearch for Julia in the ‘Search Extensions in Marketplace’ search bar\ninstall Julia, this extension provides support for the Julia programming language and install Julia Formatter, this extension will help you write clean code that is easier to read\n\n\n\n\nSelecting the Julia Language Support and Formatter"
  },
  {
    "objectID": "Tutorial-1_Dowloads, Setups and Your First Project.html#making-your-first-julia-project",
    "href": "Tutorial-1_Dowloads, Setups and Your First Project.html#making-your-first-julia-project",
    "title": "Tutorial 1: Downloads, Setups and Your First Project",
    "section": "Making your first Julia project",
    "text": "Making your first Julia project\nAs with working in R and RStudio, we advocate working in a contained project environment when using Julia. Each unique project may require a different setup (e.g. packages, package versions, working directories, data locations, etc.).\nTo set up a project in VS Code:\n\nCreating a folder at a location of your choosing (e.g. within your Documents folder). This can be on GoogleDrive, Dropbox or OneDrive. This is OK.\nName the folder with relevant works. Here we will use Julia - VS code - how to.\nNavigate to VSCode and open your new project by clicking on the ‘Explorer’ symbol (top left symbol on the activity bar) and click Open Folder and navigate your finder or explorer to the Julia - VS code - how to folder.\n\n\n\n\nOpening Your Project\n\n\n3.1 this folder becomes the working directory (same as when using an .RProject in R)\n\nCreate a new file (a script) in your directory: do this by using cmd-N (mac) or ctrl-N (windows) or File -> New File or by left clicking -> New File within the directory pane\nName your script as your see fit but please rememeber to include the .jl file extension (e.g. JuliaTuto.jl). the .jl file extension tells VS Code you want to use the Julia programming language. To save your script at any time use cmd-S (MAC) OR ctrl-S (windows) or File > Save.\n\n5.1 Note, you can also open a project in VS Code by right-clicking on your folder (in Finder, Windows file explorer or Linux nautilus) and selecting Open with -> Other -> VS Code.\n\nActivating the REPL and running some code.\nThis sequence of figures aligns with the instructions below.\n\n\n\nInitiating and using the REPL\n\n\nNow that you have an active project and a new script file you can open the Julia REPL. REPL stands for read, execute, print and loop. The REPL is like the console in R and is where the magic happens. In Eva’s words, it’s VS Code’s way of using Julia for a brain.\nTo do this you type F1 or cmd/cntrl - shift-p or View -> Command Palette and choose Julia REPL. The command palette will appear as a drop down menu with a search function at the top of the page.\nNow that you have an interface with Julia as a brain, you can actually do something! Try this: type print(\"Hello world\") in the REPL and press Enter/Return. If you’ve done all of the above correctly, Hello world should print in the REPL.\nNow, you can also make a ‘script’. Type ctrl-n or cmd-n and a document will open at the top. There will be a prompt/link to select your language. Click the link and, yes, search for and choose Julia.\nNext, type print(\"Hello world\") in the script. Just like RStudio, you can send the information in the script to the REPL. There are two ways to do this. First, and probably what you’ll want, is shift-enter(return). This will send the line of code you are on, and move to the next line. ctrl-enter(return) submits the line but does not move the cursor. Try it!"
  },
  {
    "objectID": "Tutorial-1_Dowloads, Setups and Your First Project.html#activating-your-project-the-project.toml-and-manifest.toml",
    "href": "Tutorial-1_Dowloads, Setups and Your First Project.html#activating-your-project-the-project.toml-and-manifest.toml",
    "title": "Tutorial 1: Downloads, Setups and Your First Project",
    "section": "Activating your project, the project.toml and manifest.toml",
    "text": "Activating your project, the project.toml and manifest.toml\nWe mentioned above that it is good practice to work within an environment specific to each project. The Julia package manager (Pkg) allows you to do that easily: Unlike traditional package managers, which install and manage a single global set of packages, Pkg is designed around environments: independent sets of packages that can be local to an individual project or shared and selected by name (text taken directly from the documentation).\nThe project environment is stored via two files:\nProject.toml - stores a list of packages that have been installed and their versions (very useful when sharing code as any user can see exactly what version of a package has been used)\nManifest.toml - does the same thing but for all the package dependencies (other packages that are essential, or form functional parts, of the package you want to use)\nThese files are created and modified automatically as you invoke the use of various packages.\n\nGetting started: activating your project.\nActivating your project is something that only needs doing once per computer. It allows you to add packages and dependencies to the project.\nIf you move the project to a new computer, or share the project, activation will be needed again.\nThere are two ways to activate your project.\n\ntype Pkg.activate(\".\") in the REPL.\ntype ] in the REPL and then activate .\n\nThe ] is a shorthand for using the Pkg package and opens the package manager. To get out of this, you press the backspace/delete button on your keyboard.\nThere are two ways to double check that you are actually working within your project:\n\ncheck/click the ‘Julia env:…’ on the bottom of your screen (blue bar), it should match your project name\nenter the package manager by typing ] in the Julia REPL, you should see (your-project-name) pkg> instead of julia>. Again, exit the package manager using backspace/delete button.\n\n\n\nWorking with the package manager and growing the project and manifest files\nOnce your project is activated, there are two ways to use the package manager (Pkg):\n\ndirectly from the REPL:\n\n\nnavigate to the REPL\ntype ]\nyou will see that instead of seeing julia> you now see (your-project-name) pkg>, indicating that all the packages that you now install (or update) will be installed (or updated) within this specific project\nto add a package, use the function add: ] add Plots\n\n\nusing Pkg (this is useful when you want to install packages or manage them from within your script):\n\n\nfirst type import Pkg and execute this line using shift-Enter\non subsequent lines, add, remove and update packages from your script using Pkg functions such as Pkg.add(), Pkg.remove() or Pkg.update().\nTo add a packages, the name of the package need to be written with quotes (Pkg.add(\"Plots\")).\n\n\nAn example using the Plots package\nNow that we are all set up, we are going to install a package, check the project’s status and remove a package. As this might be your first time installing a package (e.g., Plots), don’t be concerned if it takes a couple of minutes to run.\n\ntype ] add Plots in the REPL (or Pkg.add(\"Plots\")) in your script and execute using Ctrl-Enter.\n\nyou just installed the Plots package and a whole bunch of dependencies that Plots needs to work. This is equivalent to Base plots in R. Note that if you used Pkg.add(\"Plots\") this is the equivalent to using the install.packages() function in R.\n\n\n\n\n\nPackage Installing\n\n\n\ntype ] st in the REPL. This will check the status of your project and print the content of your Project.toml file, which is the list of main packages, in this case, just Plots.\n\nyou should see something like:\n\n\n\nPackage Status Check"
  },
  {
    "objectID": "Tutorial-1_Dowloads, Setups and Your First Project.html#gearing-up-to-do-more-stuff-what-packages-do-i-need.",
    "href": "Tutorial-1_Dowloads, Setups and Your First Project.html#gearing-up-to-do-more-stuff-what-packages-do-i-need.",
    "title": "Tutorial 1: Downloads, Setups and Your First Project",
    "section": "Gearing up to Do More Stuff (what packages do I need).",
    "text": "Gearing up to Do More Stuff (what packages do I need).\nThere are a core set of packages we use for all of our work. These 10 packages are almost always installed when we make a project.\nGo ahead and use either the ] or Pkg.add(\"package.name\") method to add all of these to your project.\n\nFor working with data\nCSV DataFrames DelimitedFiles\n\n\nFor plotting\nPlots\n\n\nFor statistical things\nStatistics Random Distributions StatsBase StatsPlots\n\n\nFor Modelling\nDifferentialEquations"
  },
  {
    "objectID": "Tutorial-1_Dowloads, Setups and Your First Project.html#your-first-script-setup.",
    "href": "Tutorial-1_Dowloads, Setups and Your First Project.html#your-first-script-setup.",
    "title": "Tutorial 1: Downloads, Setups and Your First Project",
    "section": "Your first script setup.",
    "text": "Your first script setup.\nAt this stage, you should have a good understanding about how to create a project folder, activate a project, start the REPL, open a script and add packages to the project.\nNow you are ready to ‘setup’ your first script.\n\ncreate a new script file (ctrl-n or cmd-n).\nchoose Julia as the language\nType some informative information at the top of the script\n\njust like in R and other programming languages, the # is a commenter.\n\nThe first section of your script is where you declare the packages you’ll be using.\n\nthe function to do this is using.\nmake Plots, Random and DataFrames available.\n\n\nNow you are ready to do something really simple. Let’s make some variables, data frames and a few simple plots.\nFirst, lets get the setup sorted and packages available\n\n# This is my first example script\n# 25 Jan 2023\n\n# packages I need\nusing Random, DataFrames, Plots, StatsPlots\n\nSecond, let’s make some variables and see how Julia print them to the screen\n\n# make two variables using the rand function\n# because we are using random numbers, we'll set the seed here for reproducibility\n\nRandom.seed!(12345)\n\nx = rand(10)\ny = rand(10)\n\nx\n\n10-element Vector{Float64}:\n 0.7918054038647908\n 0.1595789996994108\n 0.33419142747606\n 0.8113922657011057\n 0.7966292033537833\n 0.9178138221831842\n 0.31132682723725014\n 0.7529056805990061\n 0.6338479453532103\n 0.8999510969166794\n\n\nCool. Now, lets create two data frames, one made of the x and y variables, and another with three variables made directly in a call to DataFrame.\n\n# combine into a data frame using the DataFrame function\ndf = DataFrame(x = x, y = y)\ndf\n\n\n10×2 DataFrameRowxyFloat64Float6410.7918050.33026320.1595790.42198730.3341910.68530740.8113920.295850.7966290.97365960.9178140.2445970.3113270.46875180.7529060.27705590.6338480.629916100.8999510.121805\n\n\n…and the second\n\n# make a second data frame with three variables\n# using DataFrame directly to create variables\ndf2 = DataFrame(a=1:10, b=10*rand(10), c=10*rand(10))\ndf2\n\n\n10×3 DataFrameRowabcInt64Float64Float64110.5634039.77384227.226793.58869330.4666423.76688444.594899.03599550.4911088.73964666.991921.36299771.581220.815793884.707453.75399994.975720.59976110104.586752.14792\n\n\nGreat. Now, lets see how to plot the ‘solo’ variables. Note how we specify the seriestype. Try getting rid of this….\n\n# plot the data using x and y, as a scatterplot\nplot(x, y, seriestype=:scatter)\n\n\n\n\nSuperb. So, StatsPlots provides a special macro to use a dataframe with plots. It’s a three step process:\n\ndeclare the @df macro\ndefine the data frame\ndeclare the columns, using the :\n\n\n# plot the data using the data frame macro\n# declare the df macro, declare the data frame, use : to signify columns\n@df df plot(:x, :y)\n\n\n\n\nAnd here, we use the df2, and plot variable b and c vs. a.\n\n# the same, and plotting two y variables\n@df df2 plot(:a, [:b, :c])\n\n\n\n\n\nA quick briefing about data frames in Julia versus R and dplyr is here\nDataFrames Comparison R dplyr)"
  },
  {
    "objectID": "Tutorial-4_Programming Basics.html",
    "href": "Tutorial-4_Programming Basics.html",
    "title": "Tutorial 4: The Basics of Programming",
    "section": "",
    "text": "This section of the tutorials introduces programming basics, including the art of simple functions, positional arguments, keyword arguments, loops, if-else-break usage and continue-while usage.\nIt is important to note that if you have experience programming R, there is a major difference in Julia - the use of loops is very much advocated in Julia where as vectorising loops is advocated in R.\nBasically, we write loops in Julia. We try to avoid them in R, if we want speed."
  },
  {
    "objectID": "Tutorial-4_Programming Basics.html#functions",
    "href": "Tutorial-4_Programming Basics.html#functions",
    "title": "Tutorial 4: The Basics of Programming",
    "section": "Functions",
    "text": "Functions\nFunctions work exactly like they do in R, however, there are three fundamental differences:\n\nthere is no need for {} brackets (thank god)\nindenting (Julia requires seperate parts of a function to be indented - don’t worry, VS Code should do this for you)\nscoping (we’ll attempt to explain this later)\nfunctions always start with the word function and end with the word end. -to store something that is calculated in a function, you use the return command.\n\nLet’s begin with a simple function - adding 2 to any number\n\nfunction plus_two(x)\n    return(x+2)\nend\n\nplus_two (generic function with 1 method)\n\n\nLet’s use it now by providing an defining and x value, and asking for the function to return the new value.\n\nx_in = 33\nx_out = plus_two(x_in)\n\n35\n\n\nBecause we’ve defined x_out, we can request it…\n\nx_out\n\n35\n\n\n\nPositional Arguments\nAs in R, input variables for functions have a specified and fixed order unless they have a default value which is explictly specified. For instance, we can build a function that measures body weight on different planets, but defaults to estimating weight on earth with a gravitational force of 9.81:\n\nfunction bodyweight(BW_earth, g = 9.81)\n    # bw should be in kg.\n    return BW_earth*g/9.81\nend\n\nbodyweight (generic function with 2 methods)\n\n\nNote that the function is called bodyweight, it requires in the first position a weight in kg on earth and then defaults to estimating weight on earth by using g = 9.81\n\nbodyweight(75)\n\n75.0\n\n\nNow, if we want to estimate they same bodyweight on Mars, where gravit is 3.72, you can specify the g-value.\n\nbodyweight(75, 3.72)\n\n28.44036697247706\n\n\n\n\nKeyword Arguments\n\n# function with keyword arguments:\n# here, b and d are fixed = 2\n# a is positional\n# c is a keyword argument\n# the addition of ; before c means that c is an keyword argument and can be specified in any order, but must be named\nfunction key_word(a, b=2; c, d=2) \n    return a + b + c + d\nend\n\nkey_word (generic function with 2 methods)\n\n\nHere we specify position 1 (a) and that c = 3\n\nkey_word(1, c = 3)\n\n8\n\n\nHere we specify c = 3, and then position 1\n\nkey_word(c=3, 1)\n\n8\n\n\nHere we specify position 1 (a), redefine position 2 (b = 6) and declare c = 7.\n\nkey_word(1, 6, c=7)\n\n16\n\n\nNote that this DOES NOT work, because we’ve failed to define c. (and or b)\n\nkey_word(1, 8, d=4)\n\nLoadError: UndefKeywordError: keyword argument c not assigned\n\n\nTo redfine d, you’d need to define c and d.\n\nkey_word(1, c = 8, d = 4)\n\n15"
  },
  {
    "objectID": "Tutorial-4_Programming Basics.html#loops",
    "href": "Tutorial-4_Programming Basics.html#loops",
    "title": "Tutorial 4: The Basics of Programming",
    "section": "Loops",
    "text": "Loops\n\nFor loops\nFor loops work by iterating over a specified range (e.g. 1-10) at specified intervals (e.g. 1,2,3…). For instance, we might use a for loop to fill an array:\n\nFilling an array\nTo fill an array, we first define an object as an array using [].\n\nI_array = []\n\nAny[]\n\n\nLike with function, all loops start with for and end with end. Here we iteratively fill I_array with 1000 random selections of 1 or 2.\n\n# for loop to fill an array:\nfor i in 1:1000\n    # pick from the number 1 or 2 at random \n    # for each i'th step\n    for_test = rand((1,2)) \n    # push! and store for_test in I_array2\n    # Julia is smart enough to do this iteratively\n    # you don't neccessarily have to index by `[i]` like you might do in R\n    push!(I_array, for_test) \nend\n\nLet’s look at I_array now\n\nI_array\n\n1000-element Vector{Any}:\n 1\n 2\n 1\n 2\n 1\n 1\n 1\n 2\n 2\n 2\n 2\n 1\n 1\n ⋮\n 1\n 2\n 2\n 2\n 1\n 1\n 1\n 2\n 1\n 2\n 2\n 2\n\n\nLet’s try something more complex, iterating over multiple indices\nA new storage container:\n\ntab = []\n\nAny[]\n\n\nNow, we fill the storage container with values of i, j and k. Can you tell which in which order this will happen? The first entry will be [1,1,1]. The second will be [2,1,1]. Do you understand why? Mess around to check.\n\n# nested for loop to fill an array:\nfor k in 1:4\n    for j in 1:3\n        for i in 1:2\n            append!(tab,[[i,j,k]]) # here we've use append! to allocate iteratively to the array as opposed to using push! - both work. \n        end\n    end\nend\n\nLet’s look…\n\ntab\n\n24-element Vector{Any}:\n [1, 1, 1]\n [2, 1, 1]\n [1, 2, 1]\n [2, 2, 1]\n [1, 3, 1]\n [2, 3, 1]\n [1, 1, 2]\n [2, 1, 2]\n [1, 2, 2]\n [2, 2, 2]\n [1, 3, 2]\n [2, 3, 2]\n [1, 1, 3]\n [2, 1, 3]\n [1, 2, 3]\n [2, 2, 3]\n [1, 3, 3]\n [2, 3, 3]\n [1, 1, 4]\n [2, 1, 4]\n [1, 2, 4]\n [2, 2, 4]\n [1, 3, 4]\n [2, 3, 4]\n\n\nWe can also allocate to a multiple dimensional matrix. When working with matrices, we can build them out of zeros and the replace the values.\nHere we start with a three dimensional array with 4 two x three matrices.\n\nthreeDmatrix = zeros(2,3,4)\n\n2×3×4 Array{Float64, 3}:\n[:, :, 1] =\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n\n[:, :, 2] =\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n\n[:, :, 3] =\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n\n[:, :, 4] =\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n\n\nNow, let’s do a nested loop again, but this time into the matrices. The element we are adding each iteration is the sum of i+j+k.\nCan you guess how this works?\n\nfor k in 1:4\n    for j in 1:3\n        for i in 1:2\n            # note default is by column....\n            # first element allocated is 1+1+1, then 2+1+1 and this is first col\n            # then 1+2+1 and 2+2+1 into the second col\n            # then 1+3+1 and 2+3+1 into the third col\n            threeDmatrix[i,j,k] = i+j+k\n        end\n    end\nend\n\n\nthreeDmatrix\n\n2×3×4 Array{Float64, 3}:\n[:, :, 1] =\n 3.0  4.0  5.0\n 4.0  5.0  6.0\n\n[:, :, 2] =\n 4.0  5.0  6.0\n 5.0  6.0  7.0\n\n[:, :, 3] =\n 5.0  6.0  7.0\n 6.0  7.0  8.0\n\n[:, :, 4] =\n 6.0  7.0  8.0\n 7.0  8.0  9.0\n\n\nFinally, note that we can use println to provide a basic marker what what is happening: we show two ways to do this in the code.\n\nfor k in 1:4\n    for j in 1:3\n        for i in 1:2\n            #println(i,\"-\",j,\"-\",k) # multiple quotes\n            println(\"$i-$j-$k\") # one quote, $ to grab variables\n            \n            # note default is by column....\n            # first element allocated is 1+1+1, then 2+1+1 and this is first col\n            # then 1+2+1 and 2+2+1 into the second col\n            # then 1+3+1 and 2+3+1 into the third col\n            threeDmatrix[i,j,k] = i+j+k\n        end\n    end\nend\n\nAnd just for fun… this println trick can be handy for verbose tracking. Note how person in unique(persons) iterates and how you can embed a variable’s value in a text string.\n\npersons = [\"Alice\", \"Alice\", \"Bob\", \"Bob2\", \"Carl\", \"Dan\"]\n\nfor person in unique(persons)\n    println(\"Hello $person\")\nend\n\nHello Alice\nHello Bob\nHello Bob2\nHello Carl\nHello Dan\n\n\nThere are tons of different functions that can be helpful when building loops. Take a few minutes to look into the help files for eachindex, eachcol, eachrow and enumerate. They all provide slightly different ways of telling Julia how you want to loop over a problem. Also, remember that loops aren’t just for allocation, they can also be very useful when doing calculations.\n\n\n\nif, else, breaks\nWhen building a loop, it is often meaningful to stop or modify the looping process when a certain condition is met. For example, we can use the break, if and else statements to stop a for loop when i exceeds a given value (e.g. 10):\n\n# if and break:\nfor i in 1:100\n    println(i) # print i\n    if i >10\n        break # stop the loop with i >10\n    end   \nend\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# this loop can be modified using an if-else statement:\n# even though we are iterating to 100, it stops at 10.\nfor j in 1:100\n    if j >10\n        break # stop the loop with i >10\n    else\n        crj = j^3\n        println(\"J is = $j\") # print i\n        println(\"The Cube of $j is $crj\")\n    end\nend\n\nJ is = 1\nThe Cube of 1 is 1\nJ is = 2\nThe Cube of 2 is 8\nJ is = 3\nThe Cube of 3 is 27\nJ is = 4\nThe Cube of 4 is 64\nJ is = 5\nThe Cube of 5 is 125\nJ is = 6\nThe Cube of 6 is 216\nJ is = 7\nThe Cube of 7 is 343\nJ is = 8\nThe Cube of 8 is 512\nJ is = 9\nThe Cube of 9 is 729\nJ is = 10\nThe Cube of 10 is 1000\n\n\nYou’ll notice that every statement requires it’s own start )for and end points, and is indented as per Julia’s requirements. if and else statements can be very useful when building experiments: for example we might want to stop simulating a network’s dynamics if more than 50% of the species have gone extinct.\n\n\ncontinue and while\n\ncontinue\nThe continue command is the opposite to break and can be useful when you want to skip an iteration but not stop the loop:\n\nfor i in 1:30\n    # this reads: is it false that i is a multiple of 3?\n    if i % 3 == false\n        continue # makes the loop skip iterations that are a multiple of 3\n    else println(\"$i is not a multiple of 3\")\n    end\nend\n\n1 is not a multiple of 3\n2 is not a multiple of 3\n4 is not a multiple of 3\n5 is not a multiple of 3\n7 is not a multiple of 3\n8 is not a multiple of 3\n10 is not a multiple of 3\n11 is not a multiple of 3\n13 is not a multiple of 3\n14 is not a multiple of 3\n16 is not a multiple of 3\n17 is not a multiple of 3\n19 is not a multiple of 3\n20 is not a multiple of 3\n22 is not a multiple of 3\n23 is not a multiple of 3\n25 is not a multiple of 3\n26 is not a multiple of 3\n28 is not a multiple of 3\n29 is not a multiple of 3\n\n\nCan you figure out what the code would be for keeping even numbers only? Note the change of logic from false above to true here.\n\nfor i in 1:10\n    # where is it true that i is a multiple of 2?\n    if i % 2 == true\n        continue # makes the loop skip iterations that are odd\n    else println(\"$i is even\")\n    end\nend\n\n2 is even\n4 is even\n6 is even\n8 is even\n10 is even\n\n\n\n\nwhile\nwhile loops provide an alternative to for loops and allow you to iterate until a certain condition is met:\n\n# counter that is globally scoped (see next section)\n# testval -- try changing this to see how this global variable can be used in \n# the local process below\nglobal j=0\nglobal testval = 17\n\n# note that we started with j = 0!!!\n# justify a condition\nwhile(j<testval) \n    println(\"$j is definitely less than $testval\") # prints j until j < 30\n    # step forward\n    j += 1 # count\nend\n\n0 is definitely less than 17\n1 is definitely less than 17\n2 is definitely less than 17\n3 is definitely less than 17\n4 is definitely less than 17\n5 is definitely less than 17\n6 is definitely less than 17\n7 is definitely less than 17\n8 is definitely less than 17\n9 is definitely less than 17\n10 is definitely less than 17\n11 is definitely less than 17\n12 is definitely less than 17\n13 is definitely less than 17\n14 is definitely less than 17\n15 is definitely less than 17\n16 is definitely less than 17\n\n\nwhile loops don’t require you to specify a looping sequence (e.g. i in 1:100). But you do specify the starting value. The while loop can be very useful because sometimes you simply don’t know how many iterations you might need.\nIn the above code, you might have spotted the word global. Variables can exist in the local or global scope. If a variable exists inside a loop or function it is local and if you want to save it beyond the loop (i.e., in your workspace) you have to make it global - more on this below."
  },
  {
    "objectID": "Tutorial-4_Programming Basics.html#combine-a-function-and-a-loop",
    "href": "Tutorial-4_Programming Basics.html#combine-a-function-and-a-loop",
    "title": "Tutorial 4: The Basics of Programming",
    "section": "combine a function and a loop",
    "text": "combine a function and a loop\nLet’s get a bit more complicated. Above, you created a function that added 2 to any number. Let’s embed that in a loop and introduce enumerate. Quite often, there are functions you may want to apply to multiple things, and this is the example of how to do that!\n\n# make a vector - these are input values to our function\nvv = [1,2,3,7,9,11]\n\n# enumerate takes a special two variable starter: \"(index, value)\"\n# note how we print the index, then the output and then a line break with \\n\nfor (i, v) in enumerate(vv)\n    out = plus_two(v)\n    println(\"this is element $i of vv\")\n    println(\"$v plus 2 is equal to $out\\n\")\nend\n\nthis is element 1 of vv\n1 plus 2 is equal to 3\n\nthis is element 2 of vv\n2 plus 2 is equal to 4\n\nthis is element 3 of vv\n3 plus 2 is equal to 5\n\nthis is element 4 of vv\n7 plus 2 is equal to 9\n\nthis is element 5 of vv\n9 plus 2 is equal to 11\n\nthis is element 6 of vv\n11 plus 2 is equal to 13"
  },
  {
    "objectID": "Tutorial-4_Programming Basics.html#scoping",
    "href": "Tutorial-4_Programming Basics.html#scoping",
    "title": "Tutorial 4: The Basics of Programming",
    "section": "Scoping",
    "text": "Scoping\nScoping refers to the accessibility of a variable within your project. The scope of a variable is defined as the region of code where a variable is known and accessible. A variable can be in the global or local scope.\n\nGlobal\nA variable in the global scope is accessible everywhere and can be modified by any part of your code. When you create (or allocate to) a variable in your script outside of a function or loop you’re creating something that is global:\n\n# global allocation to A\nA = 7\nB = zeros(1:10)\n\n10-element OffsetArray(::Vector{Float64}, 1:10) with eltype Float64 with indices 1:10:\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n\n\nOf course you cab be super literate and force a variable to be global\n\nglobal(c = 7)\n\n7\n\n\n\n\nLocal\nA variable in the local scope is only accessible in that scope or in scopes eventually defined inside it. When you define a variable within a function or loop that isn’t returned then you create something that is local:\n\n# global\nC2 = zeros(10)\n\n10-element Vector{Float64}:\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n\n\n\n# local:\nfor i in 1:10\n    local_varb = 2 # local_varb is defined inside the loop and is therefore local (only accessible within the loop)\n    C2[i] = local_varb*i # in comparison, C is defined outside of the loop and is therefore global \nend\n\nNow, let’s see what we can see.\nC2 is global and it had numbers assigned to it, and we can see it.\n\nC2\n\n10-element Vector{Float64}:\n  2.0\n  4.0\n  6.0\n  8.0\n 10.0\n 12.0\n 14.0\n 16.0\n 18.0\n 20.0\n\n\nHowever, local_varb is local, and we can’t ask for anything about it. If we wanted to know about it, we’d have to ask for it to be println-ed to monitor it, or written (as it was to C2)\n\nlocal_varb\n\nLoadError: UndefVarError: local_varb not defined"
  },
  {
    "objectID": "Tutorial-2_Using Julia for Maths and Vector Stuff.html",
    "href": "Tutorial-2_Using Julia for Maths and Vector Stuff.html",
    "title": "Tutorial 2: Using Julia for Maths and Vector Stuff",
    "section": "",
    "text": "This second document follows on from Tutorial 1: “Getting started” and assumes that you’re still working in your active project.\nThis document covers the following:\nThere is also a section at the end with some “Quick tips”."
  },
  {
    "objectID": "Tutorial-2_Using Julia for Maths and Vector Stuff.html#basic-maths",
    "href": "Tutorial-2_Using Julia for Maths and Vector Stuff.html#basic-maths",
    "title": "Tutorial 2: Using Julia for Maths and Vector Stuff",
    "section": "Basic Maths",
    "text": "Basic Maths\nAs you probably can guess, the REPL is an interface onto a large calculator. Julia does all the things R does… and you can find the basic maths operations defined The Julia Manual\n\n# sums\n1+1\n\n2\n\n\n\n# power\n10^3\n\n1000\n\n\n\n# sequences in a vector\n# From 0, by 1, to 10...\n\nx = collect(0:1:10)\n\n# see it\nx\n\n11-element Vector{Int64}:\n  0\n  1\n  2\n  3\n  4\n  5\n  6\n  7\n  8\n  9\n 10\n\n\n\n# multply scaler x vector.\nx*10\n\n11-element Vector{Int64}:\n   0\n  10\n  20\n  30\n  40\n  50\n  60\n  70\n  80\n  90\n 100"
  },
  {
    "objectID": "Tutorial-2_Using Julia for Maths and Vector Stuff.html#getting-help",
    "href": "Tutorial-2_Using Julia for Maths and Vector Stuff.html#getting-help",
    "title": "Tutorial 2: Using Julia for Maths and Vector Stuff",
    "section": "Getting Help",
    "text": "Getting Help\nBefore we move on, lets talk about the help files and how to access them. As in R, the help files assiocated with a given package, function or command can be accessed using ? followed by the function name (e.g. type ? pi in the REPL).\nSimilar to when you entered Julia’s package manager (using ]) you’ll notice that the ? command causes a change in the REPL with help?>replacing julia> as the prompt. This informs you that you’ve entered the help mode. As an exercise, use the help mode to find the difference between print and println."
  },
  {
    "objectID": "Tutorial-2_Using Julia for Maths and Vector Stuff.html#preamble-to-objects-like-scalars-vectors-and-arrays",
    "href": "Tutorial-2_Using Julia for Maths and Vector Stuff.html#preamble-to-objects-like-scalars-vectors-and-arrays",
    "title": "Tutorial 2: Using Julia for Maths and Vector Stuff",
    "section": "Preamble to Objects like scalars, vectors and arrays",
    "text": "Preamble to Objects like scalars, vectors and arrays\nBefore we start creating arrays and matrices, we’d like to demonstrate how you allocate numbers and strings to objects in Julia and check an object’s type. We’d also like to highlight some simple mathematical operations.\n\nAllocating data to objects\nAllocating in Julia is useful as it means that variables can be stored and used elsewhere. You allocate numbers to objects using the following:\nFirst note that we use the = in Julia, not the <- as in R.\n\n# allocate an Integer number to a variable\nn = 5\n\n5\n\n\nJulia, like other languages, has some built in values, like pi. We can allocate these to variable names we will use. Notice that Julia converts pi into the unicode symbol!\n\n# allocate a pre-defined number of importance to a variable\n# note that pi is converted to π\n# note2 - you can use \\pi in a julia script to get the unicode π ...\n# this works for numerous greek letters etc.  Like \\lambda for λ\npi_sum = pi\npi_sum\n\nπ = 3.1415926535897...\n\n\nWe can use these unicode symbols, like λ, as objects\n\nλ = 4\nλ\n\n4\n\n\nYou can also assign multiple values to separate variables in a concise manner. Julia can manage something like this:\n\nαi, βi, γi = 1.3, 2.1, exp(39)\n\n# confirm...\nαi, βi, γi\n\n(1.3, 2.1, 8.659340042399374e16)\n\n\n\nAllocating strings…\nOf course you can also allocate strings of text to objects. You must use the \"\" and not '' to define strings.\n\nsob = \"School of Biosciences\"\n\n\"School of Biosciences\"\n\n\nYou can combine strings and numbers to print like this. Note how you use $object.name within the text string you are writing… and this works for objects that are text or numeric.\n\nprintln(\"The favourite number in $sob is $n\")\n\nThe favourite number in School of Biosciences is 5\n\n\n\n\n\nIdentifying the Type of object you’ve made\nJulia is very specific about types of objects. Most programming languages are. One way to learn about them is to look at what is made when you make things in different ways.\n\ntypeof(n), typeof(sob), typeof(pi)\n\n(Int64, String, Irrational{:π})\n\n\nJulia is like R and Python in that it can infer the type of object (Integer, Float, etc) on the left hand side of the equals sign - you don’t have to justify it like you do in C. However, you can declare the type if needed e.g.\n\npi_custom = Float64(3.141592)\n\n3.141592\n\n\nFor those of you that are interested, a floating-point object (a Float) is a number that has a decimal place. An Int object is an integer, a number without a decimal place, whereas an Irrational object is a specific type of Float used only for representing some irrational numbers of special significance (e.g. π and γ). The 64 purely refers to 64-bit which is the type of processor your computer uses, most modern computers are 64-bit.\nOccaisionally it will be valuable to convert an object from one type to another. For example, n is currently an Integer (Int64), and we might want it to be Float (Float64). To be clear, this is a distinction between 5 and 5.0!\n\ntypeof(n)\n\nInt64\n\n\n\nn2 = convert(Float64, n)\ntypeof(n2)\n\nFloat64"
  },
  {
    "objectID": "Tutorial-2_Using Julia for Maths and Vector Stuff.html#understanding-arrays-vectors-and-sequences.",
    "href": "Tutorial-2_Using Julia for Maths and Vector Stuff.html#understanding-arrays-vectors-and-sequences.",
    "title": "Tutorial 2: Using Julia for Maths and Vector Stuff",
    "section": "Understanding Arrays, Vectors and Sequences.",
    "text": "Understanding Arrays, Vectors and Sequences.\nAs you saw above, we created a sequence of numbers using collect(0:1:10). Let’s look at what type of obect this is:\n\ntypeof(x)\n\n\nVector{Int64} (alias for Array{Int64, 1})\n\n\n\nThis is a vector. Let’s step back to see the difference between arrays and vectors. Arrays, for the R users, are best thought of as lists - they are storage boxes for any type of variables and can contain collections of various types. The general way to create an array, in this case and empty one, is the [ ].\n\nempty_array = []\n\nAny[]\n\n\nWe will first create an array with the same values as x and then see how collect() is the function that converts this to a vector, and actually lets us see the numbers too!\nFirst, range can be used to make an array. This is very similar to seq() in R and has the two variations - by and length that the R function has. The idfference is that by is replaced by the argument step. Note how a very concise summary of this array is presented using information in square brackets [ ]:\n\nx_array1 = range(start = 1, step = 1, stop = 10)\nx_array2 = range(start = 1, stop = 10, length = 5)\n\nx_array1, x_array2\n\n(1:1:10, 1.0:2.25:10.0)\n\n\nYou can also now see that creating arrays is possible with [ ] and the use of the : :\n\nx_array3 = [1:1:10]\n\n1-element Vector{StepRange{Int64, Int64}}:\n 1:1:10\n\n\nQuite often, you want to either see the values, or specifically be using a vector. To do this, you can use the function collect():\n\ncollect(x_array1)\n\n10-element Vector{Int64}:\n  1\n  2\n  3\n  4\n  5\n  6\n  7\n  8\n  9\n 10"
  },
  {
    "objectID": "Tutorial-2_Using Julia for Maths and Vector Stuff.html#indices-if-arrays.",
    "href": "Tutorial-2_Using Julia for Maths and Vector Stuff.html#indices-if-arrays.",
    "title": "Tutorial 2: Using Julia for Maths and Vector Stuff",
    "section": "Indices if Arrays.",
    "text": "Indices if Arrays.\nYou should recall from R that values in arrays and vectors and dataframes have addresses that we call indices. Julia works with indexing very similarly.\nLet’s make a simple array of 5 numbers and another simple array of five words. Note that the [] array function is a but like the c() function in R.\n\nar = [6,7,8,9,10]\nbr = [\"Pint\", \"of\", \"Moonshine\", \"please\"]\n\n4-element Vector{String}:\n \"Pint\"\n \"of\"\n \"Moonshine\"\n \"please\"\n\n\nYou can get any address in these using… square brackets!\n\nar[2] # gets the number 7!\n\n7\n\n\n\nbr[3] # gets the word Moonshine\n\n\"Moonshine\"\n\n\nIf you want two addresses in a sequence, you can just provide the sequence:\n\nar[2:3]\n\n2-element Vector{Int64}:\n 7\n 8\n\n\nBut if you want non-adjacent values, you need to provide the ‘list of indices’ as an array, which results in the use of [[ ]].\n\nar[[2,4]]\n\n2-element Vector{Int64}:\n 7\n 9\n\n\nNote this would be like using in R ar[c(2,4)]."
  },
  {
    "objectID": "Tutorial-2_Using Julia for Maths and Vector Stuff.html#broadcasting-something-very-special",
    "href": "Tutorial-2_Using Julia for Maths and Vector Stuff.html#broadcasting-something-very-special",
    "title": "Tutorial 2: Using Julia for Maths and Vector Stuff",
    "section": "Broadcasting: something VERY special",
    "text": "Broadcasting: something VERY special\nImagine that you want to apply a function, like a log() or exp() function, to an array. We saw above that we can create a vector using collect() and multiply this by a scalar\n\n# sequences in a vector\n# From 0, by 1, to 10...\n\nx = collect(0:1:10)\n\n# see it\nx\n\n11-element Vector{Int64}:\n  0\n  1\n  2\n  3\n  4\n  5\n  6\n  7\n  8\n  9\n 10\n\n\n\n# multply scaler x vector.\nx*10\n\n11-element Vector{Int64}:\n   0\n  10\n  20\n  30\n  40\n  50\n  60\n  70\n  80\n  90\n 100\n\n\nYou can work directly with arrays and pre-built functions to do things like this. To do-so, we combine the function with the (dot) . operator. Let’s work with x_array1 from above. Note how broadcasting the function across the array returns a vector.\n\n# Look at the help file for exp10\nexp_array1 = exp10.(x_array1)\n\n10-element Vector{Float64}:\n     10.0\n    100.0\n   1000.0\n  10000.0\n 100000.0\n      1.0e6\n      1.0e7\n      1.0e8\n      1.0e9\n      1.0e10\n\n\n\n# look at the help file for log - what is the defaul!?\nlog_array1 = log.(x_array1)\n\n10-element Vector{Float64}:\n 0.0\n 0.6931471805599453\n 1.0986122886681098\n 1.3862943611198906\n 1.6094379124341003\n 1.791759469228055\n 1.9459101490553132\n 2.0794415416798357\n 2.1972245773362196\n 2.302585092994046\n\n\nDid you check the help file for log? Is it the same default as we find in R?"
  },
  {
    "objectID": "Tutorial-2_Using Julia for Maths and Vector Stuff.html#matrices",
    "href": "Tutorial-2_Using Julia for Maths and Vector Stuff.html#matrices",
    "title": "Tutorial 2: Using Julia for Maths and Vector Stuff",
    "section": "Matrices",
    "text": "Matrices\nSometimes we’ll be interested in a 2-dimensional or higher version of the array/vector, and this is a matrix. Making a matrix in Julia uses the [ ] again, an separates rows of numbers with the ;\n\nmat = [1 2 3; 4 5 6]\n\n2×3 Matrix{Int64}:\n 1  2  3\n 4  5  6\n\n\nNote how there are NO commas between the numbers in each row! This is read as ‘rows are separated by ; and columns by spaces’!\nYou can also ‘pre-fill’ a matrix with zeros. This is good practice in loops and programming as pre-filling and replacing variables in a matrix is more efficient than creating the matrix on the fly. Here we demonstrate how to pre-fil a vector, matrix and high dimension array! Matrices can have more than two dimensions!\n\nvec0 = zeros(2) # 2 zeros allocated in a vector\n\n2-element Vector{Float64}:\n 0.0\n 0.0\n\n\n\nmat0 = zeros(2,3) # zeros allocated to 2 rows and 3 columns!\n\n2×3 Matrix{Float64}:\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n\n\n\narr0 = zeros(2,3,4) # 2 rows, 3 columns and 4 dimensions!\n\n2×3×4 Array{Float64, 3}:\n[:, :, 1] =\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n\n[:, :, 2] =\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n\n[:, :, 3] =\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n\n[:, :, 4] =\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n\n\nAccessing values in a matrix follows the same convention as with the vector. The convention is [row, column]\n\nmat[1,2] # value in the first row and second column\n\n2\n\n\n\nmat[1:2, 3] # rows 1 AND 2 in the 3rd column\n\n2-element Vector{Int64}:\n 3\n 6\n\n\nFinally, to get a row or column, you need to know that we need a placeholder for the missing bit of what you are asking for. If we want the second row, we ask for row 2, and stick the : placeholder in the column spot:\n\nmat[2,:]\n\n3-element Vector{Int64}:\n 4\n 5\n 6\n\n\nFor a column, we reverse this.\n\nmat[:,2]\n\n2-element Vector{Int64}:\n 2\n 5"
  },
  {
    "objectID": "Tutorial-3_Building and Working with DataFrames.html",
    "href": "Tutorial-3_Building and Working with DataFrames.html",
    "title": "Tutorial 3: Building and Working with DataFrames",
    "section": "",
    "text": "Working with vectors, arrays and matrices is important. But quite often, we want to collect high-dimension data (multiple variables) from our simulations and store them in a spreadsheet type format.\nAs you’ve seen in Tutorial 1, there are plotting macros (@df) within the StatsPlots package that allow us to work with data frame objects from the DataFrames package. A second benefit of the data frame object is that we can export it as a csv file and import this into R where we may prefer working on plotting and statistics.\nTo this end, here we will also introduce the CSV package, which is very handy for exporting DataFrame objects to csv files, and importing them as well, if you’d like."
  },
  {
    "objectID": "Tutorial-3_Building and Working with DataFrames.html#the-data-frame",
    "href": "Tutorial-3_Building and Working with DataFrames.html#the-data-frame",
    "title": "Tutorial 3: Building and Working with DataFrames",
    "section": "The Data Frame",
    "text": "The Data Frame\nTo initialise a dataframe you use the DataFrame function from the DataFrames package:\n\ndat = DataFrame(col1=[], col2=[], col3=[]) # we use [] to specify an empty column of any type and size.\n\n\n0×3 DataFrameRowcol1col2col3AnyAnyAny\n\n\nAlternately, you can specify the data type for each column.\n\ndat1 = DataFrame(col1=Float64[], col2=Int64[], col3=Float64)\n\n\n0×3 DataFrameRowcol1col2col3Float64Int64DataType\n\n\nOf course, col1 is not the only label you provide: variable names are super important and the conventions we use in R are also important here in Julia, e.g. a.b or a_b or AaBa but not a b (no spaces allowed).\n\n# provide informative column titles using:\ndat2 = DataFrame(species=[], size=[], rate=[])\n\n\n0×3 DataFrameRowspeciessizerateAnyAnyAny\n\n\n\nAllocating or adding data to a data frame.\nTo add data to a dataframe, we use the push! command.\n\nspecies = \"D. magna\"\nsize = 2.2\nrate = 4.2\n\n4.2\n\n\n\n# push!() arguments: data frame, data\npush!(dat2, [species, size, rate])\n\n\n1×3 DataFrameRowspeciessizerateAnyAnyAny1D. magna2.24.2\n\n\nOf course, the push!() function can append data to the existing data frame. It is worth noting that push! can only append one row at a time. But since Julia is so good with loops (compared to R), this will make adding data to a dataframe really easy, and we’ll learn how to do this in the next tutorial.\n\nspecies2 = \"D.pulex\"\nsize2 = 1.8\nrate2 = 3.1\n\n# push!() arguments: data frame, data\npush!(dat2, [species2, size2, rate2])\n\n\n2×3 DataFrameRowspeciessizerateAnyAnyAny1D. magna2.24.22D.pulex1.83.1\n\n\n\n\nHelper Functions for Data Frames\nYou can print data frames using println\n\nprintln(dat2)\n\n2×3 DataFrame\n Row │ species   size  rate \n     │ Any       Any   Any  \n─────┼──────────────────────\n   1 │ D. magna  2.2   4.2\n   2 │ D.pulex   1.8   3.1\n\n\nThere are first and last function that are like head and tail in R and elsewhere, with a first argument the data frame and the second argument the number of rows.\n\nfirst(dat2, 2)\n\n\n2×3 DataFrameRowspeciessizerateAnyAnyAny1D. magna2.24.22D.pulex1.83.1\n\n\n\nlast(dat2,2)\n\n\n2×3 DataFrameRowspeciessizerateAnyAnyAny1D. magna2.24.22D.pulex1.83.1\n\n\nAnd as we learned with matrices and arrays, the [row, column] method also works for data frames:\n\ndat2[1,2]\n\n2.2\n\n\n\ndat2[1,:]\n\n\nDataFrameRow (3 columns)RowspeciessizerateAnyAnyAny1D. magna2.24.2\n\n\n\ndat2[:,3]\n\n2-element Vector{Any}:\n 4.2\n 3.1"
  },
  {
    "objectID": "Tutorial-3_Building and Working with DataFrames.html#the-csv",
    "href": "Tutorial-3_Building and Working with DataFrames.html#the-csv",
    "title": "Tutorial 3: Building and Working with DataFrames",
    "section": "The CSV",
    "text": "The CSV\nAs with R, there are functions to read and write .csv files to and from dataframes. This makes interoperability with tools in R and standard data storage file formats easy.\nTo write our daphnia data to a csv file, we use a familiar syntax, but a function from the CSV package.\n\nCSV.write(\"daphniadata.csv\", dat2)\n\nOf course, you can read files in using…. yes, CSV.read. Note the second argument declares the data to go into a data frame.\n\ndaph_in = CSV.read(\"betterDaphniaData.csv\", DataFrame)"
  }
]