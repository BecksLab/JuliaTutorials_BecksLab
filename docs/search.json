[
  {
    "objectID": "Tutorial-6_Extra Tips and Tricks.html",
    "href": "Tutorial-6_Extra Tips and Tricks.html",
    "title": "Tutorial 6: Extra Tips and Tricks",
    "section": "",
    "text": "Some quick tips that we’ve learnt the hard way…\n\nIn the REPL, you can use the up arrow to scroll through past code\nYou can even filter through your past code by typing the first letter of a line previously executed in the REPL. For example, try typing p in the REPL and using the up arrow to scroll through your code history, you should quickly find the last plot command you executed.\nToggle word wrap via View>Toggle Word Wrap or alt-Z\nRed wavy line under code in your script = error in code\nBlue wavy line under code in your script = possible error in code\nErrors and possible erros can be viewed in the PROBLEMS section of the REPL\nYou can view your current variables (similar to the top right hand panel in RStudio) by clickling on the Julia explorer: Julia workspace symbol in the activity bar (three circles). You can then look at them in more detail by clicking the sideways arrow (when allowed).\n\n\nCOPYING versus DEEP COPYING :-)\n\nJulia has a strange copying aspect where if a=b, any change in b will automatically cause the same change in a. For example, let’s make an array of three numbers:\n\n\naa = [1,2,3]\n\n3-element Vector{Int64}:\n 1\n 2\n 3\n\n\nHere we make a copy of aa and call it bb.\n\nbb = aa\nprint(bb)\n\n[1, 2, 3]\n\n\nNow, we replace the second element of bb with the value 41.\n\nbb[2] = 41\nbb\n\n3-element Vector{Int64}:\n  1\n 41\n  3\n\n\nThe default behaviour of = in Julia is to UPDATE any copy of the array, also:\n\naa\n\n3-element Vector{Int64}:\n  1\n 41\n  3\n\n\nWhoa… that’s not what we expect, though it’s pretty cool. This approach is advantageous because it lets Julia save memory, however, it is not ideal.\nTo remedy this, and create copies that don’t update their parent or other offspring, we can force c to be an independent copy of a using the deepcopy function:\n\ncc = deepcopy(aa)\n\n3-element Vector{Int64}:\n  1\n 41\n  3\n\n\n\ncc[3] = 101\naa,cc\n\n([1, 41, 3], [1, 41, 101])\n\n\n\nYou can view a .csv or .txt file by clicking on a file name in the project directory (left panel) - this opens a viewing window. CSV’s also have a built in ‘Preview’ mode - try using right click>Open Preview on a .csv file and check it out."
  },
  {
    "objectID": "Tutorial-5_Plotting in Julia.html",
    "href": "Tutorial-5_Plotting in Julia.html",
    "title": "Tutorial 5: Plotting in Julia",
    "section": "",
    "text": "In R, the plotting of data is either done in base R or via the ggplot2 package. If you’re a base R person, you’ll probably feel more comfortable with the Plots package. Alternatively, if you prefer ggplot2, the StatsPlots and Gadfly package is the closest thing you’ll find in Julia. We’ll introduce both in the following sections.\nIt is worth noting that Julia is based on a ‘Just in Time’ compiler (or JIT) so the first time you call a function it needs to compile, and can take longer than expected. This is especially true when rendering a plot. Consequently, the first plot you make might take some time but it gets significantly faster after that."
  },
  {
    "objectID": "Tutorial-5_Plotting in Julia.html#plots",
    "href": "Tutorial-5_Plotting in Julia.html#plots",
    "title": "Tutorial 5: Plotting in Julia",
    "section": "Plots",
    "text": "Plots\nAs you saw in Tutorial 2, we can make plots out of variables very easily with the plot function.\n\nRandom.seed!(12345)\nx = 1:100\ny = rand(100)\n\n# label is for the legend/key\n# lw = linewidth\nplot(x, y, label = \"amazing\", title = \"not amazing\", lw = 3)\n\n\n\n\nIf you want to add more data to a plot, the plot!() function is super valuable, and complemented by the xlabel!() and ylabel!() function to update the x-axis\n\ny2 = rand(100) # another 100 randoms\nplot!(x, y2, label = \"less amazing\")\nxlabel!(\"time is not your friend\")\nylabel!(\"ooh la la la\")\n\n\n\n\nRecall too that there is a seriestype argument to shift between the default line and, perhaps a scatterplot. Note that we can deliver both y and y2.\n\nplot(x, y, seriestype = [:line,:scatter], markershape = :diamond, lc = :orange, mc = :black, msc = :orange, label = \"Y\")\nplot!(x, y2, seriestype = [:line,:scatter], markershape = :diamond, lc = :blue, mc = :black,  msc = :blue, label = \"Y2\")\n\n\n\n\nmc is for marker colour, msc is the colour of the line around the marker/shape and lc is for line color.\nOf course, there is a scatter() plot function\n\nscatter(x, y)\n\n\n\n\n\nGrouping Variables in Plots\nJulia’s Plots.jl library does some basic work with grouping variables too, linking to key ideas about tidy data. Let’s look at some sample data where we have 12 data points (stability0 with 4 replicate observations from three networks (Network_1, Network_2 and Network_3).\n\nsample_data = DataFrame([rand(12), repeat([\"Network_1\",\"Network_2\",\"Network_3\"],4)], [\"stability\", \"network\"])\n\n\n12×2 DataFrameRowstabilitynetworkFloat64String10.0491108Network_120.699192Network_230.158122Network_340.470745Network_150.625568Network_260.997392Network_370.572846Network_180.580858Network_290.141685Network_3100.764872Network_1110.690545Network_2120.137958Network_3\n\n\nPlotting the data, by group, is accomplished like this (note the use of the . to connect the dataframe to the variable name)\n\nplot(sample_data.stability, group=sample_data.network)\n\n\n\n\nThis is a pretty silly plot because the x-axis makes no sense. We might have wanted a bar-chart instead.\n\ngroupedbar(sample_data.stability, group = sample_data.network)\n\n\n\n\nWe’ll see below how the package StatsPlots makes this easier and more flexible (a bit more like ggplot2).\n\n\nSaving Plots\nPlots can be saved and outputted using savefig or by using an output marco (e.g. png or pdf). savefig saves the most recent plot (.png is default format) or you can name figures e.g., p1, and use that reference name to save the plot object at any time:\n\n#not run\nsavefig(p1, \"path/to/file/p1.png\")\npng(p1, path/to/file/p1\")\npdf(p1, path/to/file/p1\")\n\nOnce you’ve created a plot it can be viewed or reopened in VS Code by navigating to the Julia explorer: Julia workspace symbol in the activity bar (three circles) and clicking on the plot object (e.g., p1). We advise that you always name and assign your plots (e.g. p1, p2, etc). The Plots package also has it’s own tutorial for plotting in Julia."
  },
  {
    "objectID": "Tutorial-5_Plotting in Julia.html#statsplots",
    "href": "Tutorial-5_Plotting in Julia.html#statsplots",
    "title": "Tutorial 5: Plotting in Julia",
    "section": "StatsPlots",
    "text": "StatsPlots\nAs you saw in the Setup introduction, we can also use the StatsPlots package for plotting. This approach invokes a background macro that allows you to use the DataFrames structure to deliver nice plots.\n\n# make a second data frame with three variables\n# using DataFrame directly to create variables\ndf2 = DataFrame(a=1:10, b=10*rand(10), c=10*rand(10))\ndf2\n\n\n10×3 DataFrameRowabcInt64Float64Float64110.8157936.88707223.753992.40944339.760621.53078449.964353.45292554.19571.77534668.545171.37223777.833734.74956888.69492.89649995.101120.93078910107.899568.68376\n\n\nThe use of the @df macro from StatsPlots is a three step process:\n\ndeclare the @df macro\ndefine the data frame\ndeclare the columns, using the : symbol.\n\n\n# plot the data using the data frame macro\n# declare the df macro, declare the data frame, use : to signify columns\n# note that the default is `x then y`.\n@df df2 plot(:a, :b)\n\n\n\n\nOne of the handy things about the @df macro and StatsPlots is the ability to add two or more variables at once:\n\n# the same, and plotting two y variables (b and c)\n@df df2 plot(:a, [:b, :c])\n\n\n\n\nThere are several helper functions too. For example, instead of the [[:b, :c] approach to multiple columns, there is a cols argument.\n\n@df df2 plot(:a, cols(2:3), colour = [:red :blue])\n\n\n\n\nFinally, coming back to the example above for plots using the sample_data dataframe with a grouping variable, we can see how StatsPlots mimics some of the faceting options and group options from ggplot2.\nFirst, the three groups in the same figure with an informative legend.\n\n@df sample_data plot(:stability, group = :network, legend = :topleft)\n\n\n\n\nSecond, the same data but in three panels.\n\n@df sample_data plot(:stability, group = :network, layout = 3)\n\n\n\n\nAnd following the standard Plots.jl example for grouped bars….\n\n@df sample_data groupedbar(:stability, group = :network)"
  },
  {
    "objectID": "Tutorial-5_Plotting in Julia.html#gadfly",
    "href": "Tutorial-5_Plotting in Julia.html#gadfly",
    "title": "Tutorial 5: Plotting in Julia",
    "section": "Gadfly",
    "text": "Gadfly\nThere is a actively developed package called Gadfly which implements an interpretation of the ggplot2 grammar of graphics. It has been finicky and unstable for us in the past, but you are welcome to try it. To use it, you need to install the package with the ] add Gadfly first step, and then using Gadfly in the top of your script.\nA tutorial and set of examples can be found here"
  },
  {
    "objectID": "Tutorial-1_Downloads Setups and Your First Project.html",
    "href": "Tutorial-1_Downloads Setups and Your First Project.html",
    "title": "Tutorial 1: Downloads, Setups and Your First Project",
    "section": "",
    "text": "Julia\nNavigate to this page and follow the platform-specific instructions to dowload and install Julia (we recommend installing the current stable release).\nDuring the installation process, you may be prompted to add Julia to the PATH, this box should be ticked.\nVSCode\nNavigate to this page to dowload and install your platform specific Visual Studio Code (not Visual Studio or Visual Studio for Mac)."
  },
  {
    "objectID": "Tutorial-1_Downloads Setups and Your First Project.html#setting-up-vscode-to-use-julia",
    "href": "Tutorial-1_Downloads Setups and Your First Project.html#setting-up-vscode-to-use-julia",
    "title": "Tutorial 1: Downloads, Setups and Your First Project",
    "section": "Setting Up VSCode to use Julia",
    "text": "Setting Up VSCode to use Julia\nVS Code is a free source-code editor, allowing you to code in multiple coding languages all from a platform that is completely customisable to the user. This flexibility is great but it does mean that you need to spend time telling VS Code what it is you want to do and how. This is where extensions come in; extensions are higher level packages that permit the use of a given coding language like Julia, edit your themes and icons, and provide helpful applications like spell checker or Bracket Pair Colorizer.\nTo install Julia in VS Code do the following (you only need to do this once):\n\nopen VS Code (you’ll see the welcome page)\nnavigate to the ‘Marketplace’ (5th symbol down in the activity bar - vertical panel on the lefthand side of the screen)\n\n\n\n\nThe Marketplace Button\n\n\n\nsearch for Julia in the ‘Search Extensions in Marketplace’ search bar\ninstall Julia, this extension provides support for the Julia programming language and install Julia Formatter, this extension will help you write clean code that is easier to read\n\n\n\n\nSelecting the Julia Language Support and Formatter"
  },
  {
    "objectID": "Tutorial-1_Downloads Setups and Your First Project.html#making-your-first-julia-project",
    "href": "Tutorial-1_Downloads Setups and Your First Project.html#making-your-first-julia-project",
    "title": "Tutorial 1: Downloads, Setups and Your First Project",
    "section": "Making your first Julia project",
    "text": "Making your first Julia project\nAs with working in R and RStudio, we advocate working in a contained project environment when using Julia. Each unique project may require a different setup (e.g. packages, package versions, working directories, data locations, etc.).\nTo set up a project in VS Code:\n\nCreating a folder at a location of your choosing (e.g. within your Documents folder). This can be on GoogleDrive, Dropbox or OneDrive. This is OK.\nName the folder with relevant works. Here we will use Julia - VS code - how to.\nNavigate to VSCode and open your new project by clicking on the ‘Explorer’ symbol (top left symbol on the activity bar) and click Open Folder and navigate your finder or explorer to the Julia - VS code - how to folder.\n\n\n\n\nOpening Your Project\n\n\n3.1 this folder becomes the working directory (same as when using an .RProject in R)\n\nCreate a new file (a script) in your directory: do this by using cmd-N (mac) or ctrl-N (windows) or File -> New File or by left clicking -> New File within the directory pane\nName your script as your see fit but please rememeber to include the .jl file extension (e.g. JuliaTuto.jl). the .jl file extension tells VS Code you want to use the Julia programming language. To save your script at any time use cmd-S (MAC) OR ctrl-S (windows) or File > Save.\n\n5.1 Note, you can also open a project in VS Code by right-clicking on your folder (in Finder, Windows file explorer or Linux nautilus) and selecting Open with -> Other -> VS Code.\n\nActivating the REPL and running some code.\nThis sequence of figures aligns with the instructions below.\n\n\n\nInitiating and using the REPL\n\n\nNow that you have an active project and a new script file you can open the Julia REPL. REPL stands for read, execute, print and loop. The REPL is like the console in R and is where the magic happens. In Eva’s words, it’s VS Code’s way of using Julia for a brain.\nTo do this you type F1 or cmd/cntrl - shift-p or View -> Command Palette and choose Julia REPL. The command palette will appear as a drop down menu with a search function at the top of the page.\nNow that you have an interface with Julia as a brain, you can actually do something! Try this: type print(\"Hello world\") in the REPL and press Enter/Return. If you’ve done all of the above correctly, Hello world should print in the REPL.\nNow, you can also make a ‘script’. Type ctrl-n or cmd-n and a document will open at the top. There will be a prompt/link to select your language. Click the link and, yes, search for and choose Julia.\nNext, type print(\"Hello world\") in the script. Just like RStudio, you can send the information in the script to the REPL. There are two ways to do this. First, and probably what you’ll want, is shift-enter(return). This will send the line of code you are on, and move to the next line. ctrl-enter(return) submits the line but does not move the cursor. Try it!"
  },
  {
    "objectID": "Tutorial-1_Downloads Setups and Your First Project.html#activating-your-project-the-project.toml-and-manifest.toml",
    "href": "Tutorial-1_Downloads Setups and Your First Project.html#activating-your-project-the-project.toml-and-manifest.toml",
    "title": "Tutorial 1: Downloads, Setups and Your First Project",
    "section": "Activating your project, the project.toml and manifest.toml",
    "text": "Activating your project, the project.toml and manifest.toml\nWe mentioned above that it is good practice to work within an environment specific to each project. The Julia package manager (Pkg) allows you to do that easily: Unlike traditional package managers, which install and manage a single global set of packages, Pkg is designed around environments: independent sets of packages that can be local to an individual project or shared and selected by name (text taken directly from the documentation).\nThe project environment is stored via two files:\nProject.toml - stores a list of packages that have been installed and their versions (very useful when sharing code as any user can see exactly what version of a package has been used)\nManifest.toml - does the same thing but for all the package dependencies (other packages that are essential, or form functional parts, of the package you want to use)\nThese files are created and modified automatically as you invoke the use of various packages.\n\nGetting started: activating your project.\nActivating your project is something that only needs doing once per computer. It allows you to add packages and dependencies to the project.\nIf you move the project to a new computer, or share the project, activation will be needed again.\nThere are two ways to activate your project.\n\ntype Pkg.activate(\".\") in the REPL.\ntype ] in the REPL and then activate .\n\nThe ] is a shorthand for using the Pkg package and opens the package manager. To get out of this, you press the backspace/delete button on your keyboard.\nThere are two ways to double check that you are actually working within your project:\n\ncheck/click the ‘Julia env:…’ on the bottom of your screen (blue bar), it should match your project name\nenter the package manager by typing ] in the Julia REPL, you should see (your-project-name) pkg> instead of julia>. Again, exit the package manager using backspace/delete button.\n\n\n\nWorking with the package manager and growing the project and manifest files\nOnce your project is activated, there are two ways to use the package manager (Pkg):\n\ndirectly from the REPL:\n\n\nnavigate to the REPL\ntype ]\nyou will see that instead of seeing julia> you now see (your-project-name) pkg>, indicating that all the packages that you now install (or update) will be installed (or updated) within this specific project\nto add a package, use the function add: ] add Plots\n\n\nusing Pkg (this is useful when you want to install packages or manage them from within your script):\n\n\nfirst type import Pkg and execute this line using shift-Enter\non subsequent lines, add, remove and update packages from your script using Pkg functions such as Pkg.add(), Pkg.remove() or Pkg.update().\nTo add a packages, the name of the package need to be written with quotes (Pkg.add(\"Plots\")).\n\n\nAn example using the Plots package\nNow that we are all set up, we are going to install a package, check the project’s status and remove a package. As this might be your first time installing a package (e.g., Plots), don’t be concerned if it takes a couple of minutes to run.\n\ntype ] add Plots in the REPL (or Pkg.add(\"Plots\")) in your script and execute using Ctrl-Enter.\n\nyou just installed the Plots package and a whole bunch of dependencies that Plots needs to work. This is equivalent to Base plots in R. Note that if you used Pkg.add(\"Plots\") this is the equivalent to using the install.packages() function in R.\n\n\n\n\n\nPackage Installing\n\n\n\ntype ] st in the REPL. This will check the status of your project and print the content of your Project.toml file, which is the list of main packages, in this case, just Plots.\n\nyou should see something like:\n\n\n\nPackage Status Check"
  },
  {
    "objectID": "Tutorial-1_Downloads Setups and Your First Project.html#gearing-up-to-do-more-stuff-what-packages-do-i-need.",
    "href": "Tutorial-1_Downloads Setups and Your First Project.html#gearing-up-to-do-more-stuff-what-packages-do-i-need.",
    "title": "Tutorial 1: Downloads, Setups and Your First Project",
    "section": "Gearing up to Do More Stuff (what packages do I need).",
    "text": "Gearing up to Do More Stuff (what packages do I need).\nThere are a core set of packages we use for all of our work. These 10 packages are almost always installed when we make a project.\nGo ahead and use either the ] or Pkg.add(\"package.name\") method to add all of these to your project.\n\nFor working with data\nCSV DataFrames DelimitedFiles\n\n\nFor plotting\nPlots\n\n\nFor statistical things\nStatistics Random Distributions StatsBase StatsPlots\n\n\nFor Modelling\nDifferentialEquations"
  },
  {
    "objectID": "Tutorial-1_Downloads Setups and Your First Project.html#your-first-script-setup.",
    "href": "Tutorial-1_Downloads Setups and Your First Project.html#your-first-script-setup.",
    "title": "Tutorial 1: Downloads, Setups and Your First Project",
    "section": "Your first script setup.",
    "text": "Your first script setup.\nAt this stage, you should have a good understanding about how to create a project folder, activate a project, start the REPL, open a script and add packages to the project.\nNow you are ready to ‘setup’ your first script.\n\ncreate a new script file (ctrl-n or cmd-n).\nchoose Julia as the language\nType some informative information at the top of the script\n\njust like in R and other programming languages, the # is a commenter.\n\nThe first section of your script is where you declare the packages you’ll be using.\n\nthe function to do this is using.\nmake Plots, Random and DataFrames available.\n\n\nNow you are ready to do something really simple. Let’s make some variables, data frames and a few simple plots.\nFirst, lets get the setup sorted and packages available\n\n# This is my first example script\n# 25 Jan 2023\n\n# packages I need\nusing Random, DataFrames, Plots, StatsPlots\n\nSecond, let’s make some variables and see how Julia print them to the screen\n\n# make two variables using the rand function\n# because we are using random numbers, we'll set the seed here for reproducibility\n\nRandom.seed!(12345)\n\nx = rand(10)\ny = rand(10)\n\nx\n\n10-element Vector{Float64}:\n 0.7918054038647908\n 0.1595789996994108\n 0.33419142747606\n 0.8113922657011057\n 0.7966292033537833\n 0.9178138221831842\n 0.31132682723725014\n 0.7529056805990061\n 0.6338479453532103\n 0.8999510969166794\n\n\nCool. Now, lets create two data frames, one made of the x and y variables, and another with three variables made directly in a call to DataFrame.\n\n# combine into a data frame using the DataFrame function\ndf = DataFrame(x = x, y = y)\ndf\n\n\n10×2 DataFrameRowxyFloat64Float6410.7918050.33026320.1595790.42198730.3341910.68530740.8113920.295850.7966290.97365960.9178140.2445970.3113270.46875180.7529060.27705590.6338480.629916100.8999510.121805\n\n\n…and the second\n\n# make a second data frame with three variables\n# using DataFrame directly to create variables\ndf2 = DataFrame(a=1:10, b=10*rand(10), c=10*rand(10))\ndf2\n\n\n10×3 DataFrameRowabcInt64Float64Float64110.5634039.77384227.226793.58869330.4666423.76688444.594899.03599550.4911088.73964666.991921.36299771.581220.815793884.707453.75399994.975720.59976110104.586752.14792\n\n\nGreat. Now, lets see how to plot the ‘solo’ variables. Note how we specify the seriestype. Try getting rid of this….\n\n# plot the data using x and y, as a scatterplot\nplot(x, y, seriestype=:scatter)\n\n\n\n\nSuperb. So, StatsPlots provides a special macro to use a dataframe with plots. It’s a three step process:\n\ndeclare the @df macro\ndefine the data frame\ndeclare the columns, using the :\n\n\n# plot the data using the data frame macro\n# declare the df macro, declare the data frame, use : to signify columns\n@df df plot(:x, :y)\n\n\n\n\nAnd here, we use the df2, and plot variable b and c vs. a.\n\n# the same, and plotting two y variables\n@df df2 plot(:a, [:b, :c])\n\n\n\n\n\nA quick briefing about data frames in Julia versus R and dplyr is here\nDataFrames Comparison R dplyr)"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Julia and the BEFWM2 using VSCode",
    "section": "",
    "text": "This set of tutorials is designed to help you use an integrated coding tool, VSCode, to run experiments with the Bioenergetic Foodweb Model, built in the coding language Julia.\nIt will cover four core objectives\n\nacquire/install the Julia programming language, the Integrated Development Environment called VSCode, and the Bioenergetic Food Web Model written in the Julia programming language.\nLearn how to work with Julia programming, from installing packages to understanding arithmetic and plotting and data frames\nLearn how to simulate a simple predator-prey (consumer-resource) model using the DifferentialEquations package in Julia\nLearn how to implement and use the multi-species BioenergeticFoodWebModel in Julia\n\nHaving done these, you will then be introduced to further complexities and opportunties.\n\n\nIf you are a user of R and RStudio, you are likely familiar with setting RStudio and R up to use a project file, the .RProject inside a project folder. You are also used to downloading and installing packages into R on your computer, and then invoking their use in each script using the library() function.\nIn the world of VSCode and Julia, we do something similar. You will create project folders, just like we recommend for R. Inside this folder, two files will be created, the Project.toml and the Manifest.toml. These are not really the same as the .RProject file. In Julia, each project has a set of packages that are associated with it. This is different from the more ‘global’ installation of packages in R.\nThere are some parallels… first, adding packages in Julia uses the Pkg toolbox and gets them from the Julia Language Ecosystem. This is like downloading them from CRAN for R. Second, making packages available for use in a Julia script requires the using function, which is a lot like the library() function.\nAnyhow, the goal IS to try and make a workflow for Julia and VSCode that acts like the R and RStudio setup you are familiar with.\n\n\n\nThe simple idea here is to make a Julia script and add the code in these tutorials to your scripts. Make sure you annotate using the # symbol, as we do in R Scripts. We suggest that You have a script associated with each section of the table of contents on the left."
  },
  {
    "objectID": "Tutorial-7_Intro To Differential Equations.html",
    "href": "Tutorial-7_Intro To Differential Equations.html",
    "title": "Tutorial 7: Introducing Differential Equations",
    "section": "",
    "text": "This document illustrates how to construct and solve differential equations in Julia using the DifferentialEquations.jl package.\nIn particular, we are interested in modelling a two species Lotka-Volterra like (predator-prey/consumer-resource) system. Such systems are fundamental in ecology and form the building blocks of complex networks and the models that represent them.\nFor this tutorial you’ll need the following two packages:\n\nDifferentialEquations.jl to solve the differential equations (same ‘engine’ as the one used by the BioEnergeticFoodWebs.jl model)\nPlots.jl to visualise the results\n\nWhile we already have Plots.jl in this project, we just need to ] add DifferentialEquations.\nThe DifferentialEquations.jl can be a tad clunky so the below code might take a while to compile. If you hit errors, we recommend removing (] rm DifferentialEquations) and reinstalling (] add DifferentialEquations) the package.”\nYou probably want to start a new script for this exercise. File -> New File -> julia\n\nAn introduction to Differential Equations.\nDifferential equations are frequently used to model the change in variables of interest through time. These changes are often referred to as derivatives (or du/dt). In this case, we are interested in modelling changes in the abundance of a consumer and its resource as a function of the system’s key processes (growth, ingestion of food/foraging and mortality) and its parameters.\nThis type of model can be formalised as a simple Lotka-Volterra predator prey model, consisting of a set of differential equations:\n\nResource dynamics: \\(\\frac{dR}{dt} = r R (1-\\frac{R}{K}) - \\alpha R C\\)\nConsumer dynamics: \\(\\frac{dC}{dt} = e \\alpha R C - m C\\)\n\nwhere \\(R\\) and \\(C\\) are the abundances of the resource and consumer respectively, \\(r\\) is the resource’s growth rate, \\(K\\) is the producer’s carrying capacity, \\(\\alpha\\) is the consumer’s ingestion rate, \\(e\\) is the assimilation efficiency and \\(m\\) is the consumer’s mortality rate.\nTo recall from your ecology modules, this is a system of equations with logistic growth for the producers (plants) and a Type I functional response describing how consumer foraging (the loss of prey caused by predators eating them) varies with prey density, a simple conversion efficiency that translates the functional response (eating the prey) into babies of the consumer (predator reproduction) and then a mortality rate for the consumer/predator.\nA few details to note.\n\nthere is only one source of density dependence in this model/system - logistic growth of the producer. Density dependence is required to generate coexistence and stability.\nthe type I functional response means that the consumer foraging rate increases with prey density and does not saturate. It means that the mortality rate that consumers impose on the prey is constant and independent of the prey density. It is thus density independent and does not contribute to stability. There are two other functional responses. The Type II, which has saturating consumption rate and generates inverse density dependence, and the Type III, which has accelerating consumption rate with prey density, and thus generates increasing mortality in the prey with increasing prey density, and thus density dependence. It is only Type III functional responses that are linked to consumers/predators stabilising their prey populations. It is also a pretty rare functional response!\nthe consumer mortality rate is also constant and thus density independent.\n\n\n\nHow does this relate to the Bioenergetic Food Web Model?\nThe complex model of consumer - resource interactions that is represented by the BEFW model has at it’s heart two equations: one for producers and one for consumers. So at it’s heart, it is not too different in structure to the model above! However, the differences, spelled out in this [paper] and this [paper], are\n\nthe paramters are functions of body size\nbecause of this, we can expand the number of resource and consumer equations for multiple values of body size\nthis creates a potentially big system of equations, instead of just 2.\n\nHowever, and this is important, the process of solving these equations, whether it is two of them, or 100 of them, is essentially what we are introducing below. If you were to look inside of the BEFW model, you would see the same functions and structure as we introduce here.\n\nThe Three Steps For Simulating Food Web Dynamics\nThere are 3 major steps involved in constructing and solving this model in Julia (these happen to be the same three steps in all programming languages, including R where the deSolve package accomplishes much of this same functionality):\n\nDefine a function for your model (i.e., transform the above differential equations into a function that can be read by the solver). This function tells the solver how the variables of interest (here \\(R\\) and \\(C\\)) change over time.\nDefine the problem. Here, the problem is defined by the function, the parameters (\\(r\\), \\(\\alpha\\), \\(e\\) and \\(m\\)), the initial conditions and the timespan of the simulation. In this step you provide the solver with all the details it needs to find the solution.\nSolve!\n\n\n\nStep 1. Define the function\nHere we construct a function for our model. The function needs to accept the following:\n\ndu (derivatives) - a vector of changes in abundance for each species\nu (values) - a vector of abundance for each species\np (parameters) - a list of parameter values\nt (time) - timespan\n\n\nfunction LV_model(du,u,p,t)\n   # growth rate of the resource (modelled as a logistic growth function)\n   GrowthR = p.growthrate * u[1] * (1 - u[1]/p.K) \n   # rate of resource ingestion by consumer (modelled as a type I functional response)\n   IngestC = p.ingestrate * u[1] * u[2]\n   # mortality of consumer (modelled as density independent)\n   MortC = p.mortrate * u[2]\n   # calculate and store changes in abundance (du/dt):\n   # change in resource abundance\n   du[1] = GrowthR - IngestC\n   # change in consumer abundance\n   du[2] = p.assimeff * IngestC - MortC\nend\n\nLV_model (generic function with 1 method)\n\n\nYou’ll notice that in the above function (LV_model), we’ve specified specific parameters using the p.name notation. This is because we’ve opted to store our parameters in a named tuple called p. p is created below but it’s worth noting that when this notation is used e.g., p.growthrate, we are telling Julia that we want to use the value of growthrate that is stored as a named part of our tuple (a fancy name for an object in Julia) p.\n\n\nStep 2. Define the problem\nTo define the problem we first have to fix the system’s parameters, the initial values and the timespan of the simulation:\n\np = (\n    growthrate = 1.0, # growth rate of resource (per day)\n    ingestrate = 0.2, # rate of ingestion (per day)\n    mortrate = 0.2,   # mortality rate of consumer (per day)\n    assimeff = 0.5,   # assimilation efficiency\n    K = 10            # carrying capacity of the system (mmol/m3)\n    )\n\n(growthrate = 1.0, ingestrate = 0.2, mortrate = 0.2, assimeff = 0.5, K = 10)\n\n\nHere, we have chosen to define p as a named tuple (similar to a list in R). A vector or dictionary would also work, however, named tuples are advantageous because they allow us to use explicit names and are unmutable meaning that once it’s created you can’t change it.\n\nInitial values: For simplicity, we start with \\(R = C = 1\\):\n\n\nu0 = [1.0; 1.0]\n\n2-element Vector{Float64}:\n 1.0\n 1.0\n\n\n\nTimespan:\n\n\ntspan = (0.0,100.0) # you have to use a Pair (tuple with 2 values) of floating point numbers.\n\n(0.0, 100.0)\n\n\nWe then formally define the problem by passing the function (LV_model), the parameters (listed in our named tuple p), the initial values (u0) and the timespan (tspan) to ODEProblem():\n\nprob = ODEProblem(LV_model, u0, tspan, p)\n\n\nODEProblem with uType Vector{Float64} and tType Float64. In-place: true\ntimespan: (0.0, 100.0)\nu0: 2-element Vector{Float64}:\n 1.0\n 1.0\n\n\n\n\n\nStep 3. Solve\nTo solve the problem, we pass the ODEProblem object to the solver.\nHere we have chosen to use the default algorithm because it’s a simple problem, however there are several available - see here for more information. These two final steps (define and solve the problem) are analogous to using the deSolve package in R.”\n\nsol = solve(prob)\n\nThe solver produces 2 objects: sol.t and sol.u that respectivley store the time steps and the variables of interest through time. Let’s have a look.\n\n\nStep 4. Visualise the outputs”\nOnce the problem has been solved, the results can be explored and plotted. In fact, the DifferentialEquations.jl package has its own built in plotting recipe that provides a very fast and conventient way of visualing the abundance of the two species through time:\n\nplot(sol, \n    ylabel = \"Abundance\", \n    xlabel = \"Time\", \n    title = \"Lotka-Volterra\", \n    label = [\"prey\" \"predator\"], \n    linestyle = [:dash :dot], \n    lw = 2) \n\n\n\n\nOne thing to note here, when plotting in Julia you don’t need to seperate label names (label = [prey predator]) or linestyles (linestyle = [:dash :dot]) with a comma as you would in R. This will also be case for most plotting options in Julia.\n\n\nStep 5. Play some games\nNow that you see how this works, perhaps you can do a bit of an experiment by varying things in the p = (paramters) part of the code?\n\nCan you increase the number of time steps?\nWhat happens when you increase K?\nWhat happens when you increase or decrease growthrate?\nWhat happens when you change the ingestrate\n\n\n\nEXTRA CREDIT\nIf you are really keen…. how about trying to run the model in a loop over 3 values of growthrate, collect the final population size of the consumer and resource in a data frame with three columns (growthrate, finalCons, finalRes), and plot these values?"
  },
  {
    "objectID": "Tutorial-9_Experiments with the BEFWM2.html",
    "href": "Tutorial-9_Experiments with the BEFWM2.html",
    "title": "Tutorial 9: Experiments with the BEFWM2",
    "section": "",
    "text": "In the previous chapter, we learned how to make networks and run a simulation. We did this for a simple tri-trophic chain where we specified the network with a matrix of ones and zeros, and for a more complex network defined by the niche model where we specified species richness and connectance. We also learned how to visualise the simulations and to collect several metrics about the simulations, including detail on biomass, diversity and stability.\nIn this tutorial, we are going to learn how to do experiments. We’ll learn first how to generate multiple networks and collect information on how network structure impacts our metrics. Then we’ll learn how to manipulate parameters in the model, again collecting information on how variation in these parameters impacts our metrics.\nFor example, we might be interested in how species richness or connectance impacts biomass and stability. Or how the carrying capacity of the producers impacts biomass and stability of the community (e.g. bottom up processes). We’ll look at both of these.\n\nGetting Setup\nAs with our previous exercises, we need to have a few packages that allow making networks, simulating them and collecting the data\n\nusing DataFrames, Plots, Random, Distributions\nusing EcologicalNetworks, EcologicalNetworksPlots, EcologicalNetworksDynamics\n\n\n\nYour (re)introduction to loops: making multiple networks example\nOne of the tricks to doing experiments is learning how to run a loop. Julia is super-fast with running loops. This is a bit different to R, which has a bad rep for loops. It’s not terrible. But Julia is built to do loops fast.\nWhat we will do here is build a simple loop that makes 3 networks, each with a different species richness, but the same connectance.\n\nRandom.seed!(12325) # ensures your network and this one are the same\n\nS = [10,20,30]; # define the number of species\nC = 0.2; # define the connectance (complexity) of the network\n\n# collection zone for the networks\nnets = []\n\n# construct the food webs\n# we loop over the 3 values of S\n# we use push!() to add the food webs to nets\n# always start with a for and end with an end.\nfor i in 1:3\n    push!(nets, FoodWeb(nichemodel, S[i]; C=C, tol = 0.01))\nend\n\nGreat. Let’s see if we got what we expected in nets.\n\nnets\n\n3-element Vector{Any}:\n FoodWeb(S=10, L=21)\n FoodWeb(S=20, L=77)\n FoodWeb(S=30, L=184)\n\n\nMagnificent, we have three networs and that’s a win. We also see that they are each for a different and appropriate S. Win no. 2. We can actually now check to see what the connectances actually are. Again, we’ll use a loop, println and introduce you to the details of the FoodWeb object.\nFirst, let’s look at one of the networks.\n\nnets[1]\n\nFoodWeb of 10 species:\n  A: sparse matrix with 21 links\n  M: [1.0, 1.0, ..., 1.0, 1.0]\n  metabolic_class: 3 producers, 7 invertebrates, 0 vertebrates\n  method: nichemodel\n  species: [s1, s2, ..., s9, s10]\n\n\nWe can see that the A element is the matrix and you can guess that the M is the body Masses. We also find tha there are 3 producers and 7 invertebrates and it is derived from the niche model\n\na side note on the metabolic classes. The default parameterisation, and nearly all of the published work with the BEFW, uses invertebrates for all the non-producer species. It is possible to include others. But the data, currently, are not helpful (low volume) in supporting robust inference with these types of species.\n\nNow, recall that we can look specifically at the matrix by using nets[1].A which grabs the A part. We can also remember that sum applied to a matrix counts all the 1’s…. thus is the estimate of the links. Finally, recall that size applied to the network returns two numbers - the rows and columns. For our networks, the matrix is square. So grabbing one of these (rows = [1]) and squaring it delivers our ‘potential number of links’ (e.g. \\(species^2\\)). We can put that all together here to define connectance as \\(Con = links/S^2\\)\n\nfor i in 1:3\n    println(sum(nets[i].A)/size(nets[i].A)[1]^2)\n    end\n\n0.21\n0.1925\n0.20444444444444446\n\n\n\nDifferent ways to run loops.\nThere is another way to make this set of networks. Here we use a while loop to create 3 networks with the same species richness and connectance. We might need to do this to generate replicates. This is a good exercise with the niche model as it reminds you that it is a probabilistic tool… you can get several networks with the same S and C, but the links will be in slightly different places.\nwhile loops work on conditions… for example, if we want three networks, we could ask that the loop keep working to make the networks until we have three. To do this, we need a monitoring variable that lets us assess where we are against our target.\nLets see how to do that.\n\n# how many replicates do we want?\nreps = 3\n\nbegin\n    # list to store networks\n    global networks = []\n    # monitoring variable l (the letter l)\n    global l = length(networks)\n\n    # while loop\n    while l < reps # reps is 3 here...\n        # generate a network\n        A = FoodWeb(nichemodel, 20; C=0.15, tol = 0.01)\n        # add the network to the set\n        push!(networks, A)\n        # update the monitor\n        global l = length(networks)\n    end\nend\n\nThe term global means that the obects are made available in our global environment and should be there for us to see. If you look closely at the mini-matrices, you’ll see they are all different in micro-structure, despite having the same number of links and the same connectance.\n\nNOTE: the presentation of the matrix is very specific here… the rows correspond to the predators and the columns the resources. Obstensibly, the ranking is by body size, so small things are at the upper left. This view shows that big things tend to eat small and big things, while small things eat small. Historically, the reflection (pivot around the diagnol) has also been used, where the predators are the columns and the resources the rows. This lead to a ‘feature’ of real and theoretical networks aligning, call upper triangularity. In this latter presentation, most of the links would be in the upper triangle. In the current presentation, the links are in the lower triangle. So we can just call the feature triangularity. The niche model reproduces this triangularity.\n\n\nnetworks\n\n3-element Vector{Any}:\n FoodWeb(S=20, L=60)\n FoodWeb(S=20, L=59)\n FoodWeb(S=20, L=59)\n\n\n\nnetworks[1].A\n\n20×20 SparseArrays.SparseMatrixCSC{Bool, Int64} with 60 stored entries:\n⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠟⠉⠀⠀⠀⠀⠀⠀⠀⠀\n⠒⠲⢌⡀⠀⠀⠀⠀⠀⠀\n⣀⣰⠮⠭⠭⠭⠄⠀⠀⠀\n⣐⣒⡋⠤⠤⠤⠤⠤⠀⠀\n\n\n\nnetworks[2].A\n\n20×20 SparseArrays.SparseMatrixCSC{Bool, Int64} with 59 stored entries:\n⢄⡀⠀⠀⠀⠀⠀⠀⠀⠀\n⠉⠑⣢⡀⠀⠀⠀⠀⠀⠀\n⠛⢠⣄⣀⣀⠀⠀⠀⠀⠀\n⠀⠒⠒⠄⠀⠉⠀⠀⠀⠀\n⠀⠀⠀⣥⣶⣶⣖⣀⣀⡀\n\n\n\nnetworks[3].A\n\n20×20 SparseArrays.SparseMatrixCSC{Bool, Int64} with 59 stored entries:\n⢂⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠈⣀⠀⠀⠀⠀⠀⠀⠀⠀\n⢴⣉⣀⣀⡀⠀⠀⠀⠀⠀\n⣤⣀⠒⠛⠓⠀⠀⠀⠀⠀\n⠀⠭⣤⣤⣤⣄⣀⣀⣀⡀\n\n\n\n\n\nLinking the networks to the Ecological Networks Dynamics\nFantastic. Now you are ready for the next steps. We want to run the EcologicalNetworksDynamics model on each of these networks. Furthermore, we want to collect the biomass and stability information for all three into a data frame. Let’s see how we do that.\n\nStep 1: Create the collecting data frame\nFirst, we create the holding pen for our information. We’ll construct a data frame to collect five pieces of information: the network id (1,2 or 3), species richness at the start (our initial S), species richness at the end, total biomass at the end and stability at the end.\n\noutputs = DataFrame(Network = [], Init_Rich = [], Fin_Rich = [], Tot_biomass = [], Stability = [])\n\n\n0×5 DataFrameRowNetworkInit_RichFin_RichTot_biomassStabilityAnyAnyAnyAnyAny\n\n\n\n\nStep 2: use the pre-defined networks\nWe can use our nets object from above now. Each of these networks has a different species richness.\n\nfor i in 1:3\n\n    # prep: define size of network\n    S = size(nets[i].A)[1]\n\n    # deliver some progress reporting\n    println(\"\\nThis is network: \", i, \"with species richness = \", S,\"\\n\")\n\n    # step A: define model paramters\n    params = ModelParameters(nets[i])\n\n    # step B: define body mass\n    B0 =  rand(S)\n\n    # step C: simulate\n    out = simulate(params, B0)\n\n    # steps D: calculate metrics\n    fin_rich = foodweb_richness(out, last = 1)\n    fin_biomass = total_biomass(out, last = 20)\n    stability = population_stability(out, last = 20)\n\n    # step E: add things to the data frame\n    # note the first arg is the data frame and then\n    # the values we want allocated to the five slots\n    # are in []\n    push!(outputs, [i, S, fin_rich, fin_biomass, stability])\nend\n\n\nThis is network: 1\n\n\nwith species richness = 10\n\n\n\n┌ Info: Species [6] went extinct at time t = 52.7748329773838. \n└ 1 out of 10 species are extinct.\n┌ Info: Species [7] went extinct at time t = 97.19471278149116. \n└ 2 out of 10 species are extinct.\n┌ Info: Species [8] went extinct at time t = 110.83760319212487. \n└ 3 out of 10 species are extinct.\n\n\n\nThis is network: 2with species richness = 20\n\n\n\n┌ Info: Species [11, 8] went extinct at time t = 30.97557456252379. \n└ 2 out of 20 species are extinct.\n┌ Info: Species [10, 12] went extinct at time t = 34.70996809228141. \n└ 4 out of 20 species are extinct.\n┌ Info: Species [16, 20, 17] went extinct at time t = 39.01646705146316. \n└ 7 out of 20 species are extinct.\n┌ Info: Species [14] went extinct at time t = 90.73881755015037. \n└ 8 out of 20 species are extinct.\n┌ Info: Species [15] went extinct at time t = 114.36470919283332. \n└ 9 out of 20 species are extinct.\n\n\n\nThis is network: 3with species richness = 30\n\n\n\n┌ Info: Species [24] went extinct at time t = 38.40537328090451. \n└ 1 out of 30 species are extinct.\n┌ Info: Species [12] went extinct at time t = 43.58724536460298. \n└ 2 out of 30 species are extinct.\n\n\n┌ Info: Species [27] went extinct at time t = 48.49482506463622. \n└ 3 out of 30 species are extinct.\n┌ Info: Species [22] went extinct at time t = 69.89436475711852. \n└ 4 out of 30 species are extinct.\n┌ Info: Species [30] went extinct at time t = 87.97078016890501. \n└ 5 out of 30 species are extinct.\n┌ Info: Species [19] went extinct at time t = 103.93229501871079. \n└ 6 out of 30 species are extinct.\n\n\n┌ Info: Species [13] went extinct at time t = 112.5899175515238. \n└ 7 out of 30 species are extinct.\n┌ Info: Species [11] went extinct at time t = 187.71903006492082. \n└ 8 out of 30 species are extinct.\n\n\n┌ Info: Species [16] went extinct at time t = 207.76099132863754. \n└ 9 out of 30 species are extinct.\n┌ Info: Species [26] went extinct at time t = 232.36677896956368. \n└ 10 out of 30 species are extinct.\n\n\nAmazing. Let’s see if what we wanted collected has ended up in our data frame. Wonderful! Splendiferous. Fantabulous.\n\nprintln(outputs)\n\n3×5 DataFrame\n Row │ Network  Init_Rich  Fin_Rich  Tot_biomass  Stability  \n     │ Any      Any        Any       Any          Any        \n─────┼───────────────────────────────────────────────────────\n   1 │ 1.0      10.0       7.0       1.52003      -0.198905\n   2 │ 2.0      20.0       11.0      2.38499      -0.154605\n   3 │ 3.0      30.0       20.0      3.3829       -0.0683006\n\n\n\n\nDissecting more from simulate\nNote the details on extinctions that comes from a model run. For example, let’s revisit our sim_niche object (you won’t necessarily have to re-run this if you are working in one big script)\n\nS = 20; # define the number of species\nC = 0.2; # define the connectance (complexity) of the network\n\n# construct the food web\nRandom.seed!(12325) # ensures your network and this one are the same\nfoodweb_niche = FoodWeb(nichemodel, S, C=C)\n\n# construct the equations and fixed parameters\nparams_niche = ModelParameters(foodweb_niche)\n\n# define bodymasses between 0 and 1 and get S = 20 of them.\nRandom.seed!(123)\nB0 = rand(S)\n\n# simulate using params and bodymasses\n# note additional argument tmax for max time steps\n# default is 300\nsim_niche = simulate(params_niche, B0)\n\n┌ Info: Species [5] went extinct at time t = 33.834970465767604. \n└ 1 out of 20 species are extinct.\n┌ Info: Species [10, 8] went extinct at time t = 49.801980626257766. \n└ 3 out of 20 species are extinct.\n┌ Info: Species [13] went extinct at time t = 67.54842232722383. \n└ 4 out of 20 species are extinct.\n┌ Info: Species [14] went extinct at time t = 76.05686387794776. \n└ 5 out of 20 species are extinct.\n┌ Info: Species [12] went extinct at time t = 94.25974163851537. \n└ 6 out of 20 species are extinct.\n┌ Info: Species [15, 19] went extinct at time t = 180.6781729701157. \n└ 8 out of 20 species are extinct.\n\n\nretcode: Terminated\nInterpolation: specialized 4th order \"free\" interpolation, specialized 2nd order \"free\" stiffness-aware interpolation\nt: 58-element Vector{Float64}:\n   0.0\n   0.05642845716276844\n   0.11891649263385903\n   0.20769683238716719\n   0.3045875314442914\n   0.44216128503645374\n   0.6112783739340873\n   0.8303542080772176\n   1.0917849224507885\n   1.4340233039417565\n   1.8447846396665963\n   2.3653444519946065\n   3.0115146437752442\n   ⋮\n 103.19272243700584\n 111.88147068621589\n 122.54731908523809\n 133.74922122845595\n 147.26632373648013\n 162.38512727362877\n 180.6781729701157\n 180.6781729701157\n 201.57862868705948\n 226.71369483198157\n 254.89823928856072\n 289.09217901466906\nu: 58-element Vector{Vector{Float64}}:\n [0.906299638797481, 0.44349373245960455, 0.7456733811393941, 0.5120830400366143, 0.2538490889415096, 0.33415153638191886, 0.4273278808735992, 0.867547200255958, 0.09913361484360417, 0.12528740769155033, 0.6922086620547391, 0.13655147513745736, 0.03209667335274724, 0.3505458214588266, 0.9303323763821093, 0.9594335994071538, 0.5819123423876457, 0.3114475007050529, 0.12114752051812694, 0.20452981732035946]\n [0.8506750248039066, 0.316016267593785, 0.651840748854925, 0.4766336454051591, 0.25339023877433103, 0.3308187673571854, 0.3608638414554032, 0.7307871678092578, 0.10181476103833324, 0.1302817851708985, 0.7090830957307426, 0.143047476716464, 0.033895623646412715, 0.3678562194543374, 0.9644776003724441, 1.0175145940496193, 0.6126719605021673, 0.3314093482768925, 0.12683785756057048, 0.2129203618593246]\n [0.79061537214418, 0.23954384290971395, 0.5567140397232614, 0.4344170769662325, 0.24986737440786716, 0.32063982029985305, 0.2984775562116461, 0.5956422271584304, 0.10443600830700829, 0.1346128355925403, 0.7185118003079496, 0.14901914689388757, 0.03558419101698233, 0.38339997438386947, 0.9929266560084749, 1.06953278911396, 0.6433589739159863, 0.3561234135700153, 0.1320907952178632, 0.22294521665303071]\n [0.7117642849034563, 0.18269016715718198, 0.45014059997829864, 0.37591414569832066, 0.24025174448410844, 0.29858693228235306, 0.23019800620416758, 0.44447201574787, 0.10749246293160268, 0.13870921713301645, 0.7156357593162649, 0.1551843231186634, 0.03740341134849236, 0.3985440860134391, 1.0161499732316146, 1.1156297864750935, 0.6804066357941937, 0.3959202823221901, 0.137583475539412, 0.2381829213237624]\n [0.637864541406651, 0.1503421792257488, 0.3676657479332152, 0.320057566968519, 0.22564899934563057, 0.270500362707076, 0.17916060452846852, 0.33112405990653637, 0.10998421440894149, 0.14072106616155092, 0.6941158119081321, 0.15917588587457487, 0.03868647959581901, 0.40689888452777606, 1.0213288085687784, 1.1298756225554956, 0.7119244806213847, 0.4454799235433431, 0.14126170174114036, 0.25554938422424667]\n [0.5559407848636867, 0.12631052480880015, 0.2904114839844158, 0.2582931568360568, 0.20220842330556968, 0.23220438765756146, 0.13519226638942444, 0.23330213347465842, 0.11226625726272813, 0.1400453134242365, 0.641570210214102, 0.1612004426742432, 0.03955097344654741, 0.40804286723593697, 1.0015444670165246, 1.1036887633479435, 0.7408738296753514, 0.5263705064271911, 0.14343585264469774, 0.2800916946303293]\n [0.4860996729494896, 0.11179029473032814, 0.23137285784725128, 0.20552529077406026, 0.1747980995461694, 0.19357159968326387, 0.10612673454134991, 0.16719749268922784, 0.11358398642492225, 0.1352561059283022, 0.5613805721991025, 0.1598278497087544, 0.039596577742655764, 0.39819486451339087, 0.9479548560941534, 1.0301972322914708, 0.7517501261412793, 0.6414320506868165, 0.14297505072762562, 0.3074662732159045]\n [0.43062336037116583, 0.10356398289144214, 0.1844615792588205, 0.16141813485406956, 0.14575039383099775, 0.1571093339964948, 0.08742077847876842, 0.12135214811929286, 0.11378070169199302, 0.1254693865013906, 0.4587858740179325, 0.15424893136862108, 0.03869286978329806, 0.37436167030100614, 0.8503781972412569, 0.9057553075538197, 0.729041383618697, 0.8111579252058726, 0.13952231909053012, 0.33452709185125584]\n [0.3964192405936538, 0.10101479310886363, 0.1498840569184408, 0.12863185719239692, 0.12025445643257139, 0.1276930699613838, 0.07768609151302582, 0.09178438827929986, 0.1129872623811614, 0.11192393303962592, 0.3577855445251828, 0.14437936495554246, 0.03687729226745649, 0.3368923782528146, 0.7157846278632801, 0.7465856241369827, 0.6605821596120509, 1.0277574218259113, 0.133341718388981, 0.3523097808665832]\n [0.38243072371733805, 0.10377513407300389, 0.1217115949038405, 0.10226707383008429, 0.09734334186196499, 0.1028555239811688, 0.07466666450788355, 0.07043649701997969, 0.11164051273424316, 0.09471976081247838, 0.2637113630658382, 0.12885618774692784, 0.033978371827748904, 0.28249894955757976, 0.544447847842159, 0.55639341927026, 0.53893465126863, 1.2848208126971767, 0.12395874464534769, 0.35570542529504545]\n [0.3924286883443767, 0.11240697122613484, 0.10060160264185608, 0.08276595735749182, 0.07899615746867737, 0.08401465383098933, 0.0788422397090856, 0.05582188795693415, 0.11062078840452406, 0.07721940138253008, 0.19236961376758502, 0.10959561891383252, 0.03033101714965189, 0.22181251720504394, 0.38326331658163443, 0.3858474444456293, 0.40210575336666987, 1.478425292922194, 0.1124162514057935, 0.3416990564906213]\n [0.42813571326082744, 0.128675511760532, 0.08395046251363436, 0.06718291407025544, 0.0632356350441606, 0.06877541295298652, 0.09176856327149403, 0.04453967283991596, 0.11135444226987187, 0.06048784203533888, 0.1407241774293773, 0.08818893948453095, 0.02603605400173823, 0.16352606263626918, 0.25543375688046666, 0.2550430395334262, 0.2841668822226807, 1.5316936451717071, 0.09862107795307937, 0.3119844172763782]\n [0.4883402528108113, 0.15414578508205598, 0.07185284431714349, 0.05495095681805794, 0.04961797714957933, 0.05670337491344602, 0.11648832900242263, 0.0354977640435102, 0.11636390428998801, 0.0462790891202952, 0.10793925995233015, 0.06817276625365948, 0.021611980155946762, 0.11724461406725467, 0.1701205982863288, 0.17011786682827734, 0.20492293431105466, 1.4292032372179935, 0.0836268920392082, 0.2715005027005714]\n ⋮\n [0.5101103239051296, 0.21403940327788046, 0.14189753714304945, 0.001693635023410558, 0.0, 0.001728937022754008, 0.28196217073426805, 0.0, 0.31327085058093246, 0.0, 0.09473818890539755, 0.0, 0.0, 0.0, 0.0004371189961953228, 0.16431048059903605, 0.4330100545383833, 0.16207440622211108, 0.0004404178929681443, 0.16833384448884556]\n [0.5100179624486647, 0.21395516793778624, 0.142298340511395, 0.001399591351485802, 0.0, 0.0014285605990996871, 0.28201554962591546, 0.0, 0.3133389744030027, 0.0, 0.09462002403222947, 0.0, 0.0, 0.0, 0.00028712045202572195, 0.16437889628236, 0.4331528001886544, 0.1624194039181494, 0.0002894594976590179, 0.16827174480291335]\n [0.5101391685673029, 0.21385402252043828, 0.14271524798887555, 0.001112636069065219, 0.0, 0.0011355054958041792, 0.28205082269333753, 0.0, 0.3133648590256169, 0.0, 0.09463567195834738, 0.0, 0.0, 0.0, 0.00017121921065168936, 0.16445747963247836, 0.4329436890213209, 0.16283785122750755, 0.00017269486463913314, 0.16827370452881724]\n [0.5101982418484956, 0.21377046129833874, 0.1430518646451849, 0.0008782706978664726, 0.0, 0.0008962183476809098, 0.2820689756016431, 0.0, 0.3133576387193469, 0.0, 0.09471464863656844, 0.0, 0.0, 0.0, 9.947040358900451e-5, 0.1645130202313456, 0.43273362778296065, 0.1630429734495872, 0.00010035697721249949, 0.16835521456676708]\n [0.5102084335756756, 0.2136967087621238, 0.143348139597704, 0.0006630399647620726, 0.0, 0.00067651590963556, 0.2820693689719039, 0.0, 0.31332800021060336, 0.0, 0.09477320176194699, 0.0, 0.0, 0.0, 5.144861940770425e-5, 0.16454897745245234, 0.4326529862755553, 0.16308117940893418, 5.191757472306722e-5, 0.1684581303519066]\n [0.5101892000300914, 0.2136390751688376, 0.14358424821900018, 0.00048616264339761703, 0.0, 0.0004959989274277475, 0.28206673609400656, 0.0, 0.3133064900180514, 0.0, 0.09479046649120906, 0.0, 0.0, 0.0, 2.451430967046031e-5, 0.16456268461941692, 0.43267517418306095, 0.16307833641316483, 2.4740597400918844e-5, 0.16851125147059168]\n [0.5101772405476588, 0.2135902678598142, 0.1437866089869059, 0.00033524651458835785, 0.0, 0.00034200273310671747, 0.28206907831200306, 0.0, 0.31329849477167543, 0.0, 0.09479928184557744, 0.0, 0.0, 0.0, 9.887997298776258e-6, 0.164565448997319, 0.43269238896886636, 0.16311370021270755, 9.979930181003285e-6, 0.1685218827160758]\n [0.5101772405476588, 0.2135902678598142, 0.1437866089869059, 0.00033524651458835785, 0.0, 0.00034200273310671747, 0.28206907831200306, 0.0, 0.31329849477167543, 0.0, 0.09479928184557744, 0.0, 0.0, 0.0, 0.0, 0.164565448997319, 0.43269238896886636, 0.16311370021270755, 0.0, 0.1685218827160758]\n [0.5101757757677363, 0.21355240023704158, 0.1439431400036674, 0.0002200025342075797, 0.0, 0.0002244227287650652, 0.2820723375375796, 0.0, 0.3132932906420358, 0.0, 0.09481482484946595, 0.0, 0.0, 0.0, 0.0, 0.16456927133861393, 0.4326792235117793, 0.16316037540338976, 0.0, 0.1685304597671773]\n [0.5101703696591152, 0.213523666531707, 0.144060539077565, 0.00013284682506689382, 0.0, 0.00013550965212111025, 0.2820745504332237, 0.0, 0.3132897360866837, 0.0, 0.09482996255459025, 0.0, 0.0, 0.0, 0.0, 0.16456343881849694, 0.43267529562058404, 0.16317704041993888, 0.0, 0.16853030553320153]\n [0.5101657341582638, 0.21350517347728484, 0.14413728087703948, 7.556735456477713e-5, 0.0, 7.707967503593065e-5, 0.28207544097209714, 0.0, 0.31328664374561793, 0.0, 0.09483755535192052, 0.0, 0.0, 0.0, 0.0, 0.16456072931990792, 0.43267635507709945, 0.16319154463635513, 0.0, 0.1685302162465592]\n [0.5101635791665768, 0.2134928726933351, 0.14418784498203172, 3.80328307565163e-5, 0.0, 3.879316993321401e-5, 0.2820763883451882, 0.0, 0.31328518836452973, 0.0, 0.09484351749232077, 0.0, 0.0, 0.0, 0.0, 0.1645588376935647, 0.43267463374601806, 0.1632017694444765, 0.0, 0.16852982509285047]\n\n\nWe’ve constucted a helper function to get information on which species go extinct and when they do.\n\n# collect and organise extinctons\nextinctions = get_extinct_species(sim_niche)\n\nDict{Int64, Float64} with 8 entries:\n  5  => 33.835\n  13 => 67.5484\n  15 => 180.678\n  10 => 49.802\n  12 => 94.2597\n  8  => 49.802\n  14 => 76.0569\n  19 => 180.678\n\n\nThis is a Dict object. The numbers on the left of the => are known as the keys and the numbers on the right are values. We can create a mini- data frame out of this with the following code. key and values are actually extractor functions and collect is translating the extracted information into a vector.\n\n# create a data frame of extinctions\nee1 = DataFrame(who = collect(keys(extinctions)), when = collect(values(extinctions)))\n\n\n8×2 DataFrameRowwhowhenInt64Float641533.83521367.5484315180.67841049.80251294.25976849.80271476.0569819180.678\n\n\nNow we can try and add this information to the plot. For the time being, we’ll focus on adding the times that each of these species goes extinct to our figure. To do this we need to access the extinction time column (when), add a bit of noise/jitter so that times that are really close together can be seen on our x-axis, and then plot these as points with coordinates x = when and y = 0.\n\n# add some jitter for close together events\nexts = ee1[:,2] .+rand.()\n\n# plot\nplot(sim_niche)\n# add jittered extinction events.\nplot!(exts, zeros(size(ee1[:,1])), seriestype = :scatter, legend = false)\n\n\n\n\nPretty cool!\n\n\n\nWhat’s next\nIn the next chapter, you’ll be creating larger experiments with loops over actual parameters in the model, including the predator-prey size ratio, values of carry capacity and the predator-prey size ratio."
  },
  {
    "objectID": "Tutorial-10_Complex Experiments with the BEFWM2.html",
    "href": "Tutorial-10_Complex Experiments with the BEFWM2.html",
    "title": "Tutorial 10: Complex Experiments with the BEFWM2",
    "section": "",
    "text": "The previous tutorial focused on experiments where we manipulated the number of networks and various network parameters. This is one set of things we can change/vary in an in silico experiment. The other set of things we can change are features of the model, such as the shape of the functional response (see Tutorial 7), features of the environment such as the carrying capacity, or even empirical relationships that drive trophic structure and interaction strengths, such as the predator-prey mass ratio.\nIn this tutorial, we are going to implement three experiments. The first two will be ‘simple’ in that they vary only two things. The final example will implement a large experiment changing five features of the model.\nYou may want to start a new script in the project. We’ll need the following packages (they are already installed… so we just need using).\n\nusing EcologicalNetworksDynamics\nusing Random, Plots, Distributions, DataFrames, StatsPlots\nusing EcologicalNetworksPlots, EcologicalNetworks\n\n\nExperiment 1: Carrying Capacity and the Predator Prey Mass Ratio\nNow we are set for our first experiment. Lets first establish the parameters we need to make the food web and do the experiment. We fix S at 20 and C at 0.15. We then create vectors of Z and K.\nZ is the predator - prey mass ratio, and defines how much bigger or smaller the predators are from their prey. The data suggest it is between predators are between 10 and 100 times bigger than their prey see Brose et al 2006. This value interacts with setting trophic levels in the model.\nThe default setting for the models is 1 - i.e. all species are within the same order of magnitude, predators are not bigger than their prey. Here, we creat a vector of values to explore, from predators being smaller, to them being 10 or 100 x larger as the data suggests.\nMORE ON HOW THE PPMR interacts with Trophic level?\n\n#Fixed Parameters\nS = 20\nC = 0.15\n\n# Variable Parameters\nZ_levels = [0.1, 1, 10, 100]\nK_levels = [0.1, 1, 10, 100]\n\n# run this to get same results as in the document\nRandom.seed!(123)\n\nTaskLocalRNG()\n\n\nNow, lets set up the collecting data frame.\n\ndf_collect = DataFrame(Z = [], K = [], FinalRichness = [], FinalBiomass = [], FinalStability = [])\n\n\n0×5 DataFrameRowZKFinalRichnessFinalBiomassFinalStabilityAnyAnyAnyAnyAny\n\n\nNow, set up the loop to use these variables and generate outputs\n\nfor z in Z_levels\n    for k in K_levels\n\n        println(\" ***> This is iteration with Z = $z and K = $k\\n\")\n\n        fw = FoodWeb(nichemodel, S; C, Z = z)\n        Environment(fw, K = k)\n\n        B0 = rand(S)\n        params = ModelParameters(fw)\n\n        out = simulate(params, B0)\n\n        # collect info\n        fin_rich = foodweb_richness(out, last = 30)\n        fin_bio = total_biomass(out, last = 30)\n        stab = population_stability(out, last = 30)\n\n        push!(df_collect, [z, k, fin_rich, fin_bio, stab])\n    end\nend\n\n ***> This is iteration with Z = 0.1 and K = 0.1\n\n\n\n┌ Info: Species [16] went extinct at time t = 10.333220779245396. \n└ 1 out of 20 species are extinct.\n┌ Info: Species [7] went extinct at time t = 58.07510892697318. \n└ 2 out of 20 species are extinct.\n┌ Info: Species [8] went extinct at time t = 96.59439608251868. \n└ 3 out of 20 species are extinct.\n┌ Info: Species [15] went extinct at time t = 99.81800659688153. \n└ 4 out of 20 species are extinct.\n┌ Info: Species [10] went extinct at time t = 173.50017299410476. \n└ 5 out of 20 species are extinct.\n\n\n ***> This is iteration with Z = 0.1 and K = 1.0\n\n\n\n┌ Info: Species [7, 18] went extinct at time t = 7.79864262878258. \n└ 2 out of 20 species are extinct.\n┌ Info: Species [17] went extinct at time t = 12.302588972757128. \n└ 3 out of 20 species are extinct.\n┌ Info: Species [14, 19] went extinct at time t = 54.65909534164244. \n└ 5 out of 20 species are extinct.\n┌ Info: Species [10] went extinct at time t = 60.53358149873246. \n└ 6 out of 20 species are extinct.\n\n\n ***> This is iteration with Z = 0.1 and K = 10.0\n\n\n\n┌ Info: Species [5] went extinct at time t = 252.5627381565363. \n└ 7 out of 20 species are extinct.\n┌ Info: Species [16] went extinct at time t = 255.6762152446527. \n└ 8 out of 20 species are extinct.\n\n\n┌ Info: Species [18] went extinct at time t = 5.452845413338652. \n└ 1 out of 20 species are extinct.\n┌ Info: Species [17] went extinct at time t = 7.6238324278018. \n└ 2 out of 20 species are extinct.\n┌ Info: Species [15] went extinct at time t = 67.45898739065261. \n└ 3 out of 20 species are extinct.\n┌ Info: Species [19] went extinct at time t = 70.55144729932225. \n└ 4 out of 20 species are extinct.\n┌ Info: Species [11] went extinct at time t = 76.65337831298842. \n└ 5 out of 20 species are extinct.\n┌ Info: Species [12] went extinct at time t = 79.93906826954334. \n└ 6 out of 20 species are extinct.\n\n\n┌ Info: Species [9] went extinct at time t = 206.60040098574206. \n└ 7 out of 20 species are extinct.\n\n\n ***> This is iteration with Z = 0.1 and K = 100.0\n\n\n\n┌ Info: Species [9] went extinct at time t = 10.740211650168495. \n└ 1 out of 20 species are extinct.\n┌ Info: Species [20] went extinct at time t = 21.53600773237581. \n└ 2 out of 20 species are extinct.\n\n\n┌ Info: Species [14] went extinct at time t = 26.526137967578318. \n└ 3 out of 20 species are extinct.\n┌ Info: Species [10, 17] went extinct at time t = 29.65218241510892. \n└ 5 out of 20 species are extinct.\n┌ Info: Species [11] went extinct at time t = 40.93973683032451. \n└ 6 out of 20 species are extinct.\n┌ Info: Species [7, 3] went extinct at time t = 44.403037167488925. \n└ 8 out of 20 species are extinct.\n┌ Info: Species [5, 12] went extinct at time t = 47.422100875122986. \n└ 10 out of 20 species are extinct.\n┌ Info: Species [15] went extinct at time t = 53.521946406912726. \n└ 11 out of 20 species are extinct.\n┌ Info: Species [13] went extinct at time t = 88.23965733559986. \n└ 12 out of 20 species are extinct.\n\n\n ***> This is iteration with Z = 1.0 and K = 0.1\n\n\n\n┌ Info: Species [7, 11] went extinct at time t = 33.40288048145466. \n└ 2 out of 20 species are extinct.\n┌ Info: Species [16] went extinct at time t = 43.58846848478901. \n└ 3 out of 20 species are extinct.\n\n\n ***> This is iteration with Z = 1.0 and K = 1.0\n\n\n\n┌ Info: Species [13] went extinct at time t = 71.26258343675524. \n└ 4 out of 20 species are extinct.\n┌ Info: Species [9] went extinct at time t = 76.2910085126206. \n└ 5 out of 20 species are extinct.\n┌ Info: Species [17] went extinct at time t = 81.47041929142708. \n└ 6 out of 20 species are extinct.\n┌ Info: Species [20] went extinct at time t = 250.51901692767748. \n└ 7 out of 20 species are extinct.\n\n\n┌ Info: Species [12] went extinct at time t = 30.025171952720154. \n└ 1 out of 20 species are extinct.\n┌ Info: Species [16, 20, 17, 19] went extinct at time t = 41.4267587744762. \n└ 5 out of 20 species are extinct.\n┌ Info: Species [4] went extinct at time t = 61.788208267960805. \n└ 6 out of 20 species are extinct.\n┌ Info: Species [11, 18] went extinct at time t = 108.48651859473986. \n└ 8 out of 20 species are extinct.\n┌ Info: Species [7] went extinct at time t = 146.3080674035236. \n└ 9 out of 20 species are extinct.\n┌ Info: Species [14] went extinct at time t = 296.7203892892406. \n└ 10 out of 20 species are extinct.\n\n\n ***> This is iteration with Z = 1.0 and K = 10.0\n\n\n\n┌ Info: Species [7] went extinct at time t = 31.97167042395919. \n└ 1 out of 20 species are extinct.\n┌ Info: Species [20, 19] went extinct at time t = 44.704826238230446. \n└ 3 out of 20 species are extinct.\n\n\n ***> This is iteration with Z = 1.0 and K = 100.0\n\n\n\n┌ Info: Species [16] went extinct at time t = 351.1728007870926. \n└ 4 out of 20 species are extinct.\n\n\n┌ Info: Species [14] went extinct at time t = 93.92059343902136. \n└ 1 out of 20 species are extinct.\n┌ Info: Species [13] went extinct at time t = 232.64065602391264. \n└ 2 out of 20 species are extinct.\n┌ Info: Species [12] went extinct at time t = 257.55666477477075. \n└ 3 out of 20 species are extinct.\n\n\n ***> This is iteration with Z = 10.0 and K = 0.1\n\n\n\n┌ Info: Species [19] went extinct at time t = 176.22073341629988. \n└ 1 out of 20 species are extinct.\n┌ Info: Species [14] went extinct at time t = 447.84231449641817. \n└ 2 out of 20 species are extinct.\n\n\n ***> This is iteration with Z = 10.0 and K = 1.0\n\n\n\n ***> This is iteration with Z = 10.0 and K = 10.0\n\n\n\n┌ Info: Species [18] went extinct at time t = 257.2149928441204. \n└ 1 out of 20 species are extinct.\n┌ Info: Species [12] went extinct at time t = 362.2028229313007. \n└ 2 out of 20 species are extinct.\n\n\n ***> This is iteration with Z = 10.0 and K = 100.0\n\n\n\n┌ Info: Species [12] went extinct at time t = 392.3491322903875. \n└ 1 out of 20 species are extinct.\n\n\n┌ Info: Species [3] went extinct at time t = 108.36651973920425. \n└ 1 out of 20 species are extinct.\n┌ Info: Species [5, 4] went extinct at time t = 142.19180110075308. \n└ 3 out of 20 species are extinct.\n┌ Info: Species [11, 9] went extinct at time t = 152.16900575546077. \n└ 5 out of 20 species are extinct.\n┌ Info: Species [6] went extinct at time t = 162.39218592381178. \n└ 6 out of 20 species are extinct.\n┌ Info: Species [15, 10] went extinct at time t = 184.60725874208512. \n└ 8 out of 20 species are extinct.\n┌ Info: Species [7] went extinct at time t = 196.60065563305216. \n└ 9 out of 20 species are extinct.\n\n\n ***> This is iteration with Z = 100.0 and K = 0.1\n\n\n\n┌ Info: Species [16, 13] went extinct at time t = 254.46108282792977. \n└ 11 out of 20 species are extinct.\n┌ Info: Species [20] went extinct at time t = 324.694736964769. \n└ 12 out of 20 species are extinct.\n┌ Info: Species [19] went extinct at time t = 360.7907924164594. \n└ 13 out of 20 species are extinct.\n\n\n ***> This is iteration with Z = 100.0 and K = 1.0\n\n\n\n ***> This is iteration with Z = 100.0 and K = 10.0\n\n\n\n ***> This is iteration with Z = 100.0 and K = 100.0\n\n\n\n┌ Info: Species [4] went extinct at time t = 303.7164417912157. \n└ 1 out of 20 species are extinct.\n\n\nWonderful. Now we are in a position to learn about two new plotting methods. First, let’s look at the data frame we’ve created.\n\ndf_collect\n\n\n16×5 DataFrameRowZKFinalRichnessFinalBiomassFinalStabilityAnyAnyAnyAnyAny10.10.115.02.69924-0.007685520.11.012.02.13677-0.001101130.110.013.02.18971-0.00054661240.1100.08.01.50359-0.0003826251.00.114.42.22238-0.13640961.01.012.13332.64512-0.17870971.010.016.82.67383-0.25991581.0100.018.73.54345-0.0968901910.00.119.44.81281-0.2322711010.01.019.58.08706-0.1015311110.010.019.26674.24443-0.02898651210.0100.012.66674.70276-0.088060913100.00.120.010.8534-0.4246314100.01.020.041.1869-0.42173615100.010.019.714.6763-0.75001716100.0100.020.018.7396-0.433297\n\n\n\nVisualising the experiment\nOne option here is to plot one of our Final Objects as the response variable against the valuse of Z and K. In R, we’d use ggplot2. Here we’ll use StatsPlots as we learned about in Tutorial 5. Can you make this work in the regular Plots syntax?\nLet’s first look at a single plot of stability\n\n@df df_collect plot(:K, [:FinalStability], group = :Z, \n    ylabel = \"Stabilty\", \n    xlabel = \"Karrying Kapacity\",\n    seriestype = [:scatter, :line],\n    legend = false)\n\n\n\n\nNow some new ploting tricks… 3 plots in a layout.\n\np1 = @df df_collect plot(:K, [:FinalStability], group = :Z, \n    legend = :bottomright,\n    ylabel = \"Stabilty\", \n    xlabel = \"Karrying Kapacity\",\n    seriestype = [:scatter, :line])\n\np2 = @df df_collect plot(:K, [:FinalBiomass], group = :Z, \n    legend = :bottomright,\n    ylabel = \"Biomass\", \n    xlabel = \"Karrying Kapacity\",\n    seriestype = [:scatter, :line])\n    \np3 = @df df_collect plot(:K, [:FinalRichness], group = :Z, \n    legend = :bottomright,\n    ylabel = \"Richness\", \n    xlabel = \"Karrying Kapacity\",\n    seriestype = [:scatter, :line])\n\n# create a layout of 3 graphs stacked on top of each other.\nplot(p1, p2, p3, layout=(3,1), legend = false)\n\n\n\n\n\n\n\nInterpretation!"
  },
  {
    "objectID": "Tutorial-4_Programming Basics.html",
    "href": "Tutorial-4_Programming Basics.html",
    "title": "Tutorial 4: The Basics of Programming",
    "section": "",
    "text": "This section of the tutorials introduces programming basics, including the art of simple functions, positional arguments, keyword arguments, loops, if-else-break usage and continue-while usage.\nIt is important to note that if you have experience programming R, there is a major difference in Julia - the use of loops is very much advocated in Julia where as vectorising loops is advocated in R.\nBasically, we write loops in Julia. We try to avoid them in R, if we want speed."
  },
  {
    "objectID": "Tutorial-4_Programming Basics.html#functions",
    "href": "Tutorial-4_Programming Basics.html#functions",
    "title": "Tutorial 4: The Basics of Programming",
    "section": "Functions",
    "text": "Functions\nFunctions work exactly like they do in R, however, there are three fundamental differences:\n\nthere is no need for {} brackets (thank god)\nindenting (Julia requires seperate parts of a function to be indented - don’t worry, VS Code should do this for you)\nscoping (we’ll attempt to explain this later)\nfunctions always start with the word function and end with the word end. -to store something that is calculated in a function, you use the return command.\n\nLet’s begin with a simple function - adding 2 to any number\n\nfunction plus_two(x)\n    return(x+2)\nend\n\nplus_two (generic function with 1 method)\n\n\nLet’s use it now by providing an defining and x value, and asking for the function to return the new value.\n\nx_in = 33\nx_out = plus_two(x_in)\n\n35\n\n\nBecause we’ve defined x_out, we can request it…\n\nx_out\n\n35\n\n\n\nPositional Arguments\nAs in R, input variables for functions have a specified and fixed order unless they have a default value which is explictly specified. For instance, we can build a function that measures body weight on different planets, but defaults to estimating weight on earth with a gravitational force of 9.81:\n\nfunction bodyweight(BW_earth, g = 9.81)\n    # bw should be in kg.\n    return BW_earth*g/9.81\nend\n\nbodyweight (generic function with 2 methods)\n\n\nNote that the function is called bodyweight, it requires in the first position a weight in kg on earth and then defaults to estimating weight on earth by using g = 9.81\n\nbodyweight(75)\n\n75.0\n\n\nNow, if we want to estimate they same bodyweight on Mars, where gravit is 3.72, you can specify the g-value.\n\nbodyweight(75, 3.72)\n\n28.44036697247706\n\n\n\n\nKeyword Arguments\n\n# function with keyword arguments:\n# here, b and d are fixed = 2\n# a is positional\n# c is a keyword argument\n# the addition of ; before c means that c is an keyword argument and can be specified in any order, but must be named\nfunction key_word(a, b=2; c, d=2) \n    return a + b + c + d\nend\n\nkey_word (generic function with 2 methods)\n\n\nHere we specify position 1 (a) and that c = 3\n\nkey_word(1, c = 3)\n\n8\n\n\nHere we specify c = 3, and then position 1\n\nkey_word(c=3, 1)\n\n8\n\n\nHere we specify position 1 (a), redefine position 2 (b = 6) and declare c = 7.\n\nkey_word(1, 6, c=7)\n\n16\n\n\nNote that this DOES NOT work, because we’ve failed to define c. (and or b)\n\nkey_word(1, 8, d=4)\n\nLoadError: UndefKeywordError: keyword argument c not assigned\n\n\nTo redfine d, you’d need to define c and d.\n\nkey_word(1, c = 8, d = 4)\n\n15"
  },
  {
    "objectID": "Tutorial-4_Programming Basics.html#loops",
    "href": "Tutorial-4_Programming Basics.html#loops",
    "title": "Tutorial 4: The Basics of Programming",
    "section": "Loops",
    "text": "Loops\n\nFor loops\nFor loops work by iterating over a specified range (e.g. 1-10) at specified intervals (e.g. 1,2,3…). For instance, we might use a for loop to fill an array:\n\nFilling an array\nTo fill an array, we first define an object as an array using [].\n\nI_array = []\n\nAny[]\n\n\nLike with function, all loops start with for and end with end. Here we iteratively fill I_array with 1000 random selections of 1 or 2.\n\n# for loop to fill an array:\nfor i in 1:1000\n    # pick from the number 1 or 2 at random \n    # for each i'th step\n    for_test = rand((1,2)) \n    # push! and store for_test in I_array2\n    # Julia is smart enough to do this iteratively\n    # you don't neccessarily have to index by `[i]` like you might do in R\n    push!(I_array, for_test) \nend\n\nLet’s look at I_array now\n\nI_array\n\n1000-element Vector{Any}:\n 1\n 1\n 2\n 2\n 2\n 1\n 2\n 2\n 2\n 2\n 1\n 2\n 1\n ⋮\n 1\n 2\n 2\n 1\n 2\n 1\n 2\n 2\n 2\n 1\n 1\n 1\n\n\nLet’s try something more complex, iterating over multiple indices\nA new storage container:\n\ntab = []\n\nAny[]\n\n\nNow, we fill the storage container with values of i, j and k. Can you tell which in which order this will happen? The first entry will be [1,1,1]. The second will be [2,1,1]. Do you understand why? Mess around to check.\n\n# nested for loop to fill an array:\nfor k in 1:4\n    for j in 1:3\n        for i in 1:2\n            append!(tab,[[i,j,k]]) # here we've use append! to allocate iteratively to the array as opposed to using push! - both work. \n        end\n    end\nend\n\nLet’s look…\n\ntab\n\n24-element Vector{Any}:\n [1, 1, 1]\n [2, 1, 1]\n [1, 2, 1]\n [2, 2, 1]\n [1, 3, 1]\n [2, 3, 1]\n [1, 1, 2]\n [2, 1, 2]\n [1, 2, 2]\n [2, 2, 2]\n [1, 3, 2]\n [2, 3, 2]\n [1, 1, 3]\n [2, 1, 3]\n [1, 2, 3]\n [2, 2, 3]\n [1, 3, 3]\n [2, 3, 3]\n [1, 1, 4]\n [2, 1, 4]\n [1, 2, 4]\n [2, 2, 4]\n [1, 3, 4]\n [2, 3, 4]\n\n\nWe can also allocate to a multiple dimensional matrix. When working with matrices, we can build them out of zeros and the replace the values.\nHere we start with a three dimensional array with 4 two x three matrices.\n\nthreeDmatrix = zeros(2,3,4)\n\n2×3×4 Array{Float64, 3}:\n[:, :, 1] =\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n\n[:, :, 2] =\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n\n[:, :, 3] =\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n\n[:, :, 4] =\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n\n\nNow, let’s do a nested loop again, but this time into the matrices. The element we are adding each iteration is the sum of i+j+k.\nCan you guess how this works?\n\nfor k in 1:4\n    for j in 1:3\n        for i in 1:2\n            # note default is by column....\n            # first element allocated is 1+1+1, then 2+1+1 and this is first col\n            # then 1+2+1 and 2+2+1 into the second col\n            # then 1+3+1 and 2+3+1 into the third col\n            threeDmatrix[i,j,k] = i+j+k\n        end\n    end\nend\n\n\nthreeDmatrix\n\n2×3×4 Array{Float64, 3}:\n[:, :, 1] =\n 3.0  4.0  5.0\n 4.0  5.0  6.0\n\n[:, :, 2] =\n 4.0  5.0  6.0\n 5.0  6.0  7.0\n\n[:, :, 3] =\n 5.0  6.0  7.0\n 6.0  7.0  8.0\n\n[:, :, 4] =\n 6.0  7.0  8.0\n 7.0  8.0  9.0\n\n\nFinally, note that we can use println to provide a basic marker what what is happening: we show two ways to do this in the code.\n\nfor k in 1:4\n    for j in 1:3\n        for i in 1:2\n            #println(i,\"-\",j,\"-\",k) # multiple quotes\n            println(\"$i-$j-$k\") # one quote, $ to grab variables\n            \n            # note default is by column....\n            # first element allocated is 1+1+1, then 2+1+1 and this is first col\n            # then 1+2+1 and 2+2+1 into the second col\n            # then 1+3+1 and 2+3+1 into the third col\n            threeDmatrix[i,j,k] = i+j+k\n        end\n    end\nend\n\nAnd just for fun… this println trick can be handy for verbose tracking. Note how person in unique(persons) iterates and how you can embed a variable’s value in a text string.\n\npersons = [\"Alice\", \"Alice\", \"Bob\", \"Bob2\", \"Carl\", \"Dan\"]\n\nfor person in unique(persons)\n    println(\"Hello $person\")\nend\n\nHello Alice\nHello Bob\nHello Bob2\nHello Carl\nHello Dan\n\n\nThere are tons of different functions that can be helpful when building loops. Take a few minutes to look into the help files for eachindex, eachcol, eachrow and enumerate. They all provide slightly different ways of telling Julia how you want to loop over a problem. Also, remember that loops aren’t just for allocation, they can also be very useful when doing calculations.\n\n\n\nif, else, breaks\nWhen building a loop, it is often meaningful to stop or modify the looping process when a certain condition is met. For example, we can use the break, if and else statements to stop a for loop when i exceeds a given value (e.g. 10):\n\n# if and break:\nfor i in 1:100\n    println(i) # print i\n    if i >10\n        break # stop the loop with i >10\n    end   \nend\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# this loop can be modified using an if-else statement:\n# even though we are iterating to 100, it stops at 10.\nfor j in 1:100\n    if j >10\n        break # stop the loop with i >10\n    else\n        crj = j^3\n        println(\"J is = $j\") # print i\n        println(\"The Cube of $j is $crj\")\n    end\nend\n\nJ is = 1\nThe Cube of 1 is 1\nJ is = 2\nThe Cube of 2 is 8\nJ is = 3\nThe Cube of 3 is 27\nJ is = 4\nThe Cube of 4 is 64\nJ is = 5\nThe Cube of 5 is 125\nJ is = 6\nThe Cube of 6 is 216\nJ is = 7\nThe Cube of 7 is 343\nJ is = 8\nThe Cube of 8 is 512\nJ is = 9\nThe Cube of 9 is 729\nJ is = 10\nThe Cube of 10 is 1000\n\n\nYou’ll notice that every statement requires it’s own start )for and end points, and is indented as per Julia’s requirements. if and else statements can be very useful when building experiments: for example we might want to stop simulating a network’s dynamics if more than 50% of the species have gone extinct.\n\n\ncontinue and while\n\ncontinue\nThe continue command is the opposite to break and can be useful when you want to skip an iteration but not stop the loop:\n\nfor i in 1:30\n    # this reads: is it false that i is a multiple of 3?\n    if i % 3 == false\n        continue # makes the loop skip iterations that are a multiple of 3\n    else println(\"$i is not a multiple of 3\")\n    end\nend\n\n1 is not a multiple of 3\n2 is not a multiple of 3\n4 is not a multiple of 3\n5 is not a multiple of 3\n7 is not a multiple of 3\n8 is not a multiple of 3\n10 is not a multiple of 3\n11 is not a multiple of 3\n13 is not a multiple of 3\n14 is not a multiple of 3\n16 is not a multiple of 3\n17 is not a multiple of 3\n19 is not a multiple of 3\n20 is not a multiple of 3\n22 is not a multiple of 3\n23 is not a multiple of 3\n25 is not a multiple of 3\n26 is not a multiple of 3\n28 is not a multiple of 3\n29 is not a multiple of 3\n\n\nCan you figure out what the code would be for keeping even numbers only? Note the change of logic from false above to true here.\n\nfor i in 1:10\n    # where is it true that i is a multiple of 2?\n    if i % 2 == true\n        continue # makes the loop skip iterations that are odd\n    else println(\"$i is even\")\n    end\nend\n\n2 is even\n4 is even\n6 is even\n8 is even\n10 is even\n\n\n\n\nwhile\nwhile loops provide an alternative to for loops and allow you to iterate until a certain condition is met:\n\n# counter that is globally scoped (see next section)\n# testval -- try changing this to see how this global variable can be used in \n# the local process below\nglobal j=0\nglobal testval = 17\n\n# note that we started with j = 0!!!\n# justify a condition\nwhile(j<testval) \n    println(\"$j is definitely less than $testval\") # prints j until j < 30\n    # step forward\n    j += 1 # count\nend\n\n0 is definitely less than 17\n1 is definitely less than 17\n2 is definitely less than 17\n3 is definitely less than 17\n4 is definitely less than 17\n5 is definitely less than 17\n6 is definitely less than 17\n7 is definitely less than 17\n8 is definitely less than 17\n9 is definitely less than 17\n10 is definitely less than 17\n11 is definitely less than 17\n12 is definitely less than 17\n13 is definitely less than 17\n14 is definitely less than 17\n15 is definitely less than 17\n16 is definitely less than 17\n\n\nwhile loops don’t require you to specify a looping sequence (e.g. i in 1:100). But you do specify the starting value. The while loop can be very useful because sometimes you simply don’t know how many iterations you might need.\nIn the above code, you might have spotted the word global. Variables can exist in the local or global scope. If a variable exists inside a loop or function it is local and if you want to save it beyond the loop (i.e., in your workspace) you have to make it global - more on this below."
  },
  {
    "objectID": "Tutorial-4_Programming Basics.html#combine-a-function-and-a-loop",
    "href": "Tutorial-4_Programming Basics.html#combine-a-function-and-a-loop",
    "title": "Tutorial 4: The Basics of Programming",
    "section": "combine a function and a loop",
    "text": "combine a function and a loop\nLet’s get a bit more complicated. Above, you created a function that added 2 to any number. Let’s embed that in a loop and introduce enumerate. Quite often, there are functions you may want to apply to multiple things, and this is the example of how to do that!\n\n# make a vector - these are input values to our function\nvv = [1,2,3,7,9,11]\n\n# enumerate takes a special two variable starter: \"(index, value)\"\n# note how we print the index, then the output and then a line break with \\n\nfor (i, v) in enumerate(vv)\n    out = plus_two(v)\n    println(\"this is element $i of vv\")\n    println(\"$v plus 2 is equal to $out\\n\")\nend\n\nthis is element 1 of vv\n1 plus 2 is equal to 3\n\nthis is element 2 of vv\n2 plus 2 is equal to 4\n\nthis is element 3 of vv\n3 plus 2 is equal to 5\n\nthis is element 4 of vv\n7 plus 2 is equal to 9\n\nthis is element 5 of vv\n9 plus 2 is equal to 11\n\nthis is element 6 of vv\n11 plus 2 is equal to 13"
  },
  {
    "objectID": "Tutorial-4_Programming Basics.html#scoping",
    "href": "Tutorial-4_Programming Basics.html#scoping",
    "title": "Tutorial 4: The Basics of Programming",
    "section": "Scoping",
    "text": "Scoping\nScoping refers to the accessibility of a variable within your project. The scope of a variable is defined as the region of code where a variable is known and accessible. A variable can be in the global or local scope.\n\nGlobal\nA variable in the global scope is accessible everywhere and can be modified by any part of your code. When you create (or allocate to) a variable in your script outside of a function or loop you’re creating something that is global:\n\n# global allocation to A\nA = 7\nB = zeros(1:10)\n\n10-element OffsetArray(::Vector{Float64}, 1:10) with eltype Float64 with indices 1:10:\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n\n\nOf course you cab be super literate and force a variable to be global\n\nglobal(c = 7)\n\n7\n\n\n\n\nLocal\nA variable in the local scope is only accessible in that scope or in scopes eventually defined inside it. When you define a variable within a function or loop that isn’t returned then you create something that is local:\n\n# global\nC2 = zeros(10)\n\n10-element Vector{Float64}:\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n\n\n\n# local:\nfor i in 1:10\n    local_varb = 2 # local_varb is defined inside the loop and is therefore local (only accessible within the loop)\n    C2[i] = local_varb*i # in comparison, C is defined outside of the loop and is therefore global \nend\n\nNow, let’s see what we can see.\nC2 is global and it had numbers assigned to it, and we can see it.\n\nC2\n\n10-element Vector{Float64}:\n  2.0\n  4.0\n  6.0\n  8.0\n 10.0\n 12.0\n 14.0\n 16.0\n 18.0\n 20.0\n\n\nHowever, local_varb is local, and we can’t ask for anything about it. If we wanted to know about it, we’d have to ask for it to be println-ed to monitor it, or written (as it was to C2)\n\nlocal_varb\n\nLoadError: UndefVarError: local_varb not defined"
  },
  {
    "objectID": "Tutorial-8_Intro To Eco Net Dyn.html",
    "href": "Tutorial-8_Intro To Eco Net Dyn.html",
    "title": "Tutorial 8: Introducing Ecological Network Dynamics (BEFWM2)",
    "section": "",
    "text": "This section of the tutorials initiates you into using the Bioenergetic Food Web Model."
  },
  {
    "objectID": "Tutorial-8_Intro To Eco Net Dyn.html#getting-the-julia-package",
    "href": "Tutorial-8_Intro To Eco Net Dyn.html#getting-the-julia-package",
    "title": "Tutorial 8: Introducing Ecological Network Dynamics (BEFWM2)",
    "section": "Getting the Julia Package",
    "text": "Getting the Julia Package\nCurrently Not Available for Guest Users\nNavigate to the GitHub location for the BioEnergetic Model.\nIt should look like this:\n\n\n\nGitHubPageForBEFW\n\n\nThen download to your Documents Folder the package.\n\n\n\nDownloadTheZip\n\n\nOnce this folder is unzipped in your Documents Folder, you can install it using Pkg.develop.\n\nusing Pkg\nPkg.develop(path = \"~/Documents/EcologicalNetworksDynamics.jl-main/\")\n\nAnd now, you are ready to construct a script using the modelling tools!\n\n## My first BEFW Modelling\n\n## Packages I need\nusing DataFrames, Plots, Random, Distributions\nusing EcologicalNetworks, EcologicalNetworksPlots, EcologicalNetworksDynamics\n\n## Time to do some Experiments!"
  },
  {
    "objectID": "Tutorial-8_Intro To Eco Net Dyn.html#using-the-julia-package",
    "href": "Tutorial-8_Intro To Eco Net Dyn.html#using-the-julia-package",
    "title": "Tutorial 8: Introducing Ecological Network Dynamics (BEFWM2)",
    "section": "Using the Julia Package",
    "text": "Using the Julia Package\n\nPreamble: The Bioenergetic Food Web.\nIt is very worth pausing for a moment and visting this paper by Dr. Eva Delmas. It describes the BioEnergetic Food Web Model, provides some history of the model, and also showcases how the original Julia version of the model worked. This section of the tutorials is designed to introduce a newer, faster and more flexible version of the Julia package.\nA very basic interpretation of the model is as follows:\n\nThe model is a model of biomass dynamics, not numbers of indiduals.\nThe model is comprised of an equation for plants (producers) an equation for consumers (herbivores, predators).\nPlants have traits that make their biomass grow and sets their carrying capacity; they are eaten by consumers via an equation describing a functional response. To link to ecology courses you have, this can be logistic growth for the plant and a type II functional response.\nConsumer have three sets of traits. One is metabolism, which is a rate that describes losses of biomass due to, well, metabolism! The second set of traits correspond to the functional response - for example describing attack rates and handling times of prey items. The third corresponds to the numerical response, or the conversion of biomass they eat into new biomass (e.g. babies)\nWe can make complex networks and systems of these equations by letting many of these paramters scale with body size via the rules of allometry and the Metabolic Theory of Ecology. This trick expands the two equations to n = number of species when we provide the toolbox with a list of species biomasses.\nEmbedded in this process are rules about how to distribute species of different sizes across trophic levels, so that we end up with predators, omnivores, herbivores and plants. We can also designate the body size relationships for different groups of organisms, like producers, invertebrates, endothermic vertebrates and ectothermic vertebrates.\nOnce we’ve done this, we can simulate the biomass dynamics of complext communities. And we can summarise things like changes in biodiversity (number of species), stability (coefficient of variation of the time series) and anything about the biomass of species, trophic levels or the community!\n\n\n\nPreamble: Setup\nOne of main advantages of running food web models in Julia is that simulations are fast and can be readily stored in your active project. With this in mind, make a new folder in your project called out_objects (right click > New Folder).\n\n\nA first run of the Ecological Network Dynamics model (BEFW)\nThere are four major steps when running the BioEnergetic Food Web model in Julia. These should be familiar from our introduction to the DifferentialEquations package:\n\nGenerate an initial food web network\nSet the parameters for each species in the network to generate the equations\nSimulate the network and equations\nExplore output and plot\n\nWhile in the previous example with Differential Equations we assumed a simple 2-species network, one of the new activities here is to take advantage of a rich history of theory and tools to construct species rich networks with appropriate structural properties, such as connectance/complexity and levels of generalism/specialism and things the number of trophic levels and a body size distribtion of the species across trophic levels.\n\nStep 1: generate an initial network\nHere we make a foodweb, actually, a food chain, from an adjacency matrix with the FoodWeb method.\n\nA = [0 0 0; 1 0 0; 0 1 0] # 1 basal producer ⋅ Species 2 eats 1 ⋅ Species 3 eats 2\nfoodweb = FoodWeb(A)\n\nFoodWeb of 3 species:\n  A: sparse matrix with 2 links\n  M: [1.0, 1.0, 1.0]\n  metabolic_class: 1 producers, 2 invertebrates, 0 vertebrates\n  method: unspecified\n  species: [s1, s2, s3]\n\n\n\n\nStep 2: Generate the model parameters\nOnce the foodweb is created, the next step is to attribute values to the model parameters. This can be simply done by calling the method ModelParameters with foodweb as an argument.\n\n# construct the equations and fixed parameters\n# see below for body size dependent parameters etc\nparams = ModelParameters(foodweb)\n\nModelParameters{BioenergeticResponse}:\n  network: FoodWeb(S=3, L=2)\n  environment: Environment(K=[1, nothing, nothing], T=293.15K)\n  biorates: BioRates(d, r, x, y, e)\n  functional_response: BioenergeticResponse\n  producer_competition: ProducerCompetition((3, 3) matrix)\n  temperature_response: NoTemperatureResponse\n\n\n\n\nStep 3: Simulate biomass dynamics\nEverything is ready to run the simulation, which can be simply done by calling simulate with the model parameters (params) and a vector species’ initial biomass (B0).\n\n# create body sizes for each species\nB0 = [0.5, 0.5, 0.5]\n\n# use simulate function\n# builds equations and uses DiffEq to run them!\nsim = simulate(params, B0)\n\nretcode: Success\nInterpolation: specialized 4th order \"free\" interpolation, specialized 2nd order \"free\" stiffness-aware interpolation\nt: 129-element Vector{Float64}:\n   0.0\n   0.07219249113352678\n   0.18654819333861794\n   0.31356331425611517\n   0.47345866183962954\n   0.6641617388942105\n   0.9131302533115802\n   1.2562392740181836\n   1.6309481665915588\n   2.089143773957029\n   2.636128104609133\n   3.293883734334714\n   4.047276405948346\n   ⋮\n 452.3138015430547\n 456.8509459661425\n 461.5266562665336\n 466.1513481974734\n 470.70605617505174\n 475.3355823765842\n 480.0140185879458\n 484.5101300067372\n 489.02575718421326\n 493.69451113794287\n 498.331767667838\n 500.0\nu: 129-element Vector{Vector{Float64}}:\n [0.5, 0.5, 0.5]\n [0.4272316681574567, 0.47585426785094076, 0.534072293177502]\n [0.3473341401191793, 0.42303815072107315, 0.5859773803469567]\n [0.294791058662908, 0.35687684744418796, 0.635235407219315]\n [0.26038496182613113, 0.28139632314454743, 0.6781234242711596]\n [0.24356863933697817, 0.2144660212785269, 0.7011935826677415]\n [0.24075042789862067, 0.15961205273400708, 0.699135084180834]\n [0.25337593682400383, 0.11902051844449948, 0.6668360012114383]\n [0.2774846493473314, 0.097203714412661, 0.6177409318953245]\n [0.31307920482758345, 0.0857704806321114, 0.5548733982179885]\n [0.3554414132717484, 0.0839628299185932, 0.48528724408580537]\n [0.39365248269575775, 0.09234997261222119, 0.4145536079678415]\n [0.40739756802826455, 0.11063681962703542, 0.35246966612900116]\n ⋮\n [0.22059513756843632, 0.18893233853869676, 0.04886706825052883]\n [0.22055285427385707, 0.1890161486143565, 0.04885919401739655]\n [0.22057127277943078, 0.18907642814450482, 0.04884560373332121]\n [0.22065930151320282, 0.1890720055670567, 0.048832142934495525]\n [0.22074484049723223, 0.18900107865719, 0.04883177554012091]\n [0.22078067645052313, 0.18891713876325852, 0.04884189574210531]\n [0.22073129917064033, 0.18885864940545732, 0.048859704977389826]\n [0.2206062055609253, 0.18892017802287123, 0.048867499198903715]\n [0.22055510500794875, 0.18900674970792372, 0.04886045346488585]\n [0.2205647417518207, 0.18907108625114374, 0.048847621938152584]\n [0.22064629570400218, 0.18907728258234632, 0.04883326864755859]\n [0.22059687801237501, 0.1890242584230083, 0.04885048633720308]\n\n\n\n\nStep 4: Seeing the outputs!\nEventually you may want to plot the biomass dynamics - the trajectory - of your community to see what is happening. For our minimal example, it can be done as follows:\n\n# create multiple objects: time = t pulled frpom the sim.t component\n# and Bx = biomass for each species pulled from the larger sim object\n# note how julia allows multiple things on left of the =\nt, B1, B2, B3 = sim.t, sim[1,:], sim[2,:], sim[3,:]; # unpack variables\n\n# Plot the basal species\nplot(t, B1, lw = 3, label=\"Producer\", xlabel = \"Time\", ylabel = \"Biomass\")\n# add the herbivore\nplot!(t, B2, lw = 3, label=\"Consumer\")\n# add the top predator\nplot!(t, B3, lw = 3, label=\"Top consumer\")\n\n\n\n\nMore generally, you could also just plot the actual simulate object directly. Much easier!\n\n plot(sim, label = [\"Producer\" \"Consumer\" \"Top consumer\";])"
  },
  {
    "objectID": "Tutorial-8_Intro To Eco Net Dyn.html#a-more-complex-example",
    "href": "Tutorial-8_Intro To Eco Net Dyn.html#a-more-complex-example",
    "title": "Tutorial 8: Introducing Ecological Network Dynamics (BEFWM2)",
    "section": "A More Complex Example",
    "text": "A More Complex Example\n\nStep 1: Generate the initial network\nIn order to run the BEFW model with a more complex network, we have to construct an initial food web network (an adjacency matrix) using the niche model. The network is characterised by the number of species in the network and its connectance/complexity value.\nNote that we are now using functionality provided by the EcologicalNetworks package.\n\nS = 20; # define the number of species\nC = 0.2; # define the connectance (complexity) of the network\n\n# construct the food web\nRandom.seed!(12325) # ensures your network and this one are the same\nfoodweb_niche = FoodWeb(nichemodel, S, C=C)\n\n# see it:\nfoodweb_niche.A\n\n20×20 SparseArrays.SparseMatrixCSC{Bool, Int64} with 80 stored entries:\n⢠⡀⠀⠀⠀⠀⠀⠀⠀⠀\n⢐⣊⣀⠀⠀⠀⠀⠀⠀⠀\n⠴⣶⣶⣤⣀⠀⠀⠀⠀⠀\n⠈⠩⠿⣿⠄⠀⠀⠀⠀⠀\n⠉⠩⠭⠭⣟⡓⠒⠒⠂⠀\n\n\n\n\nStep 2. Setting up the paramters, body masses (species) and running the model!\nAs above, our next step is to define a vector of bodymasses and then pass this, and the network to the simulate function. Here we combine the Uniform function from the Distributions package with the rand function from the Random package.\n\n# construct the equations and fixed parameters\n# see below for body size dependent parameters etc\nparams_niche = ModelParameters(foodweb_niche)\n\n# define bodymasses between 0 and 1 and get S = 20 of them.\n# this will ensure your plot looks like the one in the document\nRandom.seed!(123)\nB0 = rand(S)\n\n# simulate using params and bodymasses\n# note additional argument tmax for max time steps\n# default is 300\nsim_niche = simulate(params_niche, B0)\n\n┌ Info: Species [5] went extinct at time t = 33.834970465767604. \n└ 1 out of 20 species are extinct.\n┌ Info: Species [10, 8] went extinct at time t = 49.801980626257766. \n└ 3 out of 20 species are extinct.\n┌ Info: Species [13] went extinct at time t = 67.54842232722383. \n└ 4 out of 20 species are extinct.\n┌ Info: Species [14] went extinct at time t = 76.05686387794776. \n└ 5 out of 20 species are extinct.\n┌ Info: Species [12] went extinct at time t = 94.25974163851537. \n└ 6 out of 20 species are extinct.\n┌ Info: Species [15, 19] went extinct at time t = 180.6781729701157. \n└ 8 out of 20 species are extinct.\n\n\nretcode: Terminated\nInterpolation: specialized 4th order \"free\" interpolation, specialized 2nd order \"free\" stiffness-aware interpolation\nt: 58-element Vector{Float64}:\n   0.0\n   0.05642845716276844\n   0.11891649263385903\n   0.20769683238716719\n   0.3045875314442914\n   0.44216128503645374\n   0.6112783739340873\n   0.8303542080772176\n   1.0917849224507885\n   1.4340233039417565\n   1.8447846396665963\n   2.3653444519946065\n   3.0115146437752442\n   ⋮\n 103.19272243700584\n 111.88147068621589\n 122.54731908523809\n 133.74922122845595\n 147.26632373648013\n 162.38512727362877\n 180.6781729701157\n 180.6781729701157\n 201.57862868705948\n 226.71369483198157\n 254.89823928856072\n 289.09217901466906\nu: 58-element Vector{Vector{Float64}}:\n [0.906299638797481, 0.44349373245960455, 0.7456733811393941, 0.5120830400366143, 0.2538490889415096, 0.33415153638191886, 0.4273278808735992, 0.867547200255958, 0.09913361484360417, 0.12528740769155033, 0.6922086620547391, 0.13655147513745736, 0.03209667335274724, 0.3505458214588266, 0.9303323763821093, 0.9594335994071538, 0.5819123423876457, 0.3114475007050529, 0.12114752051812694, 0.20452981732035946]\n [0.8506750248039066, 0.316016267593785, 0.651840748854925, 0.4766336454051591, 0.25339023877433103, 0.3308187673571854, 0.3608638414554032, 0.7307871678092578, 0.10181476103833324, 0.1302817851708985, 0.7090830957307426, 0.143047476716464, 0.033895623646412715, 0.3678562194543374, 0.9644776003724441, 1.0175145940496193, 0.6126719605021673, 0.3314093482768925, 0.12683785756057048, 0.2129203618593246]\n [0.79061537214418, 0.23954384290971395, 0.5567140397232614, 0.4344170769662325, 0.24986737440786716, 0.32063982029985305, 0.2984775562116461, 0.5956422271584304, 0.10443600830700829, 0.1346128355925403, 0.7185118003079496, 0.14901914689388757, 0.03558419101698233, 0.38339997438386947, 0.9929266560084749, 1.06953278911396, 0.6433589739159863, 0.3561234135700153, 0.1320907952178632, 0.22294521665303071]\n [0.7117642849034563, 0.18269016715718198, 0.45014059997829864, 0.37591414569832066, 0.24025174448410844, 0.29858693228235306, 0.23019800620416758, 0.44447201574787, 0.10749246293160268, 0.13870921713301645, 0.7156357593162649, 0.1551843231186634, 0.03740341134849236, 0.3985440860134391, 1.0161499732316146, 1.1156297864750935, 0.6804066357941937, 0.3959202823221901, 0.137583475539412, 0.2381829213237624]\n [0.637864541406651, 0.1503421792257488, 0.3676657479332152, 0.320057566968519, 0.22564899934563057, 0.270500362707076, 0.17916060452846852, 0.33112405990653637, 0.10998421440894149, 0.14072106616155092, 0.6941158119081321, 0.15917588587457487, 0.03868647959581901, 0.40689888452777606, 1.0213288085687784, 1.1298756225554956, 0.7119244806213847, 0.4454799235433431, 0.14126170174114036, 0.25554938422424667]\n [0.5559407848636867, 0.12631052480880015, 0.2904114839844158, 0.2582931568360568, 0.20220842330556968, 0.23220438765756146, 0.13519226638942444, 0.23330213347465842, 0.11226625726272813, 0.1400453134242365, 0.641570210214102, 0.1612004426742432, 0.03955097344654741, 0.40804286723593697, 1.0015444670165246, 1.1036887633479435, 0.7408738296753514, 0.5263705064271911, 0.14343585264469774, 0.2800916946303293]\n [0.4860996729494896, 0.11179029473032814, 0.23137285784725128, 0.20552529077406026, 0.1747980995461694, 0.19357159968326387, 0.10612673454134991, 0.16719749268922784, 0.11358398642492225, 0.1352561059283022, 0.5613805721991025, 0.1598278497087544, 0.039596577742655764, 0.39819486451339087, 0.9479548560941534, 1.0301972322914708, 0.7517501261412793, 0.6414320506868165, 0.14297505072762562, 0.3074662732159045]\n [0.43062336037116583, 0.10356398289144214, 0.1844615792588205, 0.16141813485406956, 0.14575039383099775, 0.1571093339964948, 0.08742077847876842, 0.12135214811929286, 0.11378070169199302, 0.1254693865013906, 0.4587858740179325, 0.15424893136862108, 0.03869286978329806, 0.37436167030100614, 0.8503781972412569, 0.9057553075538197, 0.729041383618697, 0.8111579252058726, 0.13952231909053012, 0.33452709185125584]\n [0.3964192405936538, 0.10101479310886363, 0.1498840569184408, 0.12863185719239692, 0.12025445643257139, 0.1276930699613838, 0.07768609151302582, 0.09178438827929986, 0.1129872623811614, 0.11192393303962592, 0.3577855445251828, 0.14437936495554246, 0.03687729226745649, 0.3368923782528146, 0.7157846278632801, 0.7465856241369827, 0.6605821596120509, 1.0277574218259113, 0.133341718388981, 0.3523097808665832]\n [0.38243072371733805, 0.10377513407300389, 0.1217115949038405, 0.10226707383008429, 0.09734334186196499, 0.1028555239811688, 0.07466666450788355, 0.07043649701997969, 0.11164051273424316, 0.09471976081247838, 0.2637113630658382, 0.12885618774692784, 0.033978371827748904, 0.28249894955757976, 0.544447847842159, 0.55639341927026, 0.53893465126863, 1.2848208126971767, 0.12395874464534769, 0.35570542529504545]\n [0.3924286883443767, 0.11240697122613484, 0.10060160264185608, 0.08276595735749182, 0.07899615746867737, 0.08401465383098933, 0.0788422397090856, 0.05582188795693415, 0.11062078840452406, 0.07721940138253008, 0.19236961376758502, 0.10959561891383252, 0.03033101714965189, 0.22181251720504394, 0.38326331658163443, 0.3858474444456293, 0.40210575336666987, 1.478425292922194, 0.1124162514057935, 0.3416990564906213]\n [0.42813571326082744, 0.128675511760532, 0.08395046251363436, 0.06718291407025544, 0.0632356350441606, 0.06877541295298652, 0.09176856327149403, 0.04453967283991596, 0.11135444226987187, 0.06048784203533888, 0.1407241774293773, 0.08818893948453095, 0.02603605400173823, 0.16352606263626918, 0.25543375688046666, 0.2550430395334262, 0.2841668822226807, 1.5316936451717071, 0.09862107795307937, 0.3119844172763782]\n [0.4883402528108113, 0.15414578508205598, 0.07185284431714349, 0.05495095681805794, 0.04961797714957933, 0.05670337491344602, 0.11648832900242263, 0.0354977640435102, 0.11636390428998801, 0.0462790891202952, 0.10793925995233015, 0.06817276625365948, 0.021611980155946762, 0.11724461406725467, 0.1701205982863288, 0.17011786682827734, 0.20492293431105466, 1.4292032372179935, 0.0836268920392082, 0.2715005027005714]\n ⋮\n [0.5101103239051296, 0.21403940327788046, 0.14189753714304945, 0.001693635023410558, 0.0, 0.001728937022754008, 0.28196217073426805, 0.0, 0.31327085058093246, 0.0, 0.09473818890539755, 0.0, 0.0, 0.0, 0.0004371189961953228, 0.16431048059903605, 0.4330100545383833, 0.16207440622211108, 0.0004404178929681443, 0.16833384448884556]\n [0.5100179624486647, 0.21395516793778624, 0.142298340511395, 0.001399591351485802, 0.0, 0.0014285605990996871, 0.28201554962591546, 0.0, 0.3133389744030027, 0.0, 0.09462002403222947, 0.0, 0.0, 0.0, 0.00028712045202572195, 0.16437889628236, 0.4331528001886544, 0.1624194039181494, 0.0002894594976590179, 0.16827174480291335]\n [0.5101391685673029, 0.21385402252043828, 0.14271524798887555, 0.001112636069065219, 0.0, 0.0011355054958041792, 0.28205082269333753, 0.0, 0.3133648590256169, 0.0, 0.09463567195834738, 0.0, 0.0, 0.0, 0.00017121921065168936, 0.16445747963247836, 0.4329436890213209, 0.16283785122750755, 0.00017269486463913314, 0.16827370452881724]\n [0.5101982418484956, 0.21377046129833874, 0.1430518646451849, 0.0008782706978664726, 0.0, 0.0008962183476809098, 0.2820689756016431, 0.0, 0.3133576387193469, 0.0, 0.09471464863656844, 0.0, 0.0, 0.0, 9.947040358900451e-5, 0.1645130202313456, 0.43273362778296065, 0.1630429734495872, 0.00010035697721249949, 0.16835521456676708]\n [0.5102084335756756, 0.2136967087621238, 0.143348139597704, 0.0006630399647620726, 0.0, 0.00067651590963556, 0.2820693689719039, 0.0, 0.31332800021060336, 0.0, 0.09477320176194699, 0.0, 0.0, 0.0, 5.144861940770425e-5, 0.16454897745245234, 0.4326529862755553, 0.16308117940893418, 5.191757472306722e-5, 0.1684581303519066]\n [0.5101892000300914, 0.2136390751688376, 0.14358424821900018, 0.00048616264339761703, 0.0, 0.0004959989274277475, 0.28206673609400656, 0.0, 0.3133064900180514, 0.0, 0.09479046649120906, 0.0, 0.0, 0.0, 2.451430967046031e-5, 0.16456268461941692, 0.43267517418306095, 0.16307833641316483, 2.4740597400918844e-5, 0.16851125147059168]\n [0.5101772405476588, 0.2135902678598142, 0.1437866089869059, 0.00033524651458835785, 0.0, 0.00034200273310671747, 0.28206907831200306, 0.0, 0.31329849477167543, 0.0, 0.09479928184557744, 0.0, 0.0, 0.0, 9.887997298776258e-6, 0.164565448997319, 0.43269238896886636, 0.16311370021270755, 9.979930181003285e-6, 0.1685218827160758]\n [0.5101772405476588, 0.2135902678598142, 0.1437866089869059, 0.00033524651458835785, 0.0, 0.00034200273310671747, 0.28206907831200306, 0.0, 0.31329849477167543, 0.0, 0.09479928184557744, 0.0, 0.0, 0.0, 0.0, 0.164565448997319, 0.43269238896886636, 0.16311370021270755, 0.0, 0.1685218827160758]\n [0.5101757757677363, 0.21355240023704158, 0.1439431400036674, 0.0002200025342075797, 0.0, 0.0002244227287650652, 0.2820723375375796, 0.0, 0.3132932906420358, 0.0, 0.09481482484946595, 0.0, 0.0, 0.0, 0.0, 0.16456927133861393, 0.4326792235117793, 0.16316037540338976, 0.0, 0.1685304597671773]\n [0.5101703696591152, 0.213523666531707, 0.144060539077565, 0.00013284682506689382, 0.0, 0.00013550965212111025, 0.2820745504332237, 0.0, 0.3132897360866837, 0.0, 0.09482996255459025, 0.0, 0.0, 0.0, 0.0, 0.16456343881849694, 0.43267529562058404, 0.16317704041993888, 0.0, 0.16853030553320153]\n [0.5101657341582638, 0.21350517347728484, 0.14413728087703948, 7.556735456477713e-5, 0.0, 7.707967503593065e-5, 0.28207544097209714, 0.0, 0.31328664374561793, 0.0, 0.09483755535192052, 0.0, 0.0, 0.0, 0.0, 0.16456072931990792, 0.43267635507709945, 0.16319154463635513, 0.0, 0.1685302162465592]\n [0.5101635791665768, 0.2134928726933351, 0.14418784498203172, 3.80328307565163e-5, 0.0, 3.879316993321401e-5, 0.2820763883451882, 0.0, 0.31328518836452973, 0.0, 0.09484351749232077, 0.0, 0.0, 0.0, 0.0, 0.1645588376935647, 0.43267463374601806, 0.1632017694444765, 0.0, 0.16852982509285047]\n\n\n\n\nStep 3. Visualising the dynamics\nNow we can move to plotting again. Note how we now ask for the time directly from the simulate object and all of the biomasses from that object as well.\nNote too how we can supress the legend (which covers some of the time series).\n\nplot(sim_niche, legend = false)\n\n\n\n\nOne game to play now is to alter the bodymass distribution. rand selects a randon uniform number between 0 and 1. Can you figure out how to make the distribution uniform between 0 and 10? See what that does.\n\n\nA bit more about the process: dissecting the ModelParameters\nLet’s dissect the ModelParameters object a bit, to understand just a bit more about what is going on.\n\nparams_niche\n\nModelParameters{BioenergeticResponse}:\n  network: FoodWeb(S=20, L=80)\n  environment: Environment(K=[1, 1, ..., nothing, nothing], T=293.15K)\n  biorates: BioRates(d, r, x, y, e)\n  functional_response: BioenergeticResponse\n  producer_competition: ProducerCompetition((20, 20) matrix)\n  temperature_response: NoTemperatureResponse\n\n\nWalking through this\n\nThe network component defines the food web and reports the number of species and the links\nthe environment component reports on values of the carrying capacity (K) and the baseline temperature (T). Note that K is specified only for the basal species via [1, 1, ... nothing, nothing]. All the producers have the same K at this point (1,1,1…). The presence of the T suggests that we can ultimately work with climate change by running the model at different temperatures. There is a way to make some of the biorates and components of the functional response (see 3, 4) dependent not only on body mass, but also on temperature.\nthe biorates component contains detail on parameters central to making the model reflect a bit of reality: d is …; r is the intrinsic rate of increase (population growth rate) for the producers (plants); x and y are paramters associated with metabolic rates and consumption rates of the consumers (non-plant species). Finally, e is an efficiency/assimilation rate for the consumers eating either plants or other animals.\nthe functional_response component defines the type of consumption function being used (e.g. Type I, II, or III sensu classic ecology and Holling). The functional response defines the interaction strength between species and how consumers change how much they eat dependent on the amount (density) of resource available.There are two options. The default Bioenergetic Response corresponds to a phenomenological formulation where there are just two variables that describe how consumer consumption varies with resource density: a half-saturation parameter and an asymptote. The alternative called Classic Response is more trait based and includes the parameters attack rate and handling time. There are several other features of the functional response that can be manipulated, and these are introduced in later tutorials.\nthe producer competition component allows us to alter how plants compete with each other.\nthe temperature responsecomponewnt defines the absence or presence of temperature dependence, and when present, the shape of the relationship between biorates and functional response parameters and temperature.\n\n\n\nHelper Functions: What can we do with the outputs?\nAs noted in the pre-amble, we are most often interested in additional information about the scenarios we build with the models. These include, for example, total biomass, biodiversity and stability. Let’s see how we can calcuate some of these. Keep in mind that to use these, we have to provide a model output AND a declaration of over how many time steps we want to calculate the metrics. For example, we probably want to calculate most of these metrics when the system is at equilibrium.\n\nBefore you start with the helper functions\nIn order to use these helper functions, we need to know the number of time steps that our model has produced.\nIt is important to know that ‘time’ is rather abstract in these models, partly because the integration of the equations to make the dynamics happens at a fine scale. In order to understand what the number of data points are in your simulation, you can look at the sim.t part of the outputs.\nThe other important thing to note is that the simulation have a built in stop point when the populations get to an equilibrium. This means that even if we were to ask for n= 100000 time steps, the simulations will stop when this ‘rule’ is met.\nFinally, the algorithm is an adaptive one, so the number of output data points does not match ‘time’\nWe can find out what the number of steps is using the following code.\n\nsize(sim_niche.t) # this has 58 time points\n\n(58,)\n\n\nThis little trick tells us the max number of time steps we can specify to calculate things, like the average biomass, stability, etc.\n\n\nUsing Some Helper Functions\nFirst, we can get a meaure of total biomass in the community\n\n# we use last = 30 because the max is 58\ntotal_biomass(sim_niche, last = 30)\n\n2.487536153155013\n\n\nSecond, we can an estimate of species persistence - how many have gone extinct! Remember that we started with 20, so a value of 0.6 means that there are 12 species left.\n\n# here we specify last = 1 to get the estimate of % remaining from the start to end.\nspecies_persistence(sim_niche, last = 1)\n\n0.6\n\n\nThird, we can look at stability, defined as the coefficient of variation. Here we look at using all of the data versus using data only out towards where the equilibrium is reached.\n\n# here we can use ALL of the time steps\n# size(sim_niche.t)[1] gets the actual number\npopulation_stability(sim_niche, last = size(sim_niche.t)[1])\n\n-0.780564438364756\n\n\nJust for perspective, where you estimate stability is under your control. Here we estimate stability ‘out towards the equilibrium’ by specifying last = 30 rather than using the whole time series. This is the typical approach.\n\n# here we use only the last 30.\npopulation_stability(sim_niche, last = 30)\n\n-0.17360052844293952\n\n\nFinally, we can look at two measures of diversity. First, we can get species richness. This confirms that our persistence estimate (60%) is in line!\n\n# con\nfoodweb_richness(sim_niche, last = 1)\n\n12.0\n\n\nAnd we can estimate evenness\n\nfoodweb_evenness(sim_niche; last = 10)\n\n0.8519930037484817\n\n\n\n\n\nWhat’s next\nThe next section will introduce how to create simulations where we work with multiple networks and collect data across these. We do this using loops, and collect information in a data frame. We then work on how to embed additional changes to parameters in the loops as well."
  },
  {
    "objectID": "Tutorial-2_Using Julia for Maths and Vector Stuff.html",
    "href": "Tutorial-2_Using Julia for Maths and Vector Stuff.html",
    "title": "Tutorial 2: Using Julia for Maths and Vector Stuff",
    "section": "",
    "text": "This second document follows on from Tutorial 1: “Getting started” and assumes that you’re still working in your active project.\nThis document covers the following:\nThere is also a section at the end with some “Quick tips”."
  },
  {
    "objectID": "Tutorial-2_Using Julia for Maths and Vector Stuff.html#basic-maths",
    "href": "Tutorial-2_Using Julia for Maths and Vector Stuff.html#basic-maths",
    "title": "Tutorial 2: Using Julia for Maths and Vector Stuff",
    "section": "Basic Maths",
    "text": "Basic Maths\nAs you probably can guess, the REPL is an interface onto a large calculator. Julia does all the things R does… and you can find the basic maths operations defined The Julia Manual\n\n# sums\n1+1\n\n2\n\n\n\n# power\n10^3\n\n1000\n\n\n\n# sequences in a vector\n# From 0, by 1, to 10...\n\nx = collect(0:1:10)\n\n# see it\nx\n\n11-element Vector{Int64}:\n  0\n  1\n  2\n  3\n  4\n  5\n  6\n  7\n  8\n  9\n 10\n\n\n\n# multply scaler x vector.\nx*10\n\n11-element Vector{Int64}:\n   0\n  10\n  20\n  30\n  40\n  50\n  60\n  70\n  80\n  90\n 100"
  },
  {
    "objectID": "Tutorial-2_Using Julia for Maths and Vector Stuff.html#getting-help",
    "href": "Tutorial-2_Using Julia for Maths and Vector Stuff.html#getting-help",
    "title": "Tutorial 2: Using Julia for Maths and Vector Stuff",
    "section": "Getting Help",
    "text": "Getting Help\nBefore we move on, lets talk about the help files and how to access them. As in R, the help files assiocated with a given package, function or command can be accessed using ? followed by the function name (e.g. type ? pi in the REPL).\nSimilar to when you entered Julia’s package manager (using ]) you’ll notice that the ? command causes a change in the REPL with help?>replacing julia> as the prompt. This informs you that you’ve entered the help mode. As an exercise, use the help mode to find the difference between print and println."
  },
  {
    "objectID": "Tutorial-2_Using Julia for Maths and Vector Stuff.html#preamble-to-objects-like-scalars-vectors-and-arrays",
    "href": "Tutorial-2_Using Julia for Maths and Vector Stuff.html#preamble-to-objects-like-scalars-vectors-and-arrays",
    "title": "Tutorial 2: Using Julia for Maths and Vector Stuff",
    "section": "Preamble to Objects like scalars, vectors and arrays",
    "text": "Preamble to Objects like scalars, vectors and arrays\nBefore we start creating arrays and matrices, we’d like to demonstrate how you allocate numbers and strings to objects in Julia and check an object’s type. We’d also like to highlight some simple mathematical operations.\n\nAllocating data to objects\nAllocating in Julia is useful as it means that variables can be stored and used elsewhere. You allocate numbers to objects using the following:\nFirst note that we use the = in Julia, not the <- as in R.\n\n# allocate an Integer number to a variable\nn = 5\n\n5\n\n\nJulia, like other languages, has some built in values, like pi. We can allocate these to variable names we will use. Notice that Julia converts pi into the unicode symbol!\n\n# allocate a pre-defined number of importance to a variable\n# note that pi is converted to π\n# note2 - you can use \\pi in a julia script to get the unicode π ...\n# this works for numerous greek letters etc.  Like \\lambda for λ\npi_sum = pi\npi_sum\n\nπ = 3.1415926535897...\n\n\nWe can use these unicode symbols, like λ, as objects\n\nλ = 4\nλ\n\n4\n\n\nYou can also assign multiple values to separate variables in a concise manner. Julia can manage something like this:\n\nαi, βi, γi = 1.3, 2.1, exp(39)\n\n# confirm...\nαi, βi, γi\n\n(1.3, 2.1, 8.659340042399374e16)\n\n\n\nAllocating strings…\nOf course you can also allocate strings of text to objects. You must use the \"\" and not '' to define strings.\n\nsob = \"School of Biosciences\"\n\n\"School of Biosciences\"\n\n\nYou can combine strings and numbers to print like this. Note how you use $object.name within the text string you are writing… and this works for objects that are text or numeric.\n\nprintln(\"The favourite number in $sob is $n\")\n\nThe favourite number in School of Biosciences is 5\n\n\n\n\n\nIdentifying the Type of object you’ve made\nJulia is very specific about types of objects. Most programming languages are. One way to learn about them is to look at what is made when you make things in different ways.\n\ntypeof(n), typeof(sob), typeof(pi)\n\n(Int64, String, Irrational{:π})\n\n\nJulia is like R and Python in that it can infer the type of object (Integer, Float, etc) on the left hand side of the equals sign - you don’t have to justify it like you do in C. However, you can declare the type if needed e.g.\n\npi_custom = Float64(3.141592)\n\n3.141592\n\n\nFor those of you that are interested, a floating-point object (a Float) is a number that has a decimal place. An Int object is an integer, a number without a decimal place, whereas an Irrational object is a specific type of Float used only for representing some irrational numbers of special significance (e.g. π and γ). The 64 purely refers to 64-bit which is the type of processor your computer uses, most modern computers are 64-bit.\nOccaisionally it will be valuable to convert an object from one type to another. For example, n is currently an Integer (Int64), and we might want it to be Float (Float64). To be clear, this is a distinction between 5 and 5.0!\n\ntypeof(n)\n\nInt64\n\n\n\nn2 = convert(Float64, n)\ntypeof(n2)\n\nFloat64"
  },
  {
    "objectID": "Tutorial-2_Using Julia for Maths and Vector Stuff.html#understanding-arrays-vectors-and-sequences.",
    "href": "Tutorial-2_Using Julia for Maths and Vector Stuff.html#understanding-arrays-vectors-and-sequences.",
    "title": "Tutorial 2: Using Julia for Maths and Vector Stuff",
    "section": "Understanding Arrays, Vectors and Sequences.",
    "text": "Understanding Arrays, Vectors and Sequences.\nAs you saw above, we created a sequence of numbers using collect(0:1:10). Let’s look at what type of obect this is:\n\ntypeof(x)\n\n\nVector{Int64} (alias for Array{Int64, 1})\n\n\n\nThis is a vector. Let’s step back to see the difference between arrays and vectors. Arrays, for the R users, are best thought of as lists - they are storage boxes for any type of variables and can contain collections of various types. The general way to create an array, in this case and empty one, is the [ ].\n\nempty_array = []\n\nAny[]\n\n\nWe will first create an array with the same values as x and then see how collect() is the function that converts this to a vector, and actually lets us see the numbers too!\nFirst, range can be used to make an array. This is very similar to seq() in R and has the two variations - by and length that the R function has. The idfference is that by is replaced by the argument step. Note how a very concise summary of this array is presented using information in square brackets [ ]:\n\nx_array1 = range(start = 1, step = 1, stop = 10)\nx_array2 = range(start = 1, stop = 10, length = 5)\n\nx_array1, x_array2\n\n(1:1:10, 1.0:2.25:10.0)\n\n\nYou can also now see that creating arrays is possible with [ ] and the use of the : :\n\nx_array3 = [1:1:10]\n\n1-element Vector{StepRange{Int64, Int64}}:\n 1:1:10\n\n\nQuite often, you want to either see the values, or specifically be using a vector. To do this, you can use the function collect():\n\ncollect(x_array1)\n\n10-element Vector{Int64}:\n  1\n  2\n  3\n  4\n  5\n  6\n  7\n  8\n  9\n 10"
  },
  {
    "objectID": "Tutorial-2_Using Julia for Maths and Vector Stuff.html#indices-if-arrays.",
    "href": "Tutorial-2_Using Julia for Maths and Vector Stuff.html#indices-if-arrays.",
    "title": "Tutorial 2: Using Julia for Maths and Vector Stuff",
    "section": "Indices if Arrays.",
    "text": "Indices if Arrays.\nYou should recall from R that values in arrays and vectors and dataframes have addresses that we call indices. Julia works with indexing very similarly.\nLet’s make a simple array of 5 numbers and another simple array of five words. Note that the [] array function is a but like the c() function in R.\n\nar = [6,7,8,9,10]\nbr = [\"Pint\", \"of\", \"Moonshine\", \"please\"]\n\n4-element Vector{String}:\n \"Pint\"\n \"of\"\n \"Moonshine\"\n \"please\"\n\n\nYou can get any address in these using… square brackets!\n\nar[2] # gets the number 7!\n\n7\n\n\n\nbr[3] # gets the word Moonshine\n\n\"Moonshine\"\n\n\nIf you want two addresses in a sequence, you can just provide the sequence:\n\nar[2:3]\n\n2-element Vector{Int64}:\n 7\n 8\n\n\nBut if you want non-adjacent values, you need to provide the ‘list of indices’ as an array, which results in the use of [[ ]].\n\nar[[2,4]]\n\n2-element Vector{Int64}:\n 7\n 9\n\n\nNote this would be like using in R ar[c(2,4)]."
  },
  {
    "objectID": "Tutorial-2_Using Julia for Maths and Vector Stuff.html#broadcasting-something-very-special",
    "href": "Tutorial-2_Using Julia for Maths and Vector Stuff.html#broadcasting-something-very-special",
    "title": "Tutorial 2: Using Julia for Maths and Vector Stuff",
    "section": "Broadcasting: something VERY special",
    "text": "Broadcasting: something VERY special\nImagine that you want to apply a function, like a log() or exp() function, to an array. We saw above that we can create a vector using collect() and multiply this by a scalar\n\n# sequences in a vector\n# From 0, by 1, to 10...\n\nx = collect(0:1:10)\n\n# see it\nx\n\n11-element Vector{Int64}:\n  0\n  1\n  2\n  3\n  4\n  5\n  6\n  7\n  8\n  9\n 10\n\n\n\n# multply scaler x vector.\nx*10\n\n11-element Vector{Int64}:\n   0\n  10\n  20\n  30\n  40\n  50\n  60\n  70\n  80\n  90\n 100\n\n\nYou can work directly with arrays and pre-built functions to do things like this. To do-so, we combine the function with the (dot) . operator. Let’s work with x_array1 from above. Note how broadcasting the function across the array returns a vector.\n\n# Look at the help file for exp10\nexp_array1 = exp10.(x_array1)\n\n10-element Vector{Float64}:\n     10.0\n    100.0\n   1000.0\n  10000.0\n 100000.0\n      1.0e6\n      1.0e7\n      1.0e8\n      1.0e9\n      1.0e10\n\n\n\n# look at the help file for log - what is the defaul!?\nlog_array1 = log.(x_array1)\n\n10-element Vector{Float64}:\n 0.0\n 0.6931471805599453\n 1.0986122886681098\n 1.3862943611198906\n 1.6094379124341003\n 1.791759469228055\n 1.9459101490553132\n 2.0794415416798357\n 2.1972245773362196\n 2.302585092994046\n\n\nDid you check the help file for log? Is it the same default as we find in R?"
  },
  {
    "objectID": "Tutorial-2_Using Julia for Maths and Vector Stuff.html#matrices",
    "href": "Tutorial-2_Using Julia for Maths and Vector Stuff.html#matrices",
    "title": "Tutorial 2: Using Julia for Maths and Vector Stuff",
    "section": "Matrices",
    "text": "Matrices\nSometimes we’ll be interested in a 2-dimensional or higher version of the array/vector, and this is a matrix. Making a matrix in Julia uses the [ ] again, an separates rows of numbers with the ;\n\nmat = [1 2 3; 4 5 6]\n\n2×3 Matrix{Int64}:\n 1  2  3\n 4  5  6\n\n\nNote how there are NO commas between the numbers in each row! This is read as ‘rows are separated by ; and columns by spaces’!\nYou can also ‘pre-fill’ a matrix with zeros. This is good practice in loops and programming as pre-filling and replacing variables in a matrix is more efficient than creating the matrix on the fly. Here we demonstrate how to pre-fil a vector, matrix and high dimension array! Matrices can have more than two dimensions!\n\nvec0 = zeros(2) # 2 zeros allocated in a vector\n\n2-element Vector{Float64}:\n 0.0\n 0.0\n\n\n\nmat0 = zeros(2,3) # zeros allocated to 2 rows and 3 columns!\n\n2×3 Matrix{Float64}:\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n\n\n\narr0 = zeros(2,3,4) # 2 rows, 3 columns and 4 dimensions!\n\n2×3×4 Array{Float64, 3}:\n[:, :, 1] =\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n\n[:, :, 2] =\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n\n[:, :, 3] =\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n\n[:, :, 4] =\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n\n\nAccessing values in a matrix follows the same convention as with the vector. The convention is [row, column]\n\nmat[1,2] # value in the first row and second column\n\n2\n\n\n\nmat[1:2, 3] # rows 1 AND 2 in the 3rd column\n\n2-element Vector{Int64}:\n 3\n 6\n\n\nFinally, to get a row or column, you need to know that we need a placeholder for the missing bit of what you are asking for. If we want the second row, we ask for row 2, and stick the : placeholder in the column spot:\n\nmat[2,:]\n\n3-element Vector{Int64}:\n 4\n 5\n 6\n\n\nFor a column, we reverse this.\n\nmat[:,2]\n\n2-element Vector{Int64}:\n 2\n 5"
  },
  {
    "objectID": "Tutorial-3_Building and Working with DataFrames.html",
    "href": "Tutorial-3_Building and Working with DataFrames.html",
    "title": "Tutorial 3: Building and Working with DataFrames",
    "section": "",
    "text": "Working with vectors, arrays and matrices is important. But quite often, we want to collect high-dimension data (multiple variables) from our simulations and store them in a spreadsheet type format.\nAs you’ve seen in Tutorial 1, there are plotting macros (@df) within the StatsPlots package that allow us to work with data frame objects from the DataFrames package. A second benefit of the data frame object is that we can export it as a csv file and import this into R where we may prefer working on plotting and statistics.\nTo this end, here we will also introduce the CSV package, which is very handy for exporting DataFrame objects to csv files, and importing them as well, if you’d like."
  },
  {
    "objectID": "Tutorial-3_Building and Working with DataFrames.html#the-data-frame",
    "href": "Tutorial-3_Building and Working with DataFrames.html#the-data-frame",
    "title": "Tutorial 3: Building and Working with DataFrames",
    "section": "The Data Frame",
    "text": "The Data Frame\nTo initialise a dataframe you use the DataFrame function from the DataFrames package:\n\ndat = DataFrame(col1=[], col2=[], col3=[]) # we use [] to specify an empty column of any type and size.\n\n\n0×3 DataFrameRowcol1col2col3AnyAnyAny\n\n\nAlternately, you can specify the data type for each column.\n\ndat1 = DataFrame(col1=Float64[], col2=Int64[], col3=Float64)\n\n\n0×3 DataFrameRowcol1col2col3Float64Int64DataType\n\n\nOf course, col1 is not the only label you provide: variable names are super important and the conventions we use in R are also important here in Julia, e.g. a.b or a_b or AaBa but not a b (no spaces allowed).\n\n# provide informative column titles using:\ndat2 = DataFrame(species=[], size=[], rate=[])\n\n\n0×3 DataFrameRowspeciessizerateAnyAnyAny\n\n\n\nAllocating or adding data to a data frame.\nTo add data to a dataframe, we use the push! command.\n\nspecies = \"D. magna\"\nsize = 2.2\nrate = 4.2\n\n4.2\n\n\n\n# push!() arguments: data frame, data\npush!(dat2, [species, size, rate])\n\n\n1×3 DataFrameRowspeciessizerateAnyAnyAny1D. magna2.24.2\n\n\nOf course, the push!() function can append data to the existing data frame. It is worth noting that push! can only append one row at a time. But since Julia is so good with loops (compared to R), this will make adding data to a dataframe really easy, and we’ll learn how to do this in the next tutorial.\n\nspecies2 = \"D.pulex\"\nsize2 = 1.8\nrate2 = 3.1\n\n# push!() arguments: data frame, data\npush!(dat2, [species2, size2, rate2])\n\n\n2×3 DataFrameRowspeciessizerateAnyAnyAny1D. magna2.24.22D.pulex1.83.1\n\n\n\n\nHelper Functions for Data Frames\nYou can print data frames using println\n\nprintln(dat2)\n\n2×3 DataFrame\n Row │ species   size  rate \n     │ Any       Any   Any  \n─────┼──────────────────────\n   1 │ D. magna  2.2   4.2\n   2 │ D.pulex   1.8   3.1\n\n\nThere are first and last function that are like head and tail in R and elsewhere, with a first argument the data frame and the second argument the number of rows.\n\nfirst(dat2, 2)\n\n\n2×3 DataFrameRowspeciessizerateAnyAnyAny1D. magna2.24.22D.pulex1.83.1\n\n\n\nlast(dat2,2)\n\n\n2×3 DataFrameRowspeciessizerateAnyAnyAny1D. magna2.24.22D.pulex1.83.1\n\n\nAnd as we learned with matrices and arrays, the [row, column] method also works for data frames:\n\ndat2[1,2]\n\n2.2\n\n\n\ndat2[1,:]\n\n\nDataFrameRow (3 columns)RowspeciessizerateAnyAnyAny1D. magna2.24.2\n\n\n\ndat2[:,3]\n\n2-element Vector{Any}:\n 4.2\n 3.1"
  },
  {
    "objectID": "Tutorial-3_Building and Working with DataFrames.html#the-csv",
    "href": "Tutorial-3_Building and Working with DataFrames.html#the-csv",
    "title": "Tutorial 3: Building and Working with DataFrames",
    "section": "The CSV",
    "text": "The CSV\nAs with R, there are functions to read and write .csv files to and from dataframes. This makes interoperability with tools in R and standard data storage file formats easy.\nTo write our daphnia data to a csv file, we use a familiar syntax, but a function from the CSV package.\n\nCSV.write(\"daphniadata.csv\", dat2)\n\nOf course, you can read files in using…. yes, CSV.read. Note the second argument declares the data to go into a data frame.\n\ndaph_in = CSV.read(\"betterDaphniaData.csv\", DataFrame)"
  }
]