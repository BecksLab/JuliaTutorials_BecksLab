{
  "hash": "29dc80507167ac398fe5a080edd87cd1",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Tutorial 4: The Basics of Programming\"\ndate: last-modified\nauthor: \"Danet and Becks, based on originals by Delmas and Griffiths\"\nformat:\n    html:\n        embed-resources: true\ntitle-block-banner: true\n---\n\n\n\nThis section of the tutorials introduces programming basics, including the art of simple functions, positional arguments, keyword arguments, loops, if-else-break usage and continue-while usage.\n\nIt is important to note that if you have experience programming R, there is a major difference in Julia - the use of loops is very much advocated in Julia where as *vectorising* loops is advocated in R.\n\nBasically, we write loops in Julia.  We try to avoid them in R, if we want speed.\n\n## Functions\n\nFunctions work exactly like they do in R, however, there are three fundamental differences:\n\n- there is no need for {} brackets (thank god)\n- indenting (Julia requires seperate parts of a function to be indented - don't worry, VS Code should do this for you)\n- scoping (we'll attempt to explain this later)\n- functions always start with the word `function` and end with the word `end`. \n-to store something that is calculated in a function, you use the `return` command.\n\nLet's begin with a simple function - adding 2 to any number\n\n::: {#a5cdedb0 .cell execution_count=2}\n``` {.julia .cell-code}\nfunction plus_two(x)\n    return x+2\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n```\nplus_two (generic function with 1 method)\n```\n:::\n:::\n\n\nLet's use it now by providing an defining and x value, and asking for the function to return the new value.\n\n::: {#906252b4 .cell execution_count=3}\n``` {.julia .cell-code}\nx_in = 33\nx_out = plus_two(x_in)\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```\n35\n```\n:::\n:::\n\n\nBecause we've defined `x_out`, we can request it...\n\n::: {#9d0b4c78 .cell execution_count=4}\n``` {.julia .cell-code}\nx_out\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n```\n35\n```\n:::\n:::\n\n\n### Positional Arguments\n\nAs in **R**, input variables for functions have a specified and fixed order unless they have a default value which is explicitly specified. For instance, we can build a function that measures body weight on different planets, but defaults to estimating weight on earth with a gravitational force of 9.81:\n\n::: {#a50bde03 .cell execution_count=5}\n``` {.julia .cell-code}\nfunction bodyweight(BW_earth, g = 9.81)\n    # bw should be in kg.\n    return BW_earth*g/9.81\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```\nbodyweight (generic function with 2 methods)\n```\n:::\n:::\n\n\nNote that the function is called bodyweight, it requires in the first position a weight in kg on earth and then defaults to estimating weight on earth by using g = 9.81\n\n::: {#ecd04a3f .cell execution_count=6}\n``` {.julia .cell-code}\nbodyweight(75)\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n```\n75.0\n```\n:::\n:::\n\n\nNow, if we want to estimate they same bodyweight on Mars, where gravity is 3.72, you can specify the g-value.\n\n::: {#14c0f2af .cell execution_count=7}\n``` {.julia .cell-code}\nbodyweight(75, 3.72)\n```\n\n::: {.cell-output .cell-output-display execution_count=8}\n```\n28.44036697247706\n```\n:::\n:::\n\n\n### Keyword Arguments\n\n::: {#8766f6a0 .cell execution_count=8}\n``` {.julia .cell-code}\n# function with keyword arguments:\n# here, b and d are fixed = 2\n# a is positional\n# c is a keyword argument\n# the addition of ; before c means that c is an keyword argument and can be specified in any order, but must be named\nfunction key_word(a, b=2; c, d=2) \n    return a + b + c + d\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=9}\n```\nkey_word (generic function with 2 methods)\n```\n:::\n:::\n\n\nHere we specify _position_ 1 (a) and that c = 3\n\n::: {#7abace53 .cell execution_count=9}\n``` {.julia .cell-code}\nkey_word(1, c = 3)\n```\n\n::: {.cell-output .cell-output-display execution_count=10}\n```\n8\n```\n:::\n:::\n\n\nHere we specify c = 3, and then position 1\n\n::: {#b24ea224 .cell execution_count=10}\n``` {.julia .cell-code}\nkey_word(c=3, 1)\n```\n\n::: {.cell-output .cell-output-display execution_count=11}\n```\n8\n```\n:::\n:::\n\n\nHere we specify position 1 (a), redefine position 2 (b = 6) and declare c = 7.\n\n::: {#8364ff96 .cell execution_count=11}\n``` {.julia .cell-code}\nkey_word(1, 6, c=7)\n```\n\n::: {.cell-output .cell-output-display execution_count=12}\n```\n16\n```\n:::\n:::\n\n\nNote that this DOES NOT work, because we've failed to define c. (and or b)\n\n::: {#01261519 .cell execution_count=12}\n``` {.julia .cell-code}\nkey_word(1, 8, d=4)\n```\n\n::: {.cell-output .cell-output-error}\n```\nLoadError: UndefKeywordError: keyword argument `c` not assigned\nUndefKeywordError: keyword argument `c` not assigned\n\nStacktrace:\n [1] top-level scope\n   @ In[13]:1\n```\n:::\n:::\n\n\nTo redefine d, you'd need to define c and d.\n\n::: {#9fa30e35 .cell execution_count=13}\n``` {.julia .cell-code}\nkey_word(1, c = 8, d = 4)\n```\n\n::: {.cell-output .cell-output-display execution_count=14}\n```\n15\n```\n:::\n:::\n\n\n## Loops\n\n### For loops\nFor loops work by iterating over a specified range (e.g. 1-10) at specified intervals (e.g. 1,2,3...). For instance, we might use a for loop to fill an array:\n\n#### Filling an array\nTo fill an array, we first define an object as an array using `[]`.  \n\n::: {#95566ac9 .cell execution_count=14}\n``` {.julia .cell-code}\nI_array = []\n```\n\n::: {.cell-output .cell-output-display execution_count=15}\n```\nAny[]\n```\n:::\n:::\n\n\nLike with function, all loops start with `for` and end with `end`.  Here we iteratively fill `I_array` with 1000 random selections of 1 or 2.\n\n::: {#77e67baf .cell execution_count=15}\n``` {.julia .cell-code}\n# for loop to fill an array:\nfor i in 1:1000\n    # pick from the number 1 or 2 at random \n    # for each i'th step\n    for_test = rand((1,2)) \n    # push! and store for_test in I_array2\n    # Julia is smart enough to do this iteratively\n    # you don't necessarily have to index by `[i]` like you might do in R\n    push!(I_array, for_test) \nend\n```\n:::\n\n\nLet's look at I_array now\n\n::: {#8fa11196 .cell execution_count=16}\n``` {.julia .cell-code}\nI_array\n```\n\n::: {.cell-output .cell-output-display execution_count=17}\n```\n1000-element Vector{Any}:\n 2\n 1\n 2\n 2\n 1\n 1\n 2\n 2\n 2\n 2\n 2\n 1\n 1\n ⋮\n 1\n 1\n 1\n 1\n 1\n 1\n 2\n 2\n 2\n 1\n 1\n 2\n```\n:::\n:::\n\n\nLet's try something more complex, iterating over multiple indices\n\nA new storage container:\n\n::: {#78b373ff .cell execution_count=17}\n``` {.julia .cell-code}\ntab = []\n```\n\n::: {.cell-output .cell-output-display execution_count=18}\n```\nAny[]\n```\n:::\n:::\n\n\nNow, we fill the storage container with values of i, j and k.  Can you tell which in which order this will happen?  The first entry will be `[1,1,1]`.  The second will be `[2,1,1]`.  Do you understand why? Mess around to check.\n\n::: {#66b745cc .cell execution_count=18}\n``` {.julia .cell-code}\n# nested for loop to fill an array:\nfor k in 1:4\n    for j in 1:3\n        for i in 1:2\n            append!(tab,[[i,j,k]]) # here we've use append! to allocate iteratively to the array as opposed to using push! - both work. \n        end\n    end\nend\n```\n:::\n\n\nLet's look...\n\n::: {#a15bceab .cell execution_count=19}\n``` {.julia .cell-code}\ntab\n```\n\n::: {.cell-output .cell-output-display execution_count=20}\n```\n24-element Vector{Any}:\n [1, 1, 1]\n [2, 1, 1]\n [1, 2, 1]\n [2, 2, 1]\n [1, 3, 1]\n [2, 3, 1]\n [1, 1, 2]\n [2, 1, 2]\n [1, 2, 2]\n [2, 2, 2]\n [1, 3, 2]\n [2, 3, 2]\n [1, 1, 3]\n [2, 1, 3]\n [1, 2, 3]\n [2, 2, 3]\n [1, 3, 3]\n [2, 3, 3]\n [1, 1, 4]\n [2, 1, 4]\n [1, 2, 4]\n [2, 2, 4]\n [1, 3, 4]\n [2, 3, 4]\n```\n:::\n:::\n\n\nWe can also allocate to a multiple dimensional matrix.  When working with matrices, we can build them out of zeros and the replace the values.\n\nHere we start with a three dimensional array with 4 two x three matrices.\n\n::: {#a2794b31 .cell execution_count=20}\n``` {.julia .cell-code}\nthreeDmatrix = zeros(2,3,4)\n```\n\n::: {.cell-output .cell-output-display execution_count=21}\n```\n2×3×4 Array{Float64, 3}:\n[:, :, 1] =\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n\n[:, :, 2] =\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n\n[:, :, 3] =\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n\n[:, :, 4] =\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n```\n:::\n:::\n\n\nNow, let's do a nested loop again, but this time into the matrices.  The element we are adding each iteration is the sum of i+j+k.\n\nCan you guess how this works?\n\n::: {#29a3be11 .cell execution_count=21}\n``` {.julia .cell-code}\nfor k in 1:4\n    for j in 1:3\n        for i in 1:2\n            # note default is by column....\n            # first element allocated is 1+1+1, then 2+1+1 and this is first col\n            # then 1+2+1 and 2+2+1 into the second col\n            # then 1+3+1 and 2+3+1 into the third col\n            threeDmatrix[i,j,k] = i+j+k\n        end\n    end\nend\n```\n:::\n\n\n::: {#c65ebde3 .cell execution_count=22}\n``` {.julia .cell-code}\nthreeDmatrix\n```\n\n::: {.cell-output .cell-output-display execution_count=23}\n```\n2×3×4 Array{Float64, 3}:\n[:, :, 1] =\n 3.0  4.0  5.0\n 4.0  5.0  6.0\n\n[:, :, 2] =\n 4.0  5.0  6.0\n 5.0  6.0  7.0\n\n[:, :, 3] =\n 5.0  6.0  7.0\n 6.0  7.0  8.0\n\n[:, :, 4] =\n 6.0  7.0  8.0\n 7.0  8.0  9.0\n```\n:::\n:::\n\n\nFinally, note that we can use `println` to provide a basic marker what what is happening: we show two ways to do this in the code.\n\n::: {#7edbb0b5 .cell execution_count=23}\n``` {.julia .cell-code}\nfor k in 1:4\n    for j in 1:3\n        for i in 1:2\n            #println(i,\"-\",j,\"-\",k) # multiple quotes\n            println(\"$i-$j-$k\") # one quote, $ to grab variables\n            \n            # note default is by column....\n            # first element allocated is 1+1+1, then 2+1+1 and this is first col\n            # then 1+2+1 and 2+2+1 into the second col\n            # then 1+3+1 and 2+3+1 into the third col\n            threeDmatrix[i,j,k] = i+j+k\n        end\n    end\nend\n```\n:::\n\n\nAnd just for fun... this `println` trick can be handy for verbose tracking.  Note how `person in unique(persons)` iterates and how you can embed a variable's value in a text string.\n\n::: {#d5efcf8c .cell execution_count=24}\n``` {.julia .cell-code}\npersons = [\"Alice\", \"Alice\", \"Bob\", \"Bob2\", \"Carl\", \"Dan\"]\n\nfor person in unique(persons)\n    println(\"Hello $person\")\nend\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHello Alice\nHello Bob\nHello Bob2\nHello Carl\nHello Dan\n```\n:::\n:::\n\n\nThere are tons of different functions that can be helpful when building loops. Take a few minutes to look into the help files for `eachindex`, `eachcol`, `eachrow` and `enumerate`. They all provide slightly different ways of telling Julia how you want to loop over a problem. Also, remember that loops aren't just for allocation, they can also be very useful when doing calculations.\n\n### if, else, breaks\nWhen building a loop, it is often meaningful to stop or modify the looping process when a certain condition is met. For example, we can use the `break`, `if` and `else` statements to stop a for loop when i exceeds a given value (e.g. 10):\n\n::: {#022fdd69 .cell execution_count=25}\n``` {.julia .cell-code}\n# if and break:\nfor i in 1:100\n    println(i) # print i\n    if i >10\n        break # stop the loop with i >10\n    end   \nend\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n```\n:::\n:::\n\n\n::: {#d18bb32a .cell execution_count=26}\n``` {.julia .cell-code}\n# this loop can be modified using an if-else statement:\n# even though we are iterating to 100, it stops at 10.\nfor j in 1:100\n    if j >10\n        break # stop the loop with i >10\n    else\n        crj = j^3\n        println(\"J is = $j\") # print i\n        println(\"The Cube of $j is $crj\")\n    end\nend\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nJ is = 1\nThe Cube of 1 is 1\nJ is = 2\nThe Cube of 2 is 8\nJ is = 3\nThe Cube of 3 is 27\nJ is = 4\nThe Cube of 4 is 64\nJ is = 5\nThe Cube of 5 is 125\nJ is = 6\nThe Cube of 6 is 216\nJ is = 7\nThe Cube of 7 is 343\nJ is = 8\nThe Cube of 8 is 512\nJ is = 9\nThe Cube of 9 is 729\nJ is = 10\nThe Cube of 10 is 1000\n```\n:::\n:::\n\n\nYou'll notice that every statement requires it's own set of `for` and `end` points, and is indented as per Julia's requirements. `if` and `else` statements can be very useful when building experiments: for example we might want to stop simulating a network's dynamics if more than 50% of the species have gone extinct.\n\n### continue and while\n\n#### continue\nThe `continue` command is the opposite to `break` and can be useful when you want to skip an iteration but not stop the loop:\n\n::: {#246fc469 .cell execution_count=27}\n``` {.julia .cell-code}\nfor i in 1:30\n    # this reads: is it false that i is a multiple of 3?\n    if i % 3 == false\n        continue # makes the loop skip iterations that are a multiple of 3\n    else println(\"$i is not a multiple of 3\")\n    end\nend\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1 is not a multiple of 3\n2 is not a multiple of 3\n4 is not a multiple of 3\n5 is not a multiple of 3\n7 is not a multiple of 3\n8 is not a multiple of 3\n10 is not a multiple of 3\n11 is not a multiple of 3\n13 is not a multiple of 3\n14 is not a multiple of 3\n16 is not a multiple of 3\n17 is not a multiple of 3\n19 is not a multiple of 3\n20 is not a multiple of 3\n22 is not a multiple of 3\n23 is not a multiple of 3\n25 is not a multiple of 3\n26 is not a multiple of 3\n28 is not a multiple of 3\n29 is not a multiple of 3\n```\n:::\n:::\n\n\nCan you figure out what the code would be for keeping even numbers only? Note the change of logic from false above to true here.\n\n::: {#6069047a .cell execution_count=28}\n``` {.julia .cell-code}\nfor i in 1:10\n    # where is it true that i is a multiple of 2?\n    if i % 2 == true\n        continue # makes the loop skip iterations that are odd\n    else println(\"$i is even\")\n    end\nend\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n2 is even\n4 is even\n6 is even\n8 is even\n10 is even\n```\n:::\n:::\n\n\n#### while\n\n`while` loops provide an alternative to `for` loops and allow you to iterate until a certain condition is met:\n\n::: {#81d29bdb .cell execution_count=29}\n``` {.julia .cell-code}\n# counter that is globally scoped (see next section)\n# testval -- try changing this to see how this global variable can be used in \n# the local process below\nglobal j=0\nglobal testval = 17\n\n# note that we started with j = 0!!!\n# justify a condition\nwhile(j<testval) \n    println(\"$j is definitely less than $testval\") # prints j until j < 17\n    # step forward\n    j += 1 # count\nend\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0 is definitely less than 17\n1 is definitely less than 17\n2 is definitely less than 17\n3 is definitely less than 17\n4 is definitely less than 17\n5 is definitely less than 17\n6 is definitely less than 17\n7 is definitely less than 17\n8 is definitely less than 17\n9 is definitely less than 17\n10 is definitely less than 17\n11 is definitely less than 17\n12 is definitely less than 17\n13 is definitely less than 17\n14 is definitely less than 17\n15 is definitely less than 17\n16 is definitely less than 17\n```\n:::\n:::\n\n\n`while` loops don't require you to specify a looping sequence (e.g. `i in 1:100`).  But you do specify the starting value. The `while` loop can be very useful because sometimes you simply don't know how many iterations you might need.\n\nIn the above code, you might have spotted the word `global`. Variables can exist in the `local` or `global` scope. If a variable exists inside a loop or function it is `local` and if you want to save it beyond the loop (i.e., in your workspace) you have to make it `global` - more on this below.\n\n## combine a function and a loop\n\nLet's get a bit more complicated.  Above, you created a function that added 2 to any number.  Let's embed that in a loop and introduce `enumerate`.  Quite often, there are functions you may want to apply to multiple things, and this is the example of how to do that!\n\n::: {#d19ef7ee .cell execution_count=30}\n``` {.julia .cell-code}\n# make a vector - these are input values to our function\nvv = [1,2,3,7,9,11]\n\n# enumerate takes a special two variable starter: \"(index, value)\"\n# note how we print the index, then the output and then a line break with \\n\nfor (i, v) in enumerate(vv)\n    out = plus_two(v)\n    println(\"this is element $i of vv\")\n    println(\"$v plus 2 is equal to $out\\n\")\nend\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nthis is element 1 of vv\n1 plus 2 is equal to 3\n\nthis is element 2 of vv\n2 plus 2 is equal to 4\n\nthis is element 3 of vv\n3 plus 2 is equal to 5\n\nthis is element 4 of vv\n7 plus 2 is equal to 9\n\nthis is element 5 of vv\n9 plus 2 is equal to 11\n\nthis is element 6 of vv\n11 plus 2 is equal to 13\n\n```\n:::\n:::\n\n\n## Scoping\nScoping refers to the accessibility of a variable within your project. The scope of a variable is defined as the region of code where a variable is known and accessible. A variable can be in the global or local scope.\n\n### Global\nA variable in the `global` scope is accessible everywhere and can be modified by any part of your code. When you create (or allocate to) a variable in your script outside of a function or loop you're creating something that is `global`:\n\n::: {#a6015cec .cell execution_count=31}\n``` {.julia .cell-code}\n# global allocation to A\nA = 7\nB = zeros(1:10)\n```\n\n::: {.cell-output .cell-output-display execution_count=31}\n```\n10-element OffsetArray(::Vector{Float64}, 1:10) with eltype Float64 with indices 1:10:\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n```\n:::\n:::\n\n\nOf course you can be super literate and force a variable to be `global`\n\n::: {#614b434a .cell execution_count=32}\n``` {.julia .cell-code}\nglobal(c = 7)\n```\n\n::: {.cell-output .cell-output-display execution_count=32}\n```\n7\n```\n:::\n:::\n\n\n### Local\nA variable in the `local` scope is only accessible in that scope or in scopes eventually defined inside it. When you define a variable within a function or loop that isn't returned then you create something that is `local`:\n\n::: {#2bd65342 .cell execution_count=33}\n``` {.julia .cell-code}\n# global\nC2 = zeros(10)\n```\n\n::: {.cell-output .cell-output-display execution_count=33}\n```\n10-element Vector{Float64}:\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n```\n:::\n:::\n\n\n::: {#b0ffe7e8 .cell execution_count=34}\n``` {.julia .cell-code}\n# local:\nfor i in 1:10\n    local_varb = 2 # local_varb is defined inside the loop and is therefore local (only accessible within the loop)\n    C2[i] = local_varb*i # in comparison, C is defined outside of the loop and is therefore global \nend\n```\n:::\n\n\nNow, let's see what we can see.\n\nC2 is `global` and it had numbers assigned to it, and we can see it.\n\n::: {#a861cb09 .cell execution_count=35}\n``` {.julia .cell-code}\nC2\n```\n\n::: {.cell-output .cell-output-display execution_count=35}\n```\n10-element Vector{Float64}:\n  2.0\n  4.0\n  6.0\n  8.0\n 10.0\n 12.0\n 14.0\n 16.0\n 18.0\n 20.0\n```\n:::\n:::\n\n\nHowever, `local_varb` is local, and we can't ask for anything about it.  If we wanted to know about it, we'd have to ask for it to be `println`-ed to monitor it, or written (as it was to C2)\n\n::: {#7805b5e9 .cell execution_count=36}\n``` {.julia .cell-code}\nlocal_varb\n```\n\n::: {.cell-output .cell-output-error}\n```\nLoadError: UndefVarError: `local_varb` not defined in `Main`\nSuggestion: check for spelling errors or missing imports.\nUndefVarError: `local_varb` not defined in `Main`\nSuggestion: check for spelling errors or missing imports.\n```\n:::\n:::\n\n\n",
    "supporting": [
      "4_programming_basics_files"
    ],
    "filters": [],
    "includes": {}
  }
}