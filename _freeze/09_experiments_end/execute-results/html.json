{
  "hash": "d39fe2665bdcff9e52bb9bbdc2c04c94",
  "result": {
    "engine": "julia",
    "markdown": "---\ntitle: \"Tutorial 9: Experiments with the END\"\ndate: last-modified\nauthor: \"Danet and Becks, based on originals by Delmas and Griffiths\"\nformat:\n    html:\n        embed-resources: true\ntitle-block-banner: true\nengine: julia\n---\n\n\nIn the previous chapter, we learned how to make networks and run a simulation.  We did this for a simple tri-trophic chain where we specified the network with a matrix of ones and zeros, and for a more complex network defined by the niche model where we specified species richness and connectance.  We also learned how to visualise the simulations and to collect several metrics about the simulations, including detail on biomass, diversity and stability.\n\nIn this tutorial, we are going to learn how to do experiments.  We'll learn first how to generate multiple networks and collect information on how network structure impacts our metrics.  Then we'll learn how to manipulate parameters in the model, again collecting information on how variation in these parameters impacts our metrics.\n\nFor example, we might be interested in how species richness or connectance impacts biomass and stability.  Or how the carrying capacity of the producers impacts biomass and stability of the community (e.g. bottom up processes).  We'll look at both of these.\n\n### Getting Setup\n\nAs with our previous exercises, we need to have a few packages that allow making networks, simulating them and collecting the data\n\n\n\n::: {#2 .cell execution_count=1}\n``` {.julia .cell-code}\nusing DataFrames, Plots, Random, Distributions\nusing EcologicalNetworksDynamics\n```\n:::\n\n\n\n\n\n### Your (re)introduction to loops: making multiple networks example\n\nOne of the tricks to doing experiments is learning how to run a loop.  Julia is super-fast with running loops.  This is a bit different to R, which has a bad rep for loops.  It's not terrible.  But Julia is built to do loops fast.\n\nWhat we will do here is build a simple loop that makes 3 networks, each with a different species richness, but the same connectance.\n\nNote here that we introduce the use of the argument `tol_C`.  Because the `niche model` produces networks based on probability theory (it uses the beta-distribution), the connectance we ask for is not always the connectance we get.  The `tol_C` argument ensure that connectance is within a _tolerance_ range - in this case, having asked for `C = 0.2` and a `tol_C = 0.01` we will get `0.19 < C < 2.01`.  This is like embedding a while loop within the `FoodWeb` function!  We note too that the function `nichemodel` can take a value of `L` instead of `C`, and there is an associated `tol_L` argument for this choice too.\n\n\n\n::: {#4 .cell execution_count=1}\n``` {.julia .cell-code}\nRandom.seed!(12325) # ensures your network and this one are the same\n\nS = [10,20,30] # define the number of species\nC = 0.2 # define the connectance (complexity) of the network\n\n# collection zone for the networks\nnets = []\n\n# construct the food webs\n# we loop over the 3 values of S\n# we use push!() to add the food webs to nets\n# always start with a for and end with an end.\nfor i in 1:3\n    push!(nets, Foodweb(:niche; S = S[i], C = C))\nend\n```\n:::\n\n\n\n\n\nGreat.  Let's see if we got what we expected in nets.\n\n\n\n::: {#6 .cell execution_count=1}\n``` {.julia .cell-code}\nnets\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n3-element Vector{Any}:\n blueprint for Foodweb with 22 trophic links\n blueprint for Foodweb with 81 trophic links\n blueprint for Foodweb with 182 trophic links\n```\n:::\n:::\n\n\n\n\n\nMagnificent, we have three networs and that's a win.  We also see that they are each for a different and appropriate S.  Win no. 2.  We can actually now check to see what the connectances actually are. Again, we'll use a loop, `println` and introduce you to the details of the `FoodWeb` object.\n\nFirst, let's look at one of the networks.\n\n\n\n::: {#8 .cell execution_count=1}\n``` {.julia .cell-code}\nnets[1]\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nblueprint for Foodweb with 22 trophic links:\n  A: 10×10 SparseArrays.SparseMatrixCSC{Bool, Int64} with 22 stored entries:\n ⋅  1  1  1  1  1  1  1  1  1\n ⋅  1  1  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅\n ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅\n ⋅  ⋅  ⋅  ⋅  1  1  1  1  ⋅  ⋅\n ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅\n ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  1  1\n ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  1  ⋅  ⋅\n ⋅  ⋅  ⋅  ⋅  ⋅  1  1  1  ⋅  ⋅\n ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  1\n ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅\n```\n:::\n:::\n\n\n\n\n\nWe can see that the `A` element is the matrix and you can guess that the `M` is the body `M`asses.  We also find tha there are 3 producers and 7 invertebrates and it is derived from the niche model\n\n::: {.callout-tip}\n\nA side note on the metabolic classes.  The default parametrisation, and nearly all of the published work with the BEFW, uses invertebrates for all the non-producer species.  It is possible to include others.  But the data, currently, are not helpful (low volume) in supporting robust inference with these types of species.\n:::\n\nNow, recall that we can look specifically at the matrix by using `nets[1].A` which grabs the `A` part.  We introduce here the function `sum`.  As in **R**, `sum()` does what it says on the tin: for a vector, it addes up all the numbers and for a matrix, it does the same!  In our case here, when `sum()` is applied to a matrix of ones and zeros, it counts all the 1's.... thus is the estimate of the number of links in the community.  \n\nFinally, we note (again?) that `size` applied to the network returns two numbers - the number of rows and the number of columns.  For our networks, the matrix is square.  So grabbing one of these (rows = [1]) and squaring it delivers our 'potential number of links' (e.g. $species^2$).  \n\nWe can put that all together here to define connectance as $Con = links/S^2$.  Do be careful to watch where you put the various `[]`'s.  One of them is about the _index_ (i.e. `[i]`) and the other is about the dimension (`[1]`) of the matrix.\n\n\n\n::: {#10 .cell execution_count=1}\n``` {.julia .cell-code}\nfor i in 1:3\n    println(sum(nets[i].A)/size(nets[i].A)[1]^2)\n    end\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0.22\n0.2025\n0.20222222222222222\n```\n:::\n:::\n\n\n\n\n\n#### Different ways to run loops.\n\nThere is another way to make this set of networks.  Here we use a `while` loop to create 3 networks with the same species richness and connectance.  We might need to do this to generate _replicates_.  This is a good exercise with the **niche model** as it reminds you that it is a probabilistic tool... you can get several networks with the same S and C, but the links will be in slightly different places.\n\n`while` loops work on conditions... for example, if we want three networks, we could ask that the loop keep working to make the networks until we have three.  To do this, we need a _monitoring_ variable that lets us assess where we are against our target.\n\nLets see how to do that.\n\n\n\n::: {#12 .cell execution_count=1}\n``` {.julia .cell-code}\n# how many replicates do we want?\nreps = 3\n\nbegin\n\t# list to store networks\n\tglobal networks = []\n\t# monitoring variable l (the letter l)\n\tglobal l = length(networks)\n\n    # while loop\n\twhile l < reps # reps is 3 here...\n\t    # generate a network\n\t    A = Foodweb(:niche; S = 20, C = 0.15)\n\t    # add the network to the set\n        push!(networks, A)\n        # update the monitor\n\t    global l = length(networks)\n\tend\nend\n```\n:::\n\n\n\n\n\nThe term `global` means that the obects are made available in our global environment and should be there for us to see.  If you look closely at the mini-matrices, you'll see they are all different in micro-structure, despite having the same number of links and the same connectance.\n\n::: {.callout-note}\n\nThe presentation of the matrix is very specific here... the rows correspond to the predators and the columns the resources.  Obstensibly, the ranking is by body size, so small things are at the upper left.  This view shows that big things tend to eat small and big things, while small things eat small. Historically, the reflection (pivot around the diagnol) has also been used, where the predators are the columns and the resources the rows. This lead to a 'feature' of real and theoretical networks aligning, call `upper triangularity`.  In this latter presentation, most of the links would be in the upper triangle.  In the current presentation, the links are in the lower triangle.  So we can just call the feature `triangularity`.  The niche model reproduces this triangularity.\n:::\n\n\n\n\n::: {#14 .cell execution_count=1}\n``` {.julia .cell-code}\nnetworks\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n3-element Vector{Any}:\n blueprint for Foodweb with 55 trophic links\n blueprint for Foodweb with 63 trophic links\n blueprint for Foodweb with 62 trophic links\n```\n:::\n:::\n\n\n\n::: {#16 .cell execution_count=1}\n``` {.julia .cell-code}\nnetworks[1].A\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n20×20 SparseArrays.SparseMatrixCSC{Bool, Int64} with 55 stored entries:\n⎡⠉⠉⠉⣉⡡⠐⠒⠒⠒⠂⎤\n⎢⠀⠀⠀⠀⠀⠔⠒⠒⠒⠂⎥\n⎢⠀⠀⠀⠀⠨⠕⠒⠒⠒⠂⎥\n⎢⠀⠀⠀⠀⠀⠀⠐⠒⠿⡅⎥\n⎣⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⎦\n```\n:::\n:::\n\n\n\n::: {#18 .cell execution_count=1}\n``` {.julia .cell-code}\nnetworks[2].A\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n20×20 SparseArrays.SparseMatrixCSC{Bool, Int64} with 63 stored entries:\n⎡⠉⠩⠭⠉⠉⠁⠀⠀⠀⠒⎤\n⎢⠀⠀⠈⠒⣒⠒⠒⠶⠤⠀⎥\n⎢⠀⠀⠀⠀⠒⠀⠨⣭⣭⡤⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠤⠤⠉⎥\n⎣⠀⠀⠀⠀⠀⠀⠀⠀⠐⠛⎦\n```\n:::\n:::\n\n\n\n::: {#20 .cell execution_count=1}\n``` {.julia .cell-code}\nnetworks[3].A\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n20×20 SparseArrays.SparseMatrixCSC{Bool, Int64} with 62 stored entries:\n⎡⣀⣭⣭⣍⣉⣉⡉⠉⠁⠀⎤\n⎢⠀⠀⠀⠉⠉⠁⢠⠤⠤⠤⎥\n⎢⠀⠀⠀⠀⠀⠉⢰⣶⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠈⠉⡀⠀⎥\n⎣⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⎦\n```\n:::\n:::\n\n\n\n\n\n### Linking the networks to the Ecological Networks Dynamics\n\nFantastic.  Now you are ready for the next steps.  We want to run the `EcologicalNetworksDynamics` model on each of these networks.  Furthermore, we want to collect the biomass and stability information for all three into a data frame.  Let's see how we do that.\n\n#### Step 1: Create the collecting data frame\n\nFirst, we create the holding pen for our information.  We'll construct a data frame to collect five pieces of information: the network id (1,2 or 3), species richness at the start (our initial S), species richness at the end, total biomass at the end and stability at the end.\n\n\n\n::: {#22 .cell execution_count=1}\n``` {.julia .cell-code}\noutputs = DataFrame(Network = [], Init_Rich = [], Fin_Rich = [], Tot_biomass = [], Shannon_dic = [])\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```{=html}\n<div><div style = \"float: left;\"><span>0×5 DataFrame</span></div><div style = \"clear: both;\"></div></div><div class = \"data-frame\" style = \"overflow-x: scroll;\"><table class = \"data-frame\" style = \"margin-bottom: 6px;\"><thead><tr class = \"header\"><th class = \"rowNumber\" style = \"font-weight: bold; text-align: right;\">Row</th><th style = \"text-align: left;\">Network</th><th style = \"text-align: left;\">Init_Rich</th><th style = \"text-align: left;\">Fin_Rich</th><th style = \"text-align: left;\">Tot_biomass</th><th style = \"text-align: left;\">Shannon_dic</th></tr><tr class = \"subheader headerLastRow\"><th class = \"rowNumber\" style = \"font-weight: bold; text-align: right;\"></th><th title = \"Any\" style = \"text-align: left;\">Any</th><th title = \"Any\" style = \"text-align: left;\">Any</th><th title = \"Any\" style = \"text-align: left;\">Any</th><th title = \"Any\" style = \"text-align: left;\">Any</th><th title = \"Any\" style = \"text-align: left;\">Any</th></tr></thead><tbody></tbody></table></div>\n```\n:::\n:::\n\n\n\n\n\n#### Step 2: use the pre-defined networks\n\nWe can use our `nets` object from above now.  Each of these networks has a different species richness.\n\n\n\n::: {#24 .cell execution_count=1}\n``` {.julia .cell-code}\nfor i in 1:3\n\n    # prep: define size of network\n    S = size(nets[i].A)[1]\n\n    # deliver some progress reporting\n    println(\"\\nThis is network: \", i, \"with species richness = \", S,\"\\n\")\n\n    # step A: define model paramters\n    params = default_model(nets[i])\n\n    # step B: define body mass\n    B0 =  rand(S)\n\n    # step C: set number of timestamps\n    t = 300\n\n    # step D: simulate\n    out = simulate(params, B0, t)\n\n    # steps D: calculate metrics\n    fin_rich = richness(out)\n    fin_biomass = total_biomass(out)\n    s_div = shannon_diversity(out)\n\n    # step E: add things to the data frame\n    # note the first arg is the data frame and then\n    # the values we want allocated to the five slots\n    # are in []\n    push!(outputs, [i, S, fin_rich, fin_biomass, s_div])\nend\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nThis is network: 1with species richness = 10\n\n\nThis is network: 2with species richness = 20\n\n\nThis is network: 3with species richness = 30\n\n```\n:::\n:::\n\n\n\n\n\nAmazing.  Let's see if what we wanted collected has ended up in our data frame.  Wonderful! Splendiferous.  Fantabulous.\n\n\n\n::: {#26 .cell execution_count=1}\n``` {.julia .cell-code}\nprintln(outputs)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n3×5 DataFrame\n Row │ Network  Init_Rich  Fin_Rich                           Tot_biomass      ⋯\n     │ Any      Any        Any                                Any              ⋯\n─────┼──────────────────────────────────────────────────────────────────────────\n   1 │ 1        10         [10, 10, 10, 10, 10, 10, 10, 10,…  [4.70537, 4.6319 ⋯\n   2 │ 2        20         [20, 20, 20, 20, 20, 20, 20, 20,…  [8.52201, 8.4081\n   3 │ 3        30         [30, 30, 30, 30, 30, 30, 30, 30,…  [14.7649, 14.508\n                                                               2 columns omitted\n```\n:::\n:::\n\n\n\n\n\n#### Dissecting more from simulate\n\nNote the details on extinctions that comes from a model run.  For example, let's revisit our `sim_niche` object (you won't necessarily have to re-run this if you are working in one big script)\n\n\n\n::: {#28 .cell execution_count=1}\n``` {.julia .cell-code}\nS = 20; # define the number of species\nC = 0.2; # define the connectance (complexity) of the network\n\n# construct the food web\nRandom.seed!(12325) # ensures your network and this one are the same\nfoodweb_niche = Foodweb(:niche; S = S, C = C)\n\n# construct the equations and fixed parameters\nparams_niche = default_model(foodweb_niche)\n\n# define bodymasses between 0 and 1 and get S = 20 of them.\nRandom.seed!(123)\nB0 = rand(S)\n\n# simulate using params and bodymasses\n# specify number of time steps\nt = 300\nsim_niche = simulate(params_niche, B0, t)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nretcode: Success\nInterpolation: 3rd order Hermite\nt: 51-element Vector{Float64}:\n   0.0\n   0.0983252574499891\n   0.28544083243480267\n   0.5267982237043161\n   0.8245753364604138\n   1.181896742988936\n   1.6418353914084878\n   2.203829100924959\n   2.893464061893281\n   3.729699102007749\n   ⋮\n 166.67876410920994\n 179.5612866567586\n 193.9800038364207\n 210.21105297520486\n 227.83156289127072\n 247.0838336915681\n 267.94281052881126\n 290.8959793077713\n 300.0\nu: 51-element Vector{Vector{Float64}}:\n [0.906299638797481, 0.44349373245960455, 0.7456733811393941, 0.5120830400366143, 0.2538490889415096, 0.33415153638191886, 0.4273278808735992, 0.867547200255958, 0.09913361484360417, 0.12528740769155033, 0.6922086620547391, 0.13655147513745736, 0.03209667335274724, 0.3505458214588266, 0.9303323763821093, 0.9594335994071538, 0.5819123423876457, 0.3114475007050529, 0.12114752051812694, 0.20452981732035946]\n [0.9169483131714715, 0.444402194534041, 0.7667640455857161, 0.5179071161683636, 0.25596644376248334, 0.3439614083570855, 0.42881389580038637, 0.8404857181508336, 0.10207349613818459, 0.12980979255930417, 0.7045585608788062, 0.14142469702894178, 0.033700254458592344, 0.35322775442579823, 0.9254383246584946, 0.8428424981719224, 0.5353929049386887, 0.2716712297929136, 0.11790964375471776, 0.20588623005171253]\n [0.9372189186622565, 0.446138581295766, 0.8030805319662981, 0.5280429096670912, 0.25960285298532004, 0.36088969827160805, 0.43143000229873113, 0.7941678141517742, 0.107334065965393, 0.13803877097876832, 0.7224846396419364, 0.150274714852675, 0.03655779055568964, 0.35202356186576755, 0.8867871855452475, 0.6561325211685619, 0.45370991951901846, 0.21879863147029777, 0.1144327890249893, 0.21137607850479412]\n [0.963419944890434, 0.4478457678502066, 0.8407656301021255, 0.5394619505769526, 0.26358620538619504, 0.3785307293750754, 0.43443524658702654, 0.7426580903726461, 0.11338938338304744, 0.1475698891121404, 0.7345099631141349, 0.16048747662896795, 0.03959434344670769, 0.3379755377009729, 0.7958692645000881, 0.48283669535781387, 0.36706195693003885, 0.17548000193294144, 0.1136592394878268, 0.22309854306314952]\n [0.995616193064571, 0.44805738727466143, 0.8700643195894429, 0.5512240918443782, 0.2674989824178032, 0.3924051349926597, 0.4375425793363201, 0.6886449125246876, 0.11960335804730916, 0.15695502649258633, 0.7327878032629778, 0.17047486846995694, 0.0420936774665965, 0.3062032871443506, 0.6610340292426684, 0.34855000462048347, 0.2881369319293169, 0.14175624955652485, 0.11666389844136492, 0.24243967254676815]\n [1.0331366869886944, 0.44448629343725343, 0.8788288901686566, 0.5620901047900512, 0.2708572048035862, 0.39695429480179645, 0.44018298027640984, 0.6333401253753693, 0.1252037789780579, 0.1640984843116221, 0.7114983769875807, 0.17795514254857084, 0.04354809380952039, 0.26092610308891634, 0.5154058541922188, 0.25624511921879434, 0.22330145420147088, 0.11586948470233616, 0.12436895504970236, 0.26962910331924905]\n [1.0773089982155897, 0.43396923698721435, 0.8556572961992899, 0.5707904139404543, 0.2731983214483226, 0.38705755776238965, 0.4413794083264426, 0.57197930814629, 0.12978003467017415, 0.16724868374246712, 0.6675169557355778, 0.18101017312972054, 0.04388752925907648, 0.20909394578211202, 0.3805309865842198, 0.19230727005942244, 0.16943175281775166, 0.09443672996682428, 0.13906102138589269, 0.30741066949967055]\n [1.1213743703927337, 0.4149870885160012, 0.7975741540831984, 0.5733620864984142, 0.2733077885606147, 0.36141676843558873, 0.4391552288251882, 0.5071960218562799, 0.13225598133704913, 0.1649144766546638, 0.6093837906327526, 0.17807037605762552, 0.04315159765633695, 0.1631734536430942, 0.2790930366914647, 0.15237925689592774, 0.12890880773111002, 0.0777317468581009, 0.16225155189984958, 0.35425475261372863]\n [1.1573410183305781, 0.3875799067335869, 0.7122633234623346, 0.5656661531044221, 0.2699342224158771, 0.32362037390928877, 0.43151833519945715, 0.43980122366299085, 0.1320832740044849, 0.15754833392958092, 0.5485937790090555, 0.16967851768901068, 0.04155688582593655, 0.12670961646818607, 0.20790093579654878, 0.12919220653556573, 0.09920527144448085, 0.06511083602693121, 0.1957265685332169, 0.40863184877785175]\n [1.1744909386178761, 0.35353525150930704, 0.6130415990319116, 0.5442924204781258, 0.2619765432579562, 0.2797239154423789, 0.41725964546931765, 0.3734718885747243, 0.12906194711831975, 0.14648620822639452, 0.49617455885534983, 0.15734180901650238, 0.039351964038387546, 0.0993990767009241, 0.15977668195469585, 0.1193453433823383, 0.07853078787521317, 0.05684848395648957, 0.23880211323157663, 0.46473430625333423]\n ⋮\n [6.0796918581521705e-5, 0.00013150891522234224, 5.122984902540371e-5, 5.055926352857151e-6, 0.0011197509119841174, 2.72109224811782e-5, 0.004805123705502722, 0.23714938621163634, 0.020346986070423154, 2.4630532478621647e-5, 0.4450777658015223, 2.5911085615199446e-5, 0.19582059388974904, 0.10090484291038816, 0.041751108986210705, 0.21605866945924587, 0.009748297718852397, 0.11095477485031849, 0.30896576290589634, 0.4836187314820017]\n [2.9540113222151e-5, 8.00347447969903e-5, 2.6268553079711177e-5, 2.3358462951417747e-6, 0.0008502538978680421, 1.3952641028716671e-5, 0.003612589598646932, 0.23963412412987403, 0.01792469665365543, 1.2629101515044369e-5, 0.4453417610336027, 1.3285671319409156e-5, 0.19486664345425517, 0.10209874101896887, 0.041891604062320766, 0.21602379754402518, 0.009562083807607504, 0.11101835580257087, 0.30897071352241884, 0.4835914564059694]\n [1.316661642751681e-5, 4.609615826134825e-5, 1.2418593996049657e-5, 9.87501335764045e-7, 0.0006289434801502857, 6.59618354592074e-6, 0.002629372386546568, 0.2419049154522667, 0.015626334170663347, 5.970359692603688e-6, 0.4456057549872397, 6.280744324667517e-6, 0.1940092465353524, 0.10314206416967744, 0.0420485758853443, 0.21600078661726943, 0.009371522869375187, 0.11107366457274223, 0.3089769794043164, 0.48355133078828855]\n [5.288582093785549e-6, 2.4853056623499225e-5, 5.324319645605664e-6, 3.7495755124149537e-7, 0.00045102371927351975, 2.8280327624781335e-6, 0.0018418173438047429, 0.2439592430702398, 0.013458321791611608, 2.5596925779574415e-6, 0.4458725663247356, 2.692763414905926e-6, 0.19326957086921884, 0.10403490013930573, 0.042221577622635696, 0.21597907364641333, 0.009176377022193363, 0.11112583015352114, 0.3089834736189299, 0.4835073952356987]\n [1.960571334007521e-6, 1.2748386630111396e-5, 2.1159119561950705e-6, 1.3122771778576438e-7, 0.0003164923062583726, 1.1238747466113514e-6, 0.0012535673852470278, 0.24574331054112852, 0.011504652249723045, 1.017230170364437e-6, 0.4461273330206475, 1.0701126911794138e-6, 0.19267165202202277, 0.10475075390986296, 0.0424010070435812, 0.21595925499505683, 0.00898446860287164, 0.11117426849257206, 0.3089897837893917, 0.48346305093156516]\n [6.595296475494325e-7, 6.1574954853343675e-6, 7.67357373566243e-7, 4.1573174270631394e-8, 0.00021630952401954456, 4.075848117129789e-7, 0.0008246351715284488, 0.24730063052934673, 0.00974480715081397, 3.6890828572072965e-7, 0.4463589658988681, 3.880865976514459e-7, 0.19219749029311017, 0.10531819548617594, 0.04258477175808697, 0.21594251593609987, 0.008795235529896587, 0.11122083597719083, 0.30899624003374065, 0.48342085433959275]\n [2.0108052810536977e-7, 2.8004575219407987e-6, 2.5369560293938255e-7, 1.1906566312871398e-8, 0.00014408987057477836, 1.3475139250269254e-7, 0.0005246117248176988, 0.2486425196015011, 0.008183727277331717, 1.2196446539134927e-7, 0.446562570567622, 1.2830498581876193e-7, 0.19183327165072156, 0.10575941597680824, 0.04276848561653339, 0.2159276885416831, 0.008611086962688601, 0.11126649455155886, 0.30900276016551753, 0.4833835692537177]\n [5.358504987922635e-8, 1.1745932017073953e-6, 7.398752912487071e-8, 2.9651920612526094e-9, 9.266705935784892e-5, 3.9298759867059995e-8, 0.00031929137827159507, 0.2498113303049815, 0.006788855740345596, 3.556958190356424e-8, 0.4467437607789965, 3.741872366693396e-8, 0.1915528586838708, 0.10610455981304934, 0.04295191471615347, 0.21591384077476136, 0.008430160333178009, 0.11131227568908975, 0.30900934087544246, 0.4833508222341021]\n [3.282185490440947e-8, 8.406671643632279e-7, 4.664050899791412e-8, 1.7793663607443082e-9, 7.799523091115677e-5, 2.4773285239966867e-8, 0.00026279733144282983, 0.25020397488876517, 0.0063127663624026826, 2.2422472598567405e-8, 0.446805543604753, 2.3588140754728694e-8, 0.19146688286682312, 0.10621159455439007, 0.04301932407943414, 0.21590899888518364, 0.008364030293671913, 0.11132929056688841, 0.3090117977251234, 0.48333975047389044]\n```\n:::\n:::\n\n\n\n\n\nWe've constructed a helper function to get information on which species go extinct and when they do.\n\n::: {.callout-caution}\n## Warning\n\nSection is no longer a built-in functionality in END. Alain should be able to address\n:::\n\n\n\n::: {#30 .cell execution_count=0}\n``` {.julia .cell-code}\n# collect and organise extinctions\nextinctions = get_extinct_species(sim_niche)\n```\n:::\n\n\n\n\n\nThis is a `Dict` object.  The numbers on the left of the `=>` are known as the `keys` and the numbers on the right are `values`.  We can create a mini- data frame out of this with the following code.  `key` and `values` are actually _extractor_ functions and `collect` is translating the extracted information into a vector.\n\n\n\n::: {#32 .cell execution_count=0}\n``` {.julia .cell-code}\n# create a data frame of extinctions\nee1 = DataFrame(who = collect(keys(extinctions)), when = collect(values(extinctions)))\n```\n:::\n\n\n\n\n\nNow we can try and add this information to the plot.  For the time being, we'll focus on adding the times that each of these species goes extinct to our figure.  To do this we need to access the extinction time column (`when`), add a bit of noise/jitter so that times that are really close together can be seen on our x-axis, and then plot these as points with coordinates `x = when` and `y = 0`.\n\n\n\n::: {#34 .cell execution_count=0}\n``` {.julia .cell-code}\n# add some jitter for close together events\nexts = ee1[:,2] .+rand.()\n\n# plot\nplot(sim_niche)\n# add jittered extinction events.\nplot!(exts, zeros(size(ee1[:,1])), seriestype = :scatter, legend = false)\n\n```\n:::\n\n\n\n\n\nPretty cool!\n\n### What's next\n\nIn the next chapter, you'll be creating larger experiments with loops over actual parameters in the model, including the predator-prey size ratio, values of carry capacity and the predator-prey size ratio.\n\n",
    "supporting": [
      "09_experiments_end_files"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js\" integrity=\"sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js\" integrity=\"sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==\" crossorigin=\"anonymous\" data-relocate-top=\"true\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}