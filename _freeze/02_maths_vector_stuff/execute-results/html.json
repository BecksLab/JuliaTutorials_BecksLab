{
  "hash": "e0c69d3751cbe7b0032545016d6f1749",
  "result": {
    "engine": "julia",
    "markdown": "---\ntitle: \"Tutorial 2: Using Julia for Maths and Vector Stuff\"\ndate: last-modified\nauthor: \"Danet and Becks, based on originals by Delmas and Griffiths\"\nformat:\n    html:\n        embed-resources: true\ntitle-block-banner: true\nengine: julia\n---\n\n\n\n\n\n\nThis second document follows on from Tutorial 1: \"Getting started\" and assumes that you're still working in your active project.\n\nThere is also a section at the end with some \"Quick tips\".\n\n## Basic Maths {#sec-basic-maths}\n\nAs you probably can guess, the REPL is an interface onto a large calculator.  Julia does all the things R does... and you can find the basic maths operations defined [The Julia Manual](https://docs.julialang.org/en/v1/manual/mathematical-operations/index.html)\n\nsums\n\n\n::: {#4 .cell execution_count=1}\n``` {.julia .cell-code}\n1+1\n```\n:::\n\n\n\n\n\nexponents\n\n\n::: {#6 .cell execution_count=1}\n``` {.julia .cell-code}\n10^3\n```\n:::\n\n\n\n\n\nsequences in a vector\n\n\n::: {#8 .cell execution_count=1}\n``` {.julia .cell-code}\n\n# From 0, by 1, to 10...\n\nx = collect(0:1:10)\n\n# see it\nx\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n11-element Vector{Int64}:\n  0\n  1\n  2\n  3\n  4\n  5\n  6\n  7\n  8\n  9\n 10\n```\n:::\n:::\n\n\n\n\n\nmultiply vector by scalar value\n\n\n::: {#10 .cell execution_count=1}\n``` {.julia .cell-code}\n\nx*10\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n11-element Vector{Int64}:\n   0\n  10\n  20\n  30\n  40\n  50\n  60\n  70\n  80\n  90\n 100\n```\n:::\n:::\n\n\n\n\n\n## Getting Help {#sec-getting-help}\n\nBefore we move on, lets talk about the help files and how to access them. As in R, the help files associated with a given package, function or command can be accessed using `?` followed by the function name (e.g. type `? pi` in the REPL).\n\nSimilar to when you entered Julia's package manager (using `]`) you'll notice that the `?` command causes a change in the REPL with `help?> `replacing `julia>` as the prompt. This informs you that you've entered the help mode. As an exercise, use the help mode to find the difference between `print` and `println`.\n\n## Preamble to Objects like scalars, vectors and arrays\n\nBefore we start creating arrays and matrices, we'd like to demonstrate how you allocate numbers and strings to objects in Julia and check an object's type. We'd also like to highlight some simple mathematical operations.\n\n### Allocating data to objects\n\nAllocating in Julia is useful as it means that variables can be stored and used elsewhere. You allocate numbers to objects using the following:\n\nFirst note that we use the `=` in `Julia`, not the `<-` as in R.\n\n\n\n::: {#12 .cell execution_count=1}\n``` {.julia .cell-code}\n# allocate an Integer number to a variable\nn = 5\n```\n:::\n\n\n\n\n\nJulia, like other languages, has some built in values, like `pi`.  We can allocate these to variable names we will use. Notice that Julia converts pi into the unicode symbol!\n\n::: {.callout-tip collapse=\"true\"}\n## Capitalising on unicode\n\n`Julia` has built in unicode support that allows you to use mathematical symbols (and emojis!). This is vary useful when describing models and variables as you don't have to specify a 'wordy' variable but rather the actual mathematical symbol. Making for cleaner and more 'readable' code! \n\nTo 'access' different unicode symbols start by typing `\\` and the standard name of the symbol you wish to use\n\n:::  \n\n\n\n::: {#14 .cell execution_count=1}\n``` {.julia .cell-code}\n# allocate a pre-defined number of importance to a variable\n# note that pi is converted to π\n\npi_sum = pi\npi_sum\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nπ = 3.1415926535897...\n```\n:::\n:::\n\n\n\n\n\nWe can use these unicode symbols (and emojis!), as a variable and assign them a value - meaning that 🐺 is totally a usable variable name!\n\n\n\n::: {#16 .cell execution_count=1}\n``` {.julia .cell-code}\n🐺 = 4\n🐺\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n4\n```\n:::\n:::\n\n\n\n\n\nYou can also assign multiple values to separate variables in a concise manner.  Julia can manage something like this:\n\n\n\n\n::: {#18 .cell execution_count=1}\n``` {.julia .cell-code}\nαi, βi, γi = 1.3, 2.1, exp(39)\n\n# confirm...\nαi, βi, γi\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n(1.3, 2.1, 8.659340042399374e16)\n```\n:::\n:::\n\n\n\n\n\n#### Allocating strings\n\nOf course you can also allocate strings of text to objects.  You must use the `\"\"` and not `''` to define strings.\n\n\n\n::: {#20 .cell execution_count=1}\n``` {.julia .cell-code}\nsob = \"School of Biosciences\"\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n\"School of Biosciences\"\n```\n:::\n:::\n\n\n\n\n\nYou can combine strings and numbers to print like this. Note how you use $object.name within the text string you are writing... and this works for objects that are text or numeric.\n\n\n\n::: {#22 .cell execution_count=1}\n``` {.julia .cell-code}\nprintln(\"The favourite number in $sob is $n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nThe favourite number in School of Biosciences is 5\n```\n:::\n:::\n\n\n\n\n\n### Identifying the Type of object you've made\n\nJulia is very specific about types of objects.  Most programming languages are.  One way to learn about them is to look at what is made when you make things in different ways.\n\n\n\n::: {#24 .cell execution_count=1}\n``` {.julia .cell-code}\ntypeof(n), typeof(sob), typeof(pi)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n(Int64, String, Irrational{:π})\n```\n:::\n:::\n\n\n\n\n\nJulia is like R and Python in that it can infer the type of object (Integer, Float, etc) on the left hand side of the equals sign - you don't have to justify it like you do in C. However, you can declare the type if needed e.g.\n\n\n\n::: {#26 .cell execution_count=1}\n``` {.julia .cell-code}\npi_custom = Float64(3.141592)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n3.141592\n```\n:::\n:::\n\n\n\n\n\nFor those of you that are interested, a floating-point object (a Float) is a number that has a decimal place. An Int object is an integer, a number without a decimal place, whereas an Irrational object is a specific type of Float used only for representing some irrational numbers of special significance (e.g. π and γ). The 64 purely refers to 64-bit which is the type of processor your computer uses, most modern computers are 64-bit.\n\nOccasionally it will be valuable to convert an object from one type to another.  For example, `n` is currently an Integer (Int64), and we might want it to be Float (Float64).  To be clear, this is a distinction between `5` and `5.0`!\n\n\n\n::: {#28 .cell execution_count=1}\n``` {.julia .cell-code}\ntypeof(n)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nInt64\n```\n:::\n:::\n\n\n\n::: {#30 .cell execution_count=1}\n``` {.julia .cell-code}\nn2 = convert(Float64, n)\ntypeof(n2)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nFloat64\n```\n:::\n:::\n\n\n\n\n\n::: {.callout-tip collapse=\"true\"}\n## Multiple dispatch using types\n\nThe strict type system of Julia means that it is possible to define multiple 'methods' for functions depending on the type of the input object. Which allows you to have function behave different for different input types. [This](https://www.moll.dev/projects/effective-multi-dispatch/) blog post provides a nice overview of multiple dispatch using Pokemon types but the take-home message here is that it is important that you specify the correct type of an object and that often times when you run into an error it is because of that... This may seem annoying at first but it does mean that in the long run your code is much 'safer' because you won't (unknowingly) be converting and combining objects that are of different types unless you specifically specify it.\n\n:::  \n\n## Understanding Arrays, Vectors and Sequences.\n\nAs you saw above, we created a sequence of numbers using `collect(0:1:10)`. Let's look at what type of object this is:\n\n\n\n::: {#32 .cell execution_count=1}\n``` {.julia .cell-code}\ntypeof(x)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nVector{Int64} (alias for Array{Int64, 1})\n```\n:::\n:::\n\n\n\n\n\nThis is a vector.  Let's step back to see the difference between arrays and vectors.  Arrays, for the R users, are best thought of as `lists` - they are storage boxes for any type of variables and can contain collections of various types.  The general way to create an array, in this case and empty one, is the `[ ]`.\n\n\n\n::: {#34 .cell execution_count=1}\n``` {.julia .cell-code}\nempty_array = []\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nAny[]\n```\n:::\n:::\n\n\n\n\n\nWe will first create an array with the same values as `x` and then see how `collect` is the function that converts this to a vector, and actually lets us see the numbers too!\n\nFirst, `range` can be used to make an array. This is very similar to `seq()` in `R` and has the two variations - `by` and `length` that the `R` function has.  The difference is that `by` is replaced by the argument `step`. Note how a very concise summary of this array is presented using information in square brackets `[ ]`:\n\n\n\n::: {#36 .cell execution_count=1}\n``` {.julia .cell-code}\nx_array1 = range(start = 1, step = 1, stop = 10)\nx_array2 = range(start = 1, stop = 10, length = 5)\n\nx_array1, x_array2\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n(1:1:10, 1.0:2.25:10.0)\n```\n:::\n:::\n\n\n\n\n\nYou can also now see that creating arrays is possible with `[ ]` and the use of the `:` :\n\n\n\n::: {#38 .cell execution_count=1}\n``` {.julia .cell-code}\nx_array3 = [1:1:10]\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n1-element Vector{StepRange{Int64, Int64}}:\n 1:1:10\n```\n:::\n:::\n\n\n\n\n\nQuite often, you want to either see the values, or specifically be using a vector. To do this, you can use the function `collect()`:\n\n\n\n::: {#40 .cell execution_count=1}\n``` {.julia .cell-code}\ncollect(x_array1)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n10-element Vector{Int64}:\n  1\n  2\n  3\n  4\n  5\n  6\n  7\n  8\n  9\n 10\n```\n:::\n:::\n\n\n\n\n\n## Indices of Arrays.\n\nYou should recall from **R** that values in arrays and vectors and dataframes have _addresses_ that we call indices. Julia works with indexing very similarly.\n\nLet's make a simple array of 5 numbers and another simple array of five words. Note that the `[]` array function is a but like the `c()` function in **R**.\n\n\n\n::: {#42 .cell execution_count=1}\n``` {.julia .cell-code}\nar = [6,7,8,9,10]\nbr = [\"Pint\", \"of\", \"Moonshine\", \"please\"]\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n4-element Vector{String}:\n \"Pint\"\n \"of\"\n \"Moonshine\"\n \"please\"\n```\n:::\n:::\n\n\n\n\n\nYou can get any address in these using... square brackets!\n\n\n\n::: {#44 .cell execution_count=1}\n``` {.julia .cell-code}\nar[2] # gets the number 7!\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n7\n```\n:::\n:::\n\n\n\n::: {#46 .cell execution_count=1}\n``` {.julia .cell-code}\nbr[3] # gets the word Moonshine\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n\"Moonshine\"\n```\n:::\n:::\n\n\n\n\n\nIf you want two addresses in a sequence, you can just provide the sequence:\n\n\n\n::: {#48 .cell execution_count=1}\n``` {.julia .cell-code}\nar[2:3]\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n2-element Vector{Int64}:\n 7\n 8\n```\n:::\n:::\n\n\n\n\n\nBut if you want non-adjacent values, you need to provide the 'list of indices' as an array, which results in the use of `[[ ]]`.\n\n\n\n::: {#50 .cell execution_count=1}\n``` {.julia .cell-code}\nar[[2,4]]\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n2-element Vector{Int64}:\n 7\n 9\n```\n:::\n:::\n\n\n\n\n\nNote this would be like using in R `ar[c(2,4)]`.\n\n\nAnother nice indexing feature is that you can simply specify `end` as a means to index the final element. This is quite useful when you *e.g.,* want to pull the final output of a series without needing to know how long the series is.\n\n\n\n::: {#52 .cell execution_count=1}\n``` {.julia .cell-code}\nar[end]\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n10\n```\n:::\n:::\n\n\n\n\n\n## Broadcasting: something VERY special\n\nBroadcasting allows you to apply a function, like a `log()` or `exp()`, in an element-wise manner to an array (in other words apply the function to every element of an array).  \n\nWe saw above that we can create a vector using `collect()` and multiply this by a scalar\n\n\n\n::: {#54 .cell execution_count=1}\n``` {.julia .cell-code}\n# sequences in a vector\n# From 0, by 1, to 10...\n\nx = collect(0:1:10)\n\n# see it\nx\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n11-element Vector{Int64}:\n  0\n  1\n  2\n  3\n  4\n  5\n  6\n  7\n  8\n  9\n 10\n```\n:::\n:::\n\n\n\n::: {#56 .cell execution_count=1}\n``` {.julia .cell-code}\n# multply scaler x vector.\nx*10\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n11-element Vector{Int64}:\n   0\n  10\n  20\n  30\n  40\n  50\n  60\n  70\n  80\n  90\n 100\n```\n:::\n:::\n\n\n\n\n\nYou can work directly with arrays and pre-built functions to do things like this. To do-so, we combine the function with the (dot) `.` operator.  Let's work with `x_array1` from above.  Note how broadcasting the function across the array returns a vector.\n\n\n\n::: {#58 .cell execution_count=1}\n``` {.julia .cell-code}\n# Look at the help file for exp10\nexp_array1 = exp10.(x_array1)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n10-element Vector{Float64}:\n     10.0\n    100.0\n   1000.0\n  10000.0\n 100000.0\n      1.0e6\n      1.0e7\n      1.0e8\n      1.0e9\n      1.0e10\n```\n:::\n:::\n\n\n\n\n\nIf you try to do this without the (dot) `.` operator what happens?\n\n\n\n::: {#60 .cell execution_count=1}\n``` {.julia .cell-code}\n# look at the help file for log - what is the default!?\nlog_array1 = log.(x_array1)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n10-element Vector{Float64}:\n 0.0\n 0.6931471805599453\n 1.0986122886681098\n 1.3862943611198906\n 1.6094379124341003\n 1.791759469228055\n 1.9459101490553132\n 2.0794415416798357\n 2.1972245773362196\n 2.302585092994046\n```\n:::\n:::\n\n\n\n\n\nDid you check the help file for `log`?  Is it the same default as we find in **R**?\n\n## Matrices\n\nSometimes we'll be interested in a 2-dimensional or higher version of the array/vector, and this is a matrix.  Making a matrix in Julia uses the `[ ]` again, an separates rows of numbers with the `;`\n\n\n\n::: {#62 .cell execution_count=1}\n``` {.julia .cell-code}\nmat = [1 2 3; 4 5 6]\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n2×3 Matrix{Int64}:\n 1  2  3\n 4  5  6\n```\n:::\n:::\n\n\n\n\n\nNote how there are NO commas between the numbers in each row!  This is read as 'rows are separated by ; and columns by spaces'!\n\nYou can also 'pre-fill' a matrix with zeros.  This is good practice in loops and programming as pre-filling and replacing variables in a matrix is more efficient than creating the matrix on the fly.  Here we demonstrate how to pre-fil a vector, matrix and high dimension array!  Matrices can have more than two dimensions!\n\n\n\n::: {#64 .cell execution_count=1}\n``` {.julia .cell-code}\nvec0 = zeros(2) # 2 zeros allocated in a vector\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n2-element Vector{Float64}:\n 0.0\n 0.0\n```\n:::\n:::\n\n\n\n::: {#66 .cell execution_count=1}\n``` {.julia .cell-code}\nmat0 = zeros(2,3) # zeros allocated to 2 rows and 3 columns!\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n2×3 Matrix{Float64}:\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n```\n:::\n:::\n\n\n\n::: {#68 .cell execution_count=1}\n``` {.julia .cell-code}\narr0 = zeros(2,3,4) # 2 rows, 3 columns and 4 dimensions!\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n2×3×4 Array{Float64, 3}:\n[:, :, 1] =\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n\n[:, :, 2] =\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n\n[:, :, 3] =\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n\n[:, :, 4] =\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n```\n:::\n:::\n\n\n\n\n\nAccessing values in a matrix follows the same convention as with the vector.  The convention is `[row, column]`\n\n\n\n::: {#70 .cell execution_count=1}\n``` {.julia .cell-code}\nmat[1,2] # value in the first row and second column\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n2\n```\n:::\n:::\n\n\n\n::: {#72 .cell execution_count=1}\n``` {.julia .cell-code}\nmat[1:2, 3] # rows 1 AND 2 in the 3rd column\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n2-element Vector{Int64}:\n 3\n 6\n```\n:::\n:::\n\n\n\n\n\nFinally, to get a row or column, you need to know that we need a placeholder for the _missing_ bit of what you are asking for.  If we want the second row, we ask for row 2, and stick the `:` placeholder in the column spot:\n\n\n\n::: {#74 .cell execution_count=1}\n``` {.julia .cell-code}\nmat[2,:]\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n3-element Vector{Int64}:\n 4\n 5\n 6\n```\n:::\n:::\n\n\n\n\n\nFor a column, we reverse this.\n\n\n\n::: {#76 .cell execution_count=1}\n``` {.julia .cell-code}\nmat[:,2]\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n2-element Vector{Int64}:\n 2\n 5\n```\n:::\n:::\n\n\n\n\n\n### A quick interlude on types\n\nAs discussed earlier **Julia** is able to infer the type of an object based on the input. So the `mat` object we created earlier will be a matrix of integers i.e. `Matrix{Int64}`.\n\n\n\n::: {#78 .cell execution_count=1}\n``` {.julia .cell-code}\ntypeof(mat)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nMatrix{Int64} (alias for Array{Int64, 2})\n```\n:::\n:::\n\n\n\n\n\nSo what happens if we want to replace one of the elements with a Float?\n\n\n\n::: {#80 .cell execution_count=0}\n``` {.julia .cell-code}\nmat[1,2] = 1.5\n```\n:::\n\n\n\n\n\nThis is because we are trying to add a Float to an object that is of the type Integer. What happens if we convert `mat` to be a matrix of floats and then try again?\n\n\n\n::: {#82 .cell execution_count=1}\n``` {.julia .cell-code}\nmat = convert(Matrix{Float64}, mat)\nmat[1,2] = 1.5\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n1.5\n```\n:::\n:::\n\n\n\n\n\n## Dictionaries\n\nDictionaries are another way to collect information in **Julia**, these look-up tables allow you to organise information (the **key**) with corresponding data (**value**). When we create a dictionary we specify it as 'value' `=>` 'key'. Dictionaries are useful if you need to store a collection of parameters or outputs, especially because the values for each pair can be of a different type.\n\n\n\n::: {#84 .cell execution_count=1}\n``` {.julia .cell-code}\nparameters = Dict{Symbol,Any}(\n        :growth_rate => 0.4,\n        :response => :logistic,\n        :carry_capacity => 0.28,\n    )\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nDict{Symbol, Any} with 3 entries:\n  :growth_rate    => 0.4\n  :response       => :logistic\n  :carry_capacity => 0.28\n```\n:::\n:::\n\n\n\n\n\nWe can also add an 'entry' to our dictionary very easily (or change the value)\n\n\n\n::: {#86 .cell execution_count=1}\n``` {.julia .cell-code}\nparameters[:abundance] = collect(1:10)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n10-element Vector{Int64}:\n  1\n  2\n  3\n  4\n  5\n  6\n  7\n  8\n  9\n 10\n```\n:::\n:::\n\n\n\n\n\n### Looking things up\n\nTo get a value, if you have the key:\n\n\n\n::: {#88 .cell execution_count=1}\n``` {.julia .cell-code}\nparameters[:growth_rate]\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n0.4\n```\n:::\n:::\n\n\n\n\n\nYou can also get all values using `values()` (and the same for keys using `keys()`). Note that these functions are iterators and they have one job: to iterate through a dictionary value by value (or key by key) so if we want to turn these into an array we need to also call `collect()`\n\n\n\n::: {#90 .cell execution_count=1}\n``` {.julia .cell-code}\nparam_vals = collect(values(parameters))\n\nparam_keys = collect(keys(parameters))\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n4-element Vector{Symbol}:\n :growth_rate\n :response\n :carry_capacity\n :abundance\n```\n:::\n:::\n\n\n",
    "supporting": [
      "02_maths_vector_stuff_files"
    ],
    "filters": [],
    "includes": {}
  }
}