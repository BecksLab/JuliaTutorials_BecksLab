{
  "hash": "9c1f3c6a144a35d095bc1d6b40d6bdf7",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Tutorial 6: Extra Tips and Tricks\"\ndate: now\nauthor: \"Danet and Becks, based on originals by Delmas and Griffiths\"\nformat:\n    html:\n        embed-resources: true\ntitle-block-banner: true\n#jupyter: julia-1.8\n---\n\nSome quick tips that we've learnt the hard way...\n\n1. In the REPL, you can use the up arrow to scroll through past code\n2. You can even filter through your past code by typing the first letter of a line previously executed in the REPL. For example, try typing p in the REPL and using the up arrow to scroll through your code history, you should quickly find the last plot command you executed.\n3. Toggle word wrap via `View>Toggle Word Wrap` or `alt-Z`\n4. Red wavy line under code in your script = _error in code_\n5. Blue wavy line under code in your script = _possible error in code_\n6. Errors and possible erros can be viewed in the PROBLEMS section of the REPL\n7. You can view your current variables (similar to the top right hand panel in RStudio) by clickling on the Julia explorer: Julia workspace symbol in the activity bar (three circles). You can then look at them in more detail by clicking the sideways arrow (when allowed).\n\n### COPYING versus DEEP COPYING :-)\n\n8. Julia has a strange copying aspect where if a=b, any change in b will automatically cause the same change in a. For example, let's make an array of three numbers:\n\n::: {#0b16397e .cell execution_count=1}\n``` {.julia .cell-code}\naa = [1,2,3]\n```\n\n::: {.cell-output .cell-output-display execution_count=2}\n```\n3-element Vector{Int64}:\n 1\n 2\n 3\n```\n:::\n:::\n\n\nHere we make a copy of aa and call it bb.\n\n::: {#814c1793 .cell execution_count=2}\n``` {.julia .cell-code}\nbb = aa\nprint(bb)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1, 2, 3]\n```\n:::\n:::\n\n\nNow, we replace the second element of bb with the value 41.\n\n::: {#4c6a9c04 .cell execution_count=3}\n``` {.julia .cell-code}\nbb[2] = 41\nbb\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```\n3-element Vector{Int64}:\n  1\n 41\n  3\n```\n:::\n:::\n\n\nThe default behaviour of `=` in Julia is to *UPDATE* any copy of the array, also:\n\n::: {#c4f90bb8 .cell execution_count=4}\n``` {.julia .cell-code}\naa\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n```\n3-element Vector{Int64}:\n  1\n 41\n  3\n```\n:::\n:::\n\n\nWhoa... that's not what we expect, though it's pretty cool.  This approach is advantageous because it lets Julia save memory, however, it is not ideal.\n\nTo remedy this, and create copies that don't update their parent or other offspring, we can force c to be an independent copy of a using the `deepcopy` function:\n\n::: {#ce845a16 .cell execution_count=5}\n``` {.julia .cell-code}\ncc = deepcopy(aa)\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```\n3-element Vector{Int64}:\n  1\n 41\n  3\n```\n:::\n:::\n\n\n::: {#dc2b204b .cell execution_count=6}\n``` {.julia .cell-code}\ncc[3] = 101\naa,cc\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n```\n([1, 41, 3], [1, 41, 101])\n```\n:::\n:::\n\n\n9. You can view a `.csv` or `.txt` file by clicking on a file name in the project directory (left panel) - this opens a viewing window. CSV's also have a built in 'Preview' mode - try using right click>Open Preview on a `.csv` file and check it out.\n\n",
    "supporting": [
      "Tutorial-6_Extra Tips and Tricks_files"
    ],
    "filters": [],
    "includes": {}
  }
}