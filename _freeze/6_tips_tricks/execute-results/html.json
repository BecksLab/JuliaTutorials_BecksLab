{
  "hash": "a48114531637e0cef8a105d94591195b",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Tutorial 6: Extra Tips and Tricks\"\ndate: now\nauthor: \"Danet and Becks, based on originals by Delmas and Griffiths\"\nformat:\n    html:\n        embed-resources: true\ntitle-block-banner: true\n---\n\nSome quick tips that we've learnt the hard way...\n\n1. In the REPL, you can use the up arrow to scroll through past code\n2. You can even filter through your past code by typing the first letter of a line previously executed in the REPL. For example, try typing p in the REPL and using the up arrow to scroll through your code history, you should quickly find the last plot command you executed.\n3. Toggle word wrap via `View>Toggle Word Wrap` or `alt-Z`\n4. Red wavy line under code in your script = _error in code_\n5. Blue wavy line under code in your script = _possible error in code_\n6. Errors and possible errors can be viewed in the PROBLEMS section of the REPL\n7. You can view your current variables (similar to the top right hand panel in RStudio) by clicking on the Julia explorer: Julia workspace symbol in the activity bar (three circles). You can then look at them in more detail by clicking the sideways arrow (when allowed).\n\n### COPYING versus DEEP COPYING :-)\n\n8. Julia has a strange copying behaviour where if `a` = `b`, any change in `b` will automatically cause the same change in `a`. For example, let's make an array of three numbers:\n\n::: {#1f04882d .cell execution_count=1}\n``` {.julia .cell-code}\naa = [1,2,3]\n```\n\n::: {.cell-output .cell-output-display execution_count=2}\n```\n3-element Vector{Int64}:\n 1\n 2\n 3\n```\n:::\n:::\n\n\nHere we make a copy of `aa` and call it `bb`.\n\n::: {#9c608a80 .cell execution_count=2}\n``` {.julia .cell-code}\nbb = aa\nprint(bb)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1, 2, 3]\n```\n:::\n:::\n\n\nNow, we replace the second element of `bb` with the value 41.\n\n::: {#0de3aad8 .cell execution_count=3}\n``` {.julia .cell-code}\nbb[2] = 41\nbb\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```\n3-element Vector{Int64}:\n  1\n 41\n  3\n```\n:::\n:::\n\n\nThe default behaviour of `=` in Julia is to *UPDATE* any copy of the array, so we see the same change in `aa`:\n\n::: {#34e8a1e3 .cell execution_count=4}\n``` {.julia .cell-code}\naa\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n```\n3-element Vector{Int64}:\n  1\n 41\n  3\n```\n:::\n:::\n\n\nWhoa... that's not what we expect, though it's pretty cool.  This approach is advantageous because it lets Julia save memory, however, it is not ideal.\n\nTo remedy this, and create copies that don't update their parent or other offspring, we can force c to be an independent copy of a using the `deepcopy` function:\n\n::: {#1b81a4a4 .cell execution_count=5}\n``` {.julia .cell-code}\ncc = deepcopy(aa)\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```\n3-element Vector{Int64}:\n  1\n 41\n  3\n```\n:::\n:::\n\n\n::: {#b722318d .cell execution_count=6}\n``` {.julia .cell-code}\ncc[3] = 101\naa,cc\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n```\n([1, 41, 3], [1, 41, 101])\n```\n:::\n:::\n\n\n9. You can view a `.csv` or `.txt` file by clicking on a file name in the project directory (left panel) - this opens a viewing window. CSV's also have a built in 'Preview' mode - try using right click>Open Preview on a `.csv` file and check it out.\n\n10. Docstrings are a supplement to `#`-based comments for documenting your workflow. Basically, any string that appears just before an object will be interpreted as documenting it. When you use a docstring it is possible to call that description using help (`?` in the REPL) or hovering over the object in VSCode. This can be very useful when you start declaring variables or building your own functions.\n\n::: {#92573cf4 .cell execution_count=7}\n``` {.julia .cell-code}\n\"a wonderfully documented and described variable\"\nvar = 101\n```\n\n::: {.cell-output .cell-output-display execution_count=8}\n```\nvar\n```\n:::\n:::\n\n\nyou can (should) also do this with functions\n\n::: {#aa6a9341 .cell execution_count=8}\n``` {.julia .cell-code}\n\"\"\"\n    _rategradient(∂X, ∂Y)\n\nReturns the rate of change in units of the values stored in the grid, and the\nangle of the change in wind direction, *i.e.* an angle of 180 means that the\nvalue is increasing *from* the south. When both ∂X and ∂Y are equal to 0, the\nangle is assumed to be 0.\n\"\"\"\nfunction _rategradient(∂X::T, ∂Y::T) where {T <: Number}\n    if ∂X == ∂Y == 0.0\n        return (0.0, 0.0)\n    end\n    m = sqrt(∂X^2 + ∂Y^2)\n    Δ = ∂X >= 0.0 ? 0.0 : 180.0\n    θ = rad2deg(atan(∂X, ∂Y)) + Δ\n    θ = ∂X > 0.0 ? θ + 180.0 : θ\n    return (m, θ)\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=9}\n```\n_rategradient\n```\n:::\n:::\n\n\n",
    "supporting": [
      "6_tips_tricks_files"
    ],
    "filters": [],
    "includes": {}
  }
}