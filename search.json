[
  {
    "objectID": "09_experiments_end.html",
    "href": "09_experiments_end.html",
    "title": "Tutorial 9: Experiments with the END",
    "section": "",
    "text": "In the previous chapter, we learned how to make networks and run a simulation. We did this for a simple tri-trophic chain where we specified the network with a matrix of ones and zeros, and for a more complex network defined by the niche model where we specified species richness and connectance. We also learned how to visualise the simulations and to collect several metrics about the simulations, including detail on biomass, diversity and stability.\nIn this tutorial, we are going to learn how to do experiments. We’ll learn first how to generate multiple networks and collect information on how network structure impacts our metrics. Then we’ll learn how to manipulate parameters in the model, again collecting information on how variation in these parameters impacts our metrics.\nFor example, we might be interested in how species richness or connectance impacts biomass and stability. Or how the carrying capacity of the producers impacts biomass and stability of the community (e.g. bottom up processes). We’ll look at both of these.\n\nGetting Setup\nAs with our previous exercises, we need to have a few packages that allow making networks, simulating them and collecting the data\n\nusing DataFrames, Plots, Random, Distributions\nusing EcologicalNetworksDynamics\n\n\n\nYour (re)introduction to loops: making multiple networks example\nOne of the tricks to doing experiments is learning how to run a loop. Julia is super-fast with running loops. This is a bit different to R, which has a bad rep for loops. It’s not terrible. But Julia is built to do loops fast.\nWhat we will do here is build a simple loop that makes 3 networks, each with a different species richness, but the same connectance.\nNote here that we introduce the use of the argument tol_C. Because the niche model produces networks based on probability theory (it uses the beta-distribution), the connectance we ask for is not always the connectance we get. The tol_C argument ensure that connectance is within a tolerance range - in this case, having asked for C = 0.2 and a tol_C = 0.01 we will get 0.19 &lt; C &lt; 2.01. This is like embedding a while loop within the FoodWeb function! We note too that the function nichemodel can take a value of L instead of C, and there is an associated tol_L argument for this choice too.\n\nRandom.seed!(12325) # ensures your network and this one are the same\n\nS = [10,20,30] # define the number of species\nC = 0.2 # define the connectance (complexity) of the network\n\n# collection zone for the networks\nnets = []\n\n# construct the food webs\n# we loop over the 3 values of S\n# we use push!() to add the food webs to nets\n# always start with a for and end with an end.\nfor i in 1:3\n    push!(nets, Foodweb(:niche; S = S[i], C = C))\nend\n\nGreat. Let’s see if we got what we expected in nets.\n\nnets\n\n3-element Vector{Any}:\n blueprint for Foodweb with 22 trophic links\n blueprint for Foodweb with 81 trophic links\n blueprint for Foodweb with 182 trophic links\n\n\nMagnificent, we have three networs and that’s a win. We also see that they are each for a different and appropriate S. Win no. 2. We can actually now check to see what the connectances actually are. Again, we’ll use a loop, println and introduce you to the details of the FoodWeb object.\nFirst, let’s look at one of the networks.\n\nnets[1]\n\nblueprint for Foodweb with 22 trophic links:\n  A: 10×10 SparseArrays.SparseMatrixCSC{Bool, Int64} with 22 stored entries:\n ⋅  1  1  1  1  1  1  1  1  1\n ⋅  1  1  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅\n ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅\n ⋅  ⋅  ⋅  ⋅  1  1  1  1  ⋅  ⋅\n ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅\n ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  1  1\n ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  1  ⋅  ⋅\n ⋅  ⋅  ⋅  ⋅  ⋅  1  1  1  ⋅  ⋅\n ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  1\n ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅\n\n\nWe can see that the A element is the matrix and you can guess that the M is the body Masses. We also find tha there are 3 producers and 7 invertebrates and it is derived from the niche model\n\n\n\n\n\n\nTip\n\n\n\nA side note on the metabolic classes. The default parametrisation, and nearly all of the published work with the BEFW, uses invertebrates for all the non-producer species. It is possible to include others. But the data, currently, are not helpful (low volume) in supporting robust inference with these types of species.\n\n\nNow, recall that we can look specifically at the matrix by using nets[1].A which grabs the A part. We introduce here the function sum. As in R, sum() does what it says on the tin: for a vector, it addes up all the numbers and for a matrix, it does the same! In our case here, when sum() is applied to a matrix of ones and zeros, it counts all the 1’s…. thus is the estimate of the number of links in the community.\nFinally, we note (again?) that size applied to the network returns two numbers - the number of rows and the number of columns. For our networks, the matrix is square. So grabbing one of these (rows = [1]) and squaring it delivers our ‘potential number of links’ (e.g. \\(species^2\\)).\nWe can put that all together here to define connectance as \\(Con = links/S^2\\). Do be careful to watch where you put the various []’s. One of them is about the index (i.e. [i]) and the other is about the dimension ([1]) of the matrix.\n\nfor i in 1:3\n    println(sum(nets[i].A)/size(nets[i].A)[1]^2)\n    end\n\n0.22\n0.2025\n0.20222222222222222\n\n\n\nDifferent ways to run loops.\nThere is another way to make this set of networks. Here we use a while loop to create 3 networks with the same species richness and connectance. We might need to do this to generate replicates. This is a good exercise with the niche model as it reminds you that it is a probabilistic tool… you can get several networks with the same S and C, but the links will be in slightly different places.\nwhile loops work on conditions… for example, if we want three networks, we could ask that the loop keep working to make the networks until we have three. To do this, we need a monitoring variable that lets us assess where we are against our target.\nLets see how to do that.\n\n# how many replicates do we want?\nreps = 3\n\nbegin\n    # list to store networks\n    global networks = []\n    # monitoring variable l (the letter l)\n    global l = length(networks)\n\n    # while loop\n    while l &lt; reps # reps is 3 here...\n        # generate a network\n        A = Foodweb(:niche; S = 20, C = 0.15)\n        # add the network to the set\n        push!(networks, A)\n        # update the monitor\n        global l = length(networks)\n    end\nend\n\nThe term global means that the obects are made available in our global environment and should be there for us to see. If you look closely at the mini-matrices, you’ll see they are all different in micro-structure, despite having the same number of links and the same connectance.\n\n\n\n\n\n\nNote\n\n\n\nThe presentation of the matrix is very specific here… the rows correspond to the predators and the columns the resources. Obstensibly, the ranking is by body size, so small things are at the upper left. This view shows that big things tend to eat small and big things, while small things eat small. Historically, the reflection (pivot around the diagnol) has also been used, where the predators are the columns and the resources the rows. This lead to a ‘feature’ of real and theoretical networks aligning, call upper triangularity. In this latter presentation, most of the links would be in the upper triangle. In the current presentation, the links are in the lower triangle. So we can just call the feature triangularity. The niche model reproduces this triangularity.\n\n\n\nnetworks\n\n3-element Vector{Any}:\n blueprint for Foodweb with 55 trophic links\n blueprint for Foodweb with 63 trophic links\n blueprint for Foodweb with 62 trophic links\n\n\n\nnetworks[1].A\n\n20×20 SparseArrays.SparseMatrixCSC{Bool, Int64} with 55 stored entries:\n⎡⠉⠉⠉⣉⡡⠐⠒⠒⠒⠂⎤\n⎢⠀⠀⠀⠀⠀⠔⠒⠒⠒⠂⎥\n⎢⠀⠀⠀⠀⠨⠕⠒⠒⠒⠂⎥\n⎢⠀⠀⠀⠀⠀⠀⠐⠒⠿⡅⎥\n⎣⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⎦\n\n\n\nnetworks[2].A\n\n20×20 SparseArrays.SparseMatrixCSC{Bool, Int64} with 63 stored entries:\n⎡⠉⠩⠭⠉⠉⠁⠀⠀⠀⠒⎤\n⎢⠀⠀⠈⠒⣒⠒⠒⠶⠤⠀⎥\n⎢⠀⠀⠀⠀⠒⠀⠨⣭⣭⡤⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠤⠤⠉⎥\n⎣⠀⠀⠀⠀⠀⠀⠀⠀⠐⠛⎦\n\n\n\nnetworks[3].A\n\n20×20 SparseArrays.SparseMatrixCSC{Bool, Int64} with 62 stored entries:\n⎡⣀⣭⣭⣍⣉⣉⡉⠉⠁⠀⎤\n⎢⠀⠀⠀⠉⠉⠁⢠⠤⠤⠤⎥\n⎢⠀⠀⠀⠀⠀⠉⢰⣶⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠈⠉⡀⠀⎥\n⎣⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⎦\n\n\n\n\n\nLinking the networks to the Ecological Networks Dynamics\nFantastic. Now you are ready for the next steps. We want to run the EcologicalNetworksDynamics model on each of these networks. Furthermore, we want to collect the biomass and stability information for all three into a data frame. Let’s see how we do that.\n\nStep 1: Create the collecting data frame\nFirst, we create the holding pen for our information. We’ll construct a data frame to collect five pieces of information: the network id (1,2 or 3), species richness at the start (our initial S), species richness at the end, total biomass at the end and stability at the end.\n\noutputs = DataFrame(Network = [], Init_Rich = [], Fin_Rich = [], Tot_biomass = [], Shannon_dic = [])\n\n0×5 DataFrame\n\n\n\nRow\nNetwork\nInit_Rich\nFin_Rich\nTot_biomass\nShannon_dic\n\n\n\nAny\nAny\nAny\nAny\nAny\n\n\n\n\n\n\n\n\n\n\nStep 2: use the pre-defined networks\nWe can use our nets object from above now. Each of these networks has a different species richness.\n\nfor i in 1:3\n\n    # prep: define size of network\n    S = size(nets[i].A)[1]\n\n    # deliver some progress reporting\n    println(\"\\nThis is network: \", i, \"with species richness = \", S,\"\\n\")\n\n    # step A: define model paramters\n    params = default_model(nets[i])\n\n    # step B: define body mass\n    B0 =  rand(S)\n\n    # step C: set number of timestamps\n    t = 300\n\n    # step D: simulate\n    out = simulate(params, B0, t)\n\n    # steps D: calculate metrics\n    fin_rich = richness(out)\n    fin_biomass = total_biomass(out)\n    s_div = shannon_diversity(out)\n\n    # step E: add things to the data frame\n    # note the first arg is the data frame and then\n    # the values we want allocated to the five slots\n    # are in []\n    push!(outputs, [i, S, fin_rich, fin_biomass, s_div])\nend\n\n\nThis is network: 1with species richness = 10\n\n\nThis is network: 2with species richness = 20\n\n\nThis is network: 3with species richness = 30\n\n\n\nAmazing. Let’s see if what we wanted collected has ended up in our data frame. Wonderful! Splendiferous. Fantabulous.\n\nprintln(outputs)\n\n3×5 DataFrame\n Row │ Network  Init_Rich  Fin_Rich                           Tot_biomass      ⋯\n     │ Any      Any        Any                                Any              ⋯\n─────┼──────────────────────────────────────────────────────────────────────────\n   1 │ 1        10         [10, 10, 10, 10, 10, 10, 10, 10,…  [4.70537, 4.6319 ⋯\n   2 │ 2        20         [20, 20, 20, 20, 20, 20, 20, 20,…  [8.52201, 8.4081\n   3 │ 3        30         [30, 30, 30, 30, 30, 30, 30, 30,…  [14.7649, 14.508\n                                                               2 columns omitted\n\n\n\n\nDissecting more from simulate\nNote the details on extinctions that comes from a model run. For example, let’s revisit our sim_niche object (you won’t necessarily have to re-run this if you are working in one big script)\n\nS = 20; # define the number of species\nC = 0.2; # define the connectance (complexity) of the network\n\n# construct the food web\nRandom.seed!(12325) # ensures your network and this one are the same\nfoodweb_niche = Foodweb(:niche; S = S, C = C)\n\n# construct the equations and fixed parameters\nparams_niche = default_model(foodweb_niche)\n\n# define bodymasses between 0 and 1 and get S = 20 of them.\nRandom.seed!(123)\nB0 = rand(S)\n\n# simulate using params and bodymasses\n# specify number of time steps\nt = 300\nsim_niche = simulate(params_niche, B0, t)\n\nretcode: Success\nInterpolation: 3rd order Hermite\nt: 51-element Vector{Float64}:\n   0.0\n   0.0983252574499891\n   0.28544083243480267\n   0.5267982237043161\n   0.8245753364604138\n   1.181896742988936\n   1.6418353914084878\n   2.203829100924959\n   2.893464061893281\n   3.729699102007749\n   ⋮\n 166.67876410920994\n 179.5612866567586\n 193.9800038364207\n 210.21105297520486\n 227.83156289127072\n 247.0838336915681\n 267.94281052881126\n 290.8959793077713\n 300.0\nu: 51-element Vector{Vector{Float64}}:\n [0.906299638797481, 0.44349373245960455, 0.7456733811393941, 0.5120830400366143, 0.2538490889415096, 0.33415153638191886, 0.4273278808735992, 0.867547200255958, 0.09913361484360417, 0.12528740769155033, 0.6922086620547391, 0.13655147513745736, 0.03209667335274724, 0.3505458214588266, 0.9303323763821093, 0.9594335994071538, 0.5819123423876457, 0.3114475007050529, 0.12114752051812694, 0.20452981732035946]\n [0.9169483131714715, 0.444402194534041, 0.7667640455857161, 0.5179071161683636, 0.25596644376248334, 0.3439614083570855, 0.42881389580038637, 0.8404857181508336, 0.10207349613818459, 0.12980979255930417, 0.7045585608788062, 0.14142469702894178, 0.033700254458592344, 0.35322775442579823, 0.9254383246584946, 0.8428424981719224, 0.5353929049386887, 0.2716712297929136, 0.11790964375471776, 0.20588623005171253]\n [0.9372189186622565, 0.446138581295766, 0.8030805319662981, 0.5280429096670912, 0.25960285298532004, 0.36088969827160805, 0.43143000229873113, 0.7941678141517742, 0.107334065965393, 0.13803877097876832, 0.7224846396419364, 0.150274714852675, 0.03655779055568964, 0.35202356186576755, 0.8867871855452475, 0.6561325211685619, 0.45370991951901846, 0.21879863147029777, 0.1144327890249893, 0.21137607850479412]\n [0.963419944890434, 0.4478457678502066, 0.8407656301021255, 0.5394619505769526, 0.26358620538619504, 0.3785307293750754, 0.43443524658702654, 0.7426580903726461, 0.11338938338304744, 0.1475698891121404, 0.7345099631141349, 0.16048747662896795, 0.03959434344670769, 0.3379755377009729, 0.7958692645000881, 0.48283669535781387, 0.36706195693003885, 0.17548000193294144, 0.1136592394878268, 0.22309854306314952]\n [0.995616193064571, 0.44805738727466143, 0.8700643195894429, 0.5512240918443782, 0.2674989824178032, 0.3924051349926597, 0.4375425793363201, 0.6886449125246876, 0.11960335804730916, 0.15695502649258633, 0.7327878032629778, 0.17047486846995694, 0.0420936774665965, 0.3062032871443506, 0.6610340292426684, 0.34855000462048347, 0.2881369319293169, 0.14175624955652485, 0.11666389844136492, 0.24243967254676815]\n [1.0331366869886944, 0.44448629343725343, 0.8788288901686566, 0.5620901047900512, 0.2708572048035862, 0.39695429480179645, 0.44018298027640984, 0.6333401253753693, 0.1252037789780579, 0.1640984843116221, 0.7114983769875807, 0.17795514254857084, 0.04354809380952039, 0.26092610308891634, 0.5154058541922188, 0.25624511921879434, 0.22330145420147088, 0.11586948470233616, 0.12436895504970236, 0.26962910331924905]\n [1.0773089982155897, 0.43396923698721435, 0.8556572961992899, 0.5707904139404543, 0.2731983214483226, 0.38705755776238965, 0.4413794083264426, 0.57197930814629, 0.12978003467017415, 0.16724868374246712, 0.6675169557355778, 0.18101017312972054, 0.04388752925907648, 0.20909394578211202, 0.3805309865842198, 0.19230727005942244, 0.16943175281775166, 0.09443672996682428, 0.13906102138589269, 0.30741066949967055]\n [1.1213743703927337, 0.4149870885160012, 0.7975741540831984, 0.5733620864984142, 0.2733077885606147, 0.36141676843558873, 0.4391552288251882, 0.5071960218562799, 0.13225598133704913, 0.1649144766546638, 0.6093837906327526, 0.17807037605762552, 0.04315159765633695, 0.1631734536430942, 0.2790930366914647, 0.15237925689592774, 0.12890880773111002, 0.0777317468581009, 0.16225155189984958, 0.35425475261372863]\n [1.1573410183305781, 0.3875799067335869, 0.7122633234623346, 0.5656661531044221, 0.2699342224158771, 0.32362037390928877, 0.43151833519945715, 0.43980122366299085, 0.1320832740044849, 0.15754833392958092, 0.5485937790090555, 0.16967851768901068, 0.04155688582593655, 0.12670961646818607, 0.20790093579654878, 0.12919220653556573, 0.09920527144448085, 0.06511083602693121, 0.1957265685332169, 0.40863184877785175]\n [1.1744909386178761, 0.35353525150930704, 0.6130415990319116, 0.5442924204781258, 0.2619765432579562, 0.2797239154423789, 0.41725964546931765, 0.3734718885747243, 0.12906194711831975, 0.14648620822639452, 0.49617455885534983, 0.15734180901650238, 0.039351964038387546, 0.0993990767009241, 0.15977668195469585, 0.1193453433823383, 0.07853078787521317, 0.05684848395648957, 0.23880211323157663, 0.46473430625333423]\n ⋮\n [6.0796918581521705e-5, 0.00013150891522234224, 5.122984902540371e-5, 5.055926352857151e-6, 0.0011197509119841174, 2.72109224811782e-5, 0.004805123705502722, 0.23714938621163634, 0.020346986070423154, 2.4630532478621647e-5, 0.4450777658015223, 2.5911085615199446e-5, 0.19582059388974904, 0.10090484291038816, 0.041751108986210705, 0.21605866945924587, 0.009748297718852397, 0.11095477485031849, 0.30896576290589634, 0.4836187314820017]\n [2.9540113222151e-5, 8.00347447969903e-5, 2.6268553079711177e-5, 2.3358462951417747e-6, 0.0008502538978680421, 1.3952641028716671e-5, 0.003612589598646932, 0.23963412412987403, 0.01792469665365543, 1.2629101515044369e-5, 0.4453417610336027, 1.3285671319409156e-5, 0.19486664345425517, 0.10209874101896887, 0.041891604062320766, 0.21602379754402518, 0.009562083807607504, 0.11101835580257087, 0.30897071352241884, 0.4835914564059694]\n [1.316661642751681e-5, 4.609615826134825e-5, 1.2418593996049657e-5, 9.87501335764045e-7, 0.0006289434801502857, 6.59618354592074e-6, 0.002629372386546568, 0.2419049154522667, 0.015626334170663347, 5.970359692603688e-6, 0.4456057549872397, 6.280744324667517e-6, 0.1940092465353524, 0.10314206416967744, 0.0420485758853443, 0.21600078661726943, 0.009371522869375187, 0.11107366457274223, 0.3089769794043164, 0.48355133078828855]\n [5.288582093785549e-6, 2.4853056623499225e-5, 5.324319645605664e-6, 3.7495755124149537e-7, 0.00045102371927351975, 2.8280327624781335e-6, 0.0018418173438047429, 0.2439592430702398, 0.013458321791611608, 2.5596925779574415e-6, 0.4458725663247356, 2.692763414905926e-6, 0.19326957086921884, 0.10403490013930573, 0.042221577622635696, 0.21597907364641333, 0.009176377022193363, 0.11112583015352114, 0.3089834736189299, 0.4835073952356987]\n [1.960571334007521e-6, 1.2748386630111396e-5, 2.1159119561950705e-6, 1.3122771778576438e-7, 0.0003164923062583726, 1.1238747466113514e-6, 0.0012535673852470278, 0.24574331054112852, 0.011504652249723045, 1.017230170364437e-6, 0.4461273330206475, 1.0701126911794138e-6, 0.19267165202202277, 0.10475075390986296, 0.0424010070435812, 0.21595925499505683, 0.00898446860287164, 0.11117426849257206, 0.3089897837893917, 0.48346305093156516]\n [6.595296475494325e-7, 6.1574954853343675e-6, 7.67357373566243e-7, 4.1573174270631394e-8, 0.00021630952401954456, 4.075848117129789e-7, 0.0008246351715284488, 0.24730063052934673, 0.00974480715081397, 3.6890828572072965e-7, 0.4463589658988681, 3.880865976514459e-7, 0.19219749029311017, 0.10531819548617594, 0.04258477175808697, 0.21594251593609987, 0.008795235529896587, 0.11122083597719083, 0.30899624003374065, 0.48342085433959275]\n [2.0108052810536977e-7, 2.8004575219407987e-6, 2.5369560293938255e-7, 1.1906566312871398e-8, 0.00014408987057477836, 1.3475139250269254e-7, 0.0005246117248176988, 0.2486425196015011, 0.008183727277331717, 1.2196446539134927e-7, 0.446562570567622, 1.2830498581876193e-7, 0.19183327165072156, 0.10575941597680824, 0.04276848561653339, 0.2159276885416831, 0.008611086962688601, 0.11126649455155886, 0.30900276016551753, 0.4833835692537177]\n [5.358504987922635e-8, 1.1745932017073953e-6, 7.398752912487071e-8, 2.9651920612526094e-9, 9.266705935784892e-5, 3.9298759867059995e-8, 0.00031929137827159507, 0.2498113303049815, 0.006788855740345596, 3.556958190356424e-8, 0.4467437607789965, 3.741872366693396e-8, 0.1915528586838708, 0.10610455981304934, 0.04295191471615347, 0.21591384077476136, 0.008430160333178009, 0.11131227568908975, 0.30900934087544246, 0.4833508222341021]\n [3.282185490440947e-8, 8.406671643632279e-7, 4.664050899791412e-8, 1.7793663607443082e-9, 7.799523091115677e-5, 2.4773285239966867e-8, 0.00026279733144282983, 0.25020397488876517, 0.0063127663624026826, 2.2422472598567405e-8, 0.446805543604753, 2.3588140754728694e-8, 0.19146688286682312, 0.10621159455439007, 0.04301932407943414, 0.21590899888518364, 0.008364030293671913, 0.11132929056688841, 0.3090117977251234, 0.48333975047389044]\n\n\nWe’ve constructed a helper function to get information on which species go extinct and when they do.\n\n\n\n\n\n\nWarning\n\n\n\nSection is no longer a built-in functionality in END. Alain should be able to address\n\n\n\n# collect and organise extinctions\nextinctions = get_extinct_species(sim_niche)\n\nThis is a Dict object. The numbers on the left of the =&gt; are known as the keys and the numbers on the right are values. We can create a mini- data frame out of this with the following code. key and values are actually extractor functions and collect is translating the extracted information into a vector.\n\n# create a data frame of extinctions\nee1 = DataFrame(who = collect(keys(extinctions)), when = collect(values(extinctions)))\n\nNow we can try and add this information to the plot. For the time being, we’ll focus on adding the times that each of these species goes extinct to our figure. To do this we need to access the extinction time column (when), add a bit of noise/jitter so that times that are really close together can be seen on our x-axis, and then plot these as points with coordinates x = when and y = 0.\n\n# add some jitter for close together events\nexts = ee1[:,2] .+rand.()\n\n# plot\nplot(sim_niche)\n# add jittered extinction events.\nplot!(exts, zeros(size(ee1[:,1])), seriestype = :scatter, legend = false)\n\nPretty cool!\n\n\n\nWhat’s next\nIn the next chapter, you’ll be creating larger experiments with loops over actual parameters in the model, including the predator-prey size ratio, values of carry capacity and the predator-prey size ratio.",
    "crumbs": [
      "Intro to the BEFW model",
      "Tutorial 9: Experiments with the END"
    ]
  },
  {
    "objectID": "08_intro_end.html",
    "href": "08_intro_end.html",
    "title": "Tutorial 8: Introducing Ecological Networks Dynamics (END)",
    "section": "",
    "text": "It is very worth pausing for a moment and looking at Delmas et al. (2017). It describes the BioEnergetic Food Web Model, provides some history of the model, and also showcases how the original Julia version of the model worked. This section of the tutorials is designed to introduce a newer, faster and more flexible version of the Julia package.\nA very basic interpretation of the model is as follows:\n\nThe model is a model of biomass dynamics, not numbers of individuals.\nThe model is comprised of an equation for plants (producers) an equation for consumers (herbivores, predators).\nPlants have traits that make their biomass grow and sets their carrying capacity; they are eaten by consumers via an equation describing a functional response. To link to ecology courses you have, this can be logistic growth for the plant and a type II functional response.\nConsumer have three sets of traits. One is metabolism, which is a rate that describes losses of biomass due to, well, metabolism! The second set of traits correspond to the functional response - for example describing attack rates and handling times of prey items. The third corresponds to the numerical response, or the conversion of biomass they eat into new biomass (e.g. babies)\nWe can make complex networks and systems of these equations by letting many of these parameters scale with body size via the rules of allometry and the Metabolic Theory of Ecology. This trick expands the two equations to n = number of species when we provide the toolbox with a list of species biomasses.\nEmbedded in this process are rules about how to distribute species of different sizes across trophic levels, so that we end up with predators, omnivores, herbivores and plants. We can also designate the body size relationships for different groups of organisms, like producers, invertebrates, endothermic vertebrates and ectothermic vertebrates.\nOnce we’ve done this, we can simulate the biomass dynamics of complex communities. And we can summarise things like changes in biodiversity (number of species), stability (coefficient of variation of the time series) and anything about the biomass of species, trophic levels or the community!\n\n\n\n\nOne of main advantages of running food web models in Julia is that simulations are fast and can be readily stored in your active project. With this in mind, make a new folder in your project called out_objects (right click &gt; New Folder).\nWe will be using the EcologicalNetworksDynamics.jl package (Lajaaiti et al. 2024) to implement the BEFW. Although we will go through and explain the functionality it may be useful to have both the preprint as well as the complete documentation on hand for more detailed explanations. You can install EcologicalNetworksDynamics as you would any other normal Julia package.\n\nPkg.add EcologicalNetworksDynamics\n\n\n\n\nThere are four major steps when running the BioEnergetic Food Web model in Julia. These should be familiar from our introduction to the DifferentialEquations package:\n\nGenerate an initial food web network\nSet the parameters for each species in the network to generate the equations\nSimulate the network and equations\nExplore output and plot\n\nWhile in the previous example with Differential Equations we assumed a simple 2-species network, one of the new activities here is to take advantage of a rich history of theory and tools to construct species rich networks with appropriate structural properties, such as connectance/complexity and levels of generalism/specialism and things the number of trophic levels and a body size distribution of the species across trophic levels.\n\n\n\n## My first BEFW Modelling\n\n## Packages I need\nusing DataFrames, Plots, Random, Distributions\nusing EcologicalNetworksDynamics\n\n## Time to do some Experiments!\n\nHere we make a foodweb, actually, a food chain, from an adjacency matrix using Foodweb.\n\nA = [0 0 0; 1 0 0; 0 1 0] # 1 basal producer ⋅ Species 2 eats 1 ⋅ Species 3 eats 2\nfoodweb = Foodweb(A)\n\n\n\n\nOnce the foodweb is created, the next step is to attribute values to the model parameters. This can be simply done by calling default_model with foodweb as an argument.\n\n# construct the equations and fixed parameters\n# see below for body size dependent parameters etc\nparams = default_model(foodweb)\n\nIf we look at our params object we can see that it has all the required parameters for the BEFW. Later in this tutorial you will see how we can access and modify these parameters.\n\n\n\nEverything is ready to run the simulation, which can be simply done by calling simulate with the model parameters (params) and a vector species’ initial biomass (B0).\n\n# create body sizes for each species\nB0 = [0.5, 0.5, 0.5]\n# specify number of time steps\nt = 300\n\n# use simulate function\n# builds equations and uses DiffEq to run them!\nsim = simulate(params, B0, t)\n\n\n\n\nTo plot the time series, we can use the actual simulate object directly.\n\n plot(sim, label = [\"Producer\" \"Consumer\" \"Top consumer\";])\n\nEventually you may want to plot the biomass dynamics - the trajectory - of your community to see what is happening. For our minimal example, it can be done as follows:\n\n\n# create multiple objects: time = t pulled from the sim.t component\n# and Bx = biomass for each species pulled from the larger sim object\n# note how julia allows multiple things on left of the =\nt, B1, B2, B3 = sim.t, sim[1,:], sim[2,:], sim[3,:] # unpack variables\n\n# Plot the basal species\nplot(t, B1, lw = 3, label=\"Producer\", xlabel = \"Time\", ylabel = \"Biomass\")\n# add the herbivore\nplot!(t, B2, lw = 3, label=\"Consumer\")\n# add the top predator\nplot!(t, B3, lw = 3, label=\"Top consumer\")",
    "crumbs": [
      "Intro to the BEFW model",
      "Tutorial 8: Introducing Ecological Networks Dynamics (END)"
    ]
  },
  {
    "objectID": "08_intro_end.html#using-the-bioenergetic-food-web",
    "href": "08_intro_end.html#using-the-bioenergetic-food-web",
    "title": "Tutorial 8: Introducing Ecological Networks Dynamics (END)",
    "section": "",
    "text": "It is very worth pausing for a moment and looking at Delmas et al. (2017). It describes the BioEnergetic Food Web Model, provides some history of the model, and also showcases how the original Julia version of the model worked. This section of the tutorials is designed to introduce a newer, faster and more flexible version of the Julia package.\nA very basic interpretation of the model is as follows:\n\nThe model is a model of biomass dynamics, not numbers of individuals.\nThe model is comprised of an equation for plants (producers) an equation for consumers (herbivores, predators).\nPlants have traits that make their biomass grow and sets their carrying capacity; they are eaten by consumers via an equation describing a functional response. To link to ecology courses you have, this can be logistic growth for the plant and a type II functional response.\nConsumer have three sets of traits. One is metabolism, which is a rate that describes losses of biomass due to, well, metabolism! The second set of traits correspond to the functional response - for example describing attack rates and handling times of prey items. The third corresponds to the numerical response, or the conversion of biomass they eat into new biomass (e.g. babies)\nWe can make complex networks and systems of these equations by letting many of these parameters scale with body size via the rules of allometry and the Metabolic Theory of Ecology. This trick expands the two equations to n = number of species when we provide the toolbox with a list of species biomasses.\nEmbedded in this process are rules about how to distribute species of different sizes across trophic levels, so that we end up with predators, omnivores, herbivores and plants. We can also designate the body size relationships for different groups of organisms, like producers, invertebrates, endothermic vertebrates and ectothermic vertebrates.\nOnce we’ve done this, we can simulate the biomass dynamics of complex communities. And we can summarise things like changes in biodiversity (number of species), stability (coefficient of variation of the time series) and anything about the biomass of species, trophic levels or the community!\n\n\n\n\nOne of main advantages of running food web models in Julia is that simulations are fast and can be readily stored in your active project. With this in mind, make a new folder in your project called out_objects (right click &gt; New Folder).\nWe will be using the EcologicalNetworksDynamics.jl package (Lajaaiti et al. 2024) to implement the BEFW. Although we will go through and explain the functionality it may be useful to have both the preprint as well as the complete documentation on hand for more detailed explanations. You can install EcologicalNetworksDynamics as you would any other normal Julia package.\n\nPkg.add EcologicalNetworksDynamics\n\n\n\n\nThere are four major steps when running the BioEnergetic Food Web model in Julia. These should be familiar from our introduction to the DifferentialEquations package:\n\nGenerate an initial food web network\nSet the parameters for each species in the network to generate the equations\nSimulate the network and equations\nExplore output and plot\n\nWhile in the previous example with Differential Equations we assumed a simple 2-species network, one of the new activities here is to take advantage of a rich history of theory and tools to construct species rich networks with appropriate structural properties, such as connectance/complexity and levels of generalism/specialism and things the number of trophic levels and a body size distribution of the species across trophic levels.\n\n\n\n## My first BEFW Modelling\n\n## Packages I need\nusing DataFrames, Plots, Random, Distributions\nusing EcologicalNetworksDynamics\n\n## Time to do some Experiments!\n\nHere we make a foodweb, actually, a food chain, from an adjacency matrix using Foodweb.\n\nA = [0 0 0; 1 0 0; 0 1 0] # 1 basal producer ⋅ Species 2 eats 1 ⋅ Species 3 eats 2\nfoodweb = Foodweb(A)\n\n\n\n\nOnce the foodweb is created, the next step is to attribute values to the model parameters. This can be simply done by calling default_model with foodweb as an argument.\n\n# construct the equations and fixed parameters\n# see below for body size dependent parameters etc\nparams = default_model(foodweb)\n\nIf we look at our params object we can see that it has all the required parameters for the BEFW. Later in this tutorial you will see how we can access and modify these parameters.\n\n\n\nEverything is ready to run the simulation, which can be simply done by calling simulate with the model parameters (params) and a vector species’ initial biomass (B0).\n\n# create body sizes for each species\nB0 = [0.5, 0.5, 0.5]\n# specify number of time steps\nt = 300\n\n# use simulate function\n# builds equations and uses DiffEq to run them!\nsim = simulate(params, B0, t)\n\n\n\n\nTo plot the time series, we can use the actual simulate object directly.\n\n plot(sim, label = [\"Producer\" \"Consumer\" \"Top consumer\";])\n\nEventually you may want to plot the biomass dynamics - the trajectory - of your community to see what is happening. For our minimal example, it can be done as follows:\n\n\n# create multiple objects: time = t pulled from the sim.t component\n# and Bx = biomass for each species pulled from the larger sim object\n# note how julia allows multiple things on left of the =\nt, B1, B2, B3 = sim.t, sim[1,:], sim[2,:], sim[3,:] # unpack variables\n\n# Plot the basal species\nplot(t, B1, lw = 3, label=\"Producer\", xlabel = \"Time\", ylabel = \"Biomass\")\n# add the herbivore\nplot!(t, B2, lw = 3, label=\"Consumer\")\n# add the top predator\nplot!(t, B3, lw = 3, label=\"Top consumer\")",
    "crumbs": [
      "Intro to the BEFW model",
      "Tutorial 8: Introducing Ecological Networks Dynamics (END)"
    ]
  },
  {
    "objectID": "08_intro_end.html#a-more-complex-example",
    "href": "08_intro_end.html#a-more-complex-example",
    "title": "Tutorial 8: Introducing Ecological Networks Dynamics (END)",
    "section": "A More Complex Example",
    "text": "A More Complex Example\n\nStep 1: Generate the initial network\nIn order to run the BEFW model with a more complex network, we have to construct an initial food web network (an adjacency matrix) using the niche model (Williams and Martinez 2000). The network is characterised by the number of species in the network and its connectance/complexity value.\nNote that we are now using functionality provided by the EcologicalNetworks package.\n\nS = 20 # define the number of species\nC = 0.2 # define the connectance (complexity) of the network\n\n# construct the food web\nRandom.seed!(12325) # ensures your network and this one are the same\nfoodweb_niche = Foodweb(:niche; S = S, C = C)\n\n\n\nStep 2. Setting up the parameters, body masses (species) and running the model!\nAs above, our next step is to define a vector of bodymasses and then pass this, and the network to the simulate function. Here we combine the Uniform function from the Distributions package with the rand function from the Random package.\n\n# construct the equations and fixed parameters\n# see below for body size dependent parameters etc\nparams_niche = default_model(foodweb_niche)\n\n# define bodymasses between 0 and 1 and get S = 20 of them.\n# this will ensure your plot looks like the one in the document\nRandom.seed!(123)\nB0 = rand(S)\nt = 300\n\n# simulate using params and bodymasses\n# note additional argument tmax for max time steps\n# default is 300\nsim_niche = simulate(params_niche, B0, t)\n\n\n\nStep 3. Visualising the dynamics\nNow we can move to plotting again. Note how we now ask for the time directly from the simulate object and all of the biomasses from that object as well.\nNote too how we can suppress the legend (which covers some of the time series).\n\nplot(sim_niche, legend = false)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nOne game to play now is to alter the bodymass distribution. rand selects a random uniform number between 0 and 1. Can you figure out how to make the distribution uniform between 0 and 10? See what that does.\n\n\nA bit more about the process: dissecting the ModelParameters\nLet’s dissect the default_model object a bit, to understand just a bit more about what is going on.\n\nparams_niche\n\n\nModel (alias for EcologicalNetworksDynamics.Framework.System{&lt;inner parms&gt;}) with 17 components:\n  - Species: 20 (:s1, :s2, :s3, :s4, ..., :s20)\n  - Foodweb: 82 links\n  - Body masses: [396.6757314506745, 1000.0, 138.23722273578997, 150.62580571223663, ..., 1.0]\n  - Metabolic classes: [:invertebrate, :invertebrate, :invertebrate, :invertebrate, ..., :producer]\n  - GrowthRate: [·, ·, ·, ·, ..., 1.0]\n  - Carrying capacity: [·, ·, ·, ·, ..., 1.0]\n  - ProducersCompetition: 1.0\n  - EcologicalNetworksDynamics.LogisticGrowth\n  - Efficiency: 0.45 to 0.85.\n  - MaximumConsumption: [8.0, 8.0, 8.0, 8.0, ..., ·]\n  - Hill exponent: 2.0\n  - Consumers preferences: 0.07692307692307693 to 1.0.\n  - Intra-specific interference: [·, ·, ·, ·, ..., ·]\n  - Half-saturation density: [0.5, 0.5, 0.5, 0.5, ..., ·]\n  - EcologicalNetworksDynamics.BioenergeticResponse\n  - Metabolism: [0.0703591752903408, 0.05583797347522218, 0.09157425582526797, 0.08963029015067063, ..., 0.0]\n  - Mortality: [0.0, 0.0, 0.0, 0.0, ..., 0.0]\n\n\n\nWalking through this\n\n\n\n\n\n\nWarning\n\n\n\nThis section still reflects the old version of END structure and naming conventions\n\n\n\nThe network component defines the food web and reports the number of species and the links\nthe environment component reports on values of the carrying capacity (K) and the baseline temperature (T). Note that K is specified only for the basal species via [1, 1, ... nothing, nothing]. All the producers have the same K at this point (1,1,1…). The presence of the T suggests that we can ultimately work with climate change by running the model at different temperatures. There is a way to make some of the biorates and components of the functional response (see 3, 4) dependent not only on body mass, but also on temperature.\nthe biorates component contains detail on parameters central to making the model reflect a bit of reality: d is …; r is the intrinsic rate of increase (population growth rate) for the producers (plants); x and y are parameters associated with metabolic rates and consumption rates of the consumers (non-plant species). Finally, e is an efficiency/assimilation rate for the consumers eating either plants or other animals.\nthe functional_response component defines the type of consumption function being used (e.g. Type I, II, or III sensu classic ecology and Holling). The functional response defines the interaction strength between species and how consumers change how much they eat dependent on the amount (density) of resource available.There are two options. The default Bioenergetic Response corresponds to a phenomenological formulation where there are just two variables that describe how consumer consumption varies with resource density: a half-saturation parameter and an asymptote. The alternative called Classic Response is more trait based and includes the parameters attack rate and handling time. There are several other features of the functional response that can be manipulated, and these are introduced in later tutorials.\nthe producer_growth details the default that all plants are growing logistically.\nthe temperature responsecomponewnt defines the absence or presence of temperature dependence, and when present, the shape of the relationship between biorates and functional response parameters and temperature.\n\n\n\nHelper Functions: What can we do with the outputs?\n\n\n\n\n\n\nWarning\n\n\n\nThis section should be reviewed and revised by an END user who knows what we want to do with outputs.\n\n\nAs noted in the pre-amble, we are most often interested in additional information about the scenarios we build with the models. These include, for example, total biomass, biodiversity and stability. Let’s see how we can calculate some of these.\n\nHow long till steady state?\nWe can find out how long the simulations ran to reach steady state - remember that this is a deterministic model that typically reaches equilibrium for all species that survive.\n\nsize(sim_niche.t)\n\n(51,)\n\n\n\n\nWho went extinct and when?\n\n\n\n\n\n\nWarning\n\n\n\nNot a functionality in END.\n\n\nWe can also find out who went extinct, and when. You saw some of that detail, I hope, in the output of simulate.\n\nget_extinct_species(sim_niche)\n\n\n\nBiomass, Diversity and Stability\nFirst, we can get a measure of total biomass in the community, at equilibrium, and that of each species. Note how you can get the components too.\n\nsim_niche.u\n\n51-element Vector{Vector{Float64}}:\n [0.906299638797481, 0.44349373245960455, 0.7456733811393941, 0.5120830400366143, 0.2538490889415096, 0.33415153638191886, 0.4273278808735992, 0.867547200255958, 0.09913361484360417, 0.12528740769155033, 0.6922086620547391, 0.13655147513745736, 0.03209667335274724, 0.3505458214588266, 0.9303323763821093, 0.9594335994071538, 0.5819123423876457, 0.3114475007050529, 0.12114752051812694, 0.20452981732035946]\n [0.9169483131714715, 0.444402194534041, 0.7667640455857161, 0.5179071161683636, 0.25596644376248334, 0.3439614083570855, 0.42881389580038637, 0.8404857181508336, 0.10207349613818459, 0.12980979255930417, 0.7045585608788062, 0.14142469702894178, 0.033700254458592344, 0.35322775442579823, 0.9254383246584946, 0.8428424981719224, 0.5353929049386887, 0.2716712297929136, 0.11790964375471776, 0.20588623005171253]\n [0.9372189186622565, 0.446138581295766, 0.8030805319662981, 0.5280429096670912, 0.25960285298532004, 0.36088969827160805, 0.43143000229873113, 0.7941678141517742, 0.107334065965393, 0.13803877097876832, 0.7224846396419364, 0.150274714852675, 0.03655779055568964, 0.35202356186576755, 0.8867871855452475, 0.6561325211685619, 0.45370991951901846, 0.21879863147029777, 0.1144327890249893, 0.21137607850479412]\n [0.963419944890434, 0.4478457678502066, 0.8407656301021255, 0.5394619505769526, 0.26358620538619504, 0.3785307293750754, 0.43443524658702654, 0.7426580903726461, 0.11338938338304744, 0.1475698891121404, 0.7345099631141349, 0.16048747662896795, 0.03959434344670769, 0.3379755377009729, 0.7958692645000881, 0.48283669535781387, 0.36706195693003885, 0.17548000193294144, 0.1136592394878268, 0.22309854306314952]\n [0.995616193064571, 0.44805738727466143, 0.8700643195894429, 0.5512240918443782, 0.2674989824178032, 0.3924051349926597, 0.4375425793363201, 0.6886449125246876, 0.11960335804730916, 0.15695502649258633, 0.7327878032629778, 0.17047486846995694, 0.0420936774665965, 0.3062032871443506, 0.6610340292426684, 0.34855000462048347, 0.2881369319293169, 0.14175624955652485, 0.11666389844136492, 0.24243967254676815]\n [1.0331366869886944, 0.44448629343725343, 0.8788288901686566, 0.5620901047900512, 0.2708572048035862, 0.39695429480179645, 0.44018298027640984, 0.6333401253753693, 0.1252037789780579, 0.1640984843116221, 0.7114983769875807, 0.17795514254857084, 0.04354809380952039, 0.26092610308891634, 0.5154058541922188, 0.25624511921879434, 0.22330145420147088, 0.11586948470233616, 0.12436895504970236, 0.26962910331924905]\n [1.0773089982155897, 0.43396923698721435, 0.8556572961992899, 0.5707904139404543, 0.2731983214483226, 0.38705755776238965, 0.4413794083264426, 0.57197930814629, 0.12978003467017415, 0.16724868374246712, 0.6675169557355778, 0.18101017312972054, 0.04388752925907648, 0.20909394578211202, 0.3805309865842198, 0.19230727005942244, 0.16943175281775166, 0.09443672996682428, 0.13906102138589269, 0.30741066949967055]\n [1.1213743703927337, 0.4149870885160012, 0.7975741540831984, 0.5733620864984142, 0.2733077885606147, 0.36141676843558873, 0.4391552288251882, 0.5071960218562799, 0.13225598133704913, 0.1649144766546638, 0.6093837906327526, 0.17807037605762552, 0.04315159765633695, 0.1631734536430942, 0.2790930366914647, 0.15237925689592774, 0.12890880773111002, 0.0777317468581009, 0.16225155189984958, 0.35425475261372863]\n [1.1573410183305781, 0.3875799067335869, 0.7122633234623346, 0.5656661531044221, 0.2699342224158771, 0.32362037390928877, 0.43151833519945715, 0.43980122366299085, 0.1320832740044849, 0.15754833392958092, 0.5485937790090555, 0.16967851768901068, 0.04155688582593655, 0.12670961646818607, 0.20790093579654878, 0.12919220653556573, 0.09920527144448085, 0.06511083602693121, 0.1957265685332169, 0.40863184877785175]\n [1.1744909386178761, 0.35353525150930704, 0.6130415990319116, 0.5442924204781258, 0.2619765432579562, 0.2797239154423789, 0.41725964546931765, 0.3734718885747243, 0.12906194711831975, 0.14648620822639452, 0.49617455885534983, 0.15734180901650238, 0.039351964038387546, 0.0993990767009241, 0.15977668195469585, 0.1193453433823383, 0.07853078787521317, 0.05684848395648957, 0.23880211323157663, 0.46473430625333423]\n ⋮\n [6.0796918581521705e-5, 0.00013150891522234224, 5.122984902540371e-5, 5.055926352857151e-6, 0.0011197509119841174, 2.72109224811782e-5, 0.004805123705502722, 0.23714938621163634, 0.020346986070423154, 2.4630532478621647e-5, 0.4450777658015223, 2.5911085615199446e-5, 0.19582059388974904, 0.10090484291038816, 0.041751108986210705, 0.21605866945924587, 0.009748297718852397, 0.11095477485031849, 0.30896576290589634, 0.4836187314820017]\n [2.9540113222151e-5, 8.00347447969903e-5, 2.6268553079711177e-5, 2.3358462951417747e-6, 0.0008502538978680421, 1.3952641028716671e-5, 0.003612589598646932, 0.23963412412987403, 0.01792469665365543, 1.2629101515044369e-5, 0.4453417610336027, 1.3285671319409156e-5, 0.19486664345425517, 0.10209874101896887, 0.041891604062320766, 0.21602379754402518, 0.009562083807607504, 0.11101835580257087, 0.30897071352241884, 0.4835914564059694]\n [1.316661642751681e-5, 4.609615826134825e-5, 1.2418593996049657e-5, 9.87501335764045e-7, 0.0006289434801502857, 6.59618354592074e-6, 0.002629372386546568, 0.2419049154522667, 0.015626334170663347, 5.970359692603688e-6, 0.4456057549872397, 6.280744324667517e-6, 0.1940092465353524, 0.10314206416967744, 0.0420485758853443, 0.21600078661726943, 0.009371522869375187, 0.11107366457274223, 0.3089769794043164, 0.48355133078828855]\n [5.288582093785549e-6, 2.4853056623499225e-5, 5.324319645605664e-6, 3.7495755124149537e-7, 0.00045102371927351975, 2.8280327624781335e-6, 0.0018418173438047429, 0.2439592430702398, 0.013458321791611608, 2.5596925779574415e-6, 0.4458725663247356, 2.692763414905926e-6, 0.19326957086921884, 0.10403490013930573, 0.042221577622635696, 0.21597907364641333, 0.009176377022193363, 0.11112583015352114, 0.3089834736189299, 0.4835073952356987]\n [1.960571334007521e-6, 1.2748386630111396e-5, 2.1159119561950705e-6, 1.3122771778576438e-7, 0.0003164923062583726, 1.1238747466113514e-6, 0.0012535673852470278, 0.24574331054112852, 0.011504652249723045, 1.017230170364437e-6, 0.4461273330206475, 1.0701126911794138e-6, 0.19267165202202277, 0.10475075390986296, 0.0424010070435812, 0.21595925499505683, 0.00898446860287164, 0.11117426849257206, 0.3089897837893917, 0.48346305093156516]\n [6.595296475494325e-7, 6.1574954853343675e-6, 7.67357373566243e-7, 4.1573174270631394e-8, 0.00021630952401954456, 4.075848117129789e-7, 0.0008246351715284488, 0.24730063052934673, 0.00974480715081397, 3.6890828572072965e-7, 0.4463589658988681, 3.880865976514459e-7, 0.19219749029311017, 0.10531819548617594, 0.04258477175808697, 0.21594251593609987, 0.008795235529896587, 0.11122083597719083, 0.30899624003374065, 0.48342085433959275]\n [2.0108052810536977e-7, 2.8004575219407987e-6, 2.5369560293938255e-7, 1.1906566312871398e-8, 0.00014408987057477836, 1.3475139250269254e-7, 0.0005246117248176988, 0.2486425196015011, 0.008183727277331717, 1.2196446539134927e-7, 0.446562570567622, 1.2830498581876193e-7, 0.19183327165072156, 0.10575941597680824, 0.04276848561653339, 0.2159276885416831, 0.008611086962688601, 0.11126649455155886, 0.30900276016551753, 0.4833835692537177]\n [5.358504987922635e-8, 1.1745932017073953e-6, 7.398752912487071e-8, 2.9651920612526094e-9, 9.266705935784892e-5, 3.9298759867059995e-8, 0.00031929137827159507, 0.2498113303049815, 0.006788855740345596, 3.556958190356424e-8, 0.4467437607789965, 3.741872366693396e-8, 0.1915528586838708, 0.10610455981304934, 0.04295191471615347, 0.21591384077476136, 0.008430160333178009, 0.11131227568908975, 0.30900934087544246, 0.4833508222341021]\n [3.282185490440947e-8, 8.406671643632279e-7, 4.664050899791412e-8, 1.7793663607443082e-9, 7.799523091115677e-5, 2.4773285239966867e-8, 0.00026279733144282983, 0.25020397488876517, 0.0063127663624026826, 2.2422472598567405e-8, 0.446805543604753, 2.3588140754728694e-8, 0.19146688286682312, 0.10621159455439007, 0.04301932407943414, 0.21590899888518364, 0.008364030293671913, 0.11132929056688841, 0.3090117977251234, 0.48333975047389044]\n\n\n\n# components\ntotal_biomass(sim_niche)\n\n51-element Vector{Float64}:\n 9.035052310145453\n 8.879184522388458\n 8.608521978391984\n 8.302235859798492\n 7.977752408265428\n 7.6479265310498565\n 7.293056293658903\n 6.933942335839723\n 6.569662630859385\n 6.203645482991124\n ⋮\n 2.1766481390534884\n 2.175564867603041\n 2.1746610074768165\n 2.1739250919622513\n 2.173359762605175\n 2.1729302781638467\n 2.1726139439221392\n 2.1723830957996384\n 2.172315739556473\n\n\nSecond, we can an estimate of species persistence - how many have gone extinct! Remember that we started with 20, so a value of 0.45 means that there are 12 species left.\n\n# the percentage that persist\npersistence(sim_niche)\n\n51-element Vector{Float64}:\n 1.0\n 1.0\n 1.0\n 1.0\n 1.0\n 1.0\n 1.0\n 1.0\n 1.0\n 1.0\n ⋮\n 1.0\n 1.0\n 1.0\n 1.0\n 1.0\n 1.0\n 1.0\n 1.0\n 1.0\n\n\n\n# quick calculation of number left (but see richness below!)\n20*persistence(sim_niche) # the number left\n\n51-element Vector{Float64}:\n 20.0\n 20.0\n 20.0\n 20.0\n 20.0\n 20.0\n 20.0\n 20.0\n 20.0\n 20.0\n  ⋮\n 20.0\n 20.0\n 20.0\n 20.0\n 20.0\n 20.0\n 20.0\n 20.0\n 20.0\n\n\nThird, we can look at measures of diversity. First, we can get species richness and a measure of diversity, using the Shannon index. This confirms that our persistence estimate (45%) is in line!\n\nrichness(sim_niche)\n\n51-element Vector{Int64}:\n 20\n 20\n 20\n 20\n 20\n 20\n 20\n 20\n 20\n 20\n  ⋮\n 20\n 20\n 20\n 20\n 20\n 20\n 20\n 20\n 20\n\n\n\nshannon_diversity(sim_niche)\n\n51-element Vector{Float64}:\n 15.838289686150633\n 15.938034479922063\n 16.062630873979742\n 16.120434078447378\n 16.08114076965578\n 15.938487296717936\n 15.697940272210305\n 15.410182133499104\n 15.107012611506958\n 14.810310060152338\n  ⋮\n  8.006127953781641\n  7.956790341908213\n  7.911831829233713\n  7.870871518128445\n  7.835016456589332\n  7.803489117441188\n  7.776056823830267\n  7.751865699167819\n  7.743665633965799\n\n\n\n\n\n\n\n\nWarning\n\n\n\nSection is no longer a built-in functionality in END. Alain should be able to address\n\n\nFinally, we can look at stability - all built in metrics of stability are based on the coefficient of variation of species biomass. The CV is a measure of standardised variation - the standard deviation / mean It is not ‘stability’ in the strict mathematical sense, but an estimation of how variable the dynamics are.\ndefined as the average coefficient of variation estimated across all of the coefficients of variation for each species.\nThe master function is coefficient_of_variation and delivers four results - Coefficient of Variation (CV) of community biomass and its partition into average species CV (community_cv above), species mean CV and synchrony, along with the variation of each species; following Thibault & Connolly (2013):\n\ncoefficient_of_variation(sim_niche)\n\nNote the warning…. do you understand what it’s talking about? Think about the extinctions detail above. You can follow the instructions, right?\n\ncoefficient_of_variation(sim_niche, last = 4)\n\nYou can get parts of this with specific helper functions, such as:\n\ncommunity_cv(sim_niche, last = 4)\n\n\n\n\nWhat’s next\nThe next section will introduce how to create simulations where we work with multiple networks and collect data across these. We do this using loops, and collect information in a data frame. We then work on how to embed additional changes to parameters in the loops as well.",
    "crumbs": [
      "Intro to the BEFW model",
      "Tutorial 8: Introducing Ecological Networks Dynamics (END)"
    ]
  },
  {
    "objectID": "08_intro_end.html#references",
    "href": "08_intro_end.html#references",
    "title": "Tutorial 8: Introducing Ecological Networks Dynamics (END)",
    "section": "References",
    "text": "References\n\n\nDelmas, Eva, Ulrich Brose, Dominique Gravel, Daniel B. Stouffer, and Timothée Poisot. 2017. “Simulations of Biomass Dynamics in Community Food Webs.” Edited by Richard Fitzjohn. Methods in Ecology and Evolution 8 (7): 881–86. https://doi.org/10.1111/2041-210x.12713.\n\n\nLajaaiti, Ismaël, Iago Bonnici, Sonia Kéfi, Hana Mayall, Alain Danet, Andrew P Beckerman, Thomas Malpas, and Eva Delmas. 2024. “EcologicalNetworksDynamics.jl a Julia Package to Simulate the Temporal Dynamics of Complex Ecological Networks.” bioRxiv. http://dx.doi.org/10.1101/2024.03.20.585899.\n\n\nWilliams, Richard J., and Neo D. Martinez. 2000. “Simple Rules Yield Complex Food Webs.” Nature 404 (6774): 180–83. https://doi.org/10.1038/35004572.",
    "crumbs": [
      "Intro to the BEFW model",
      "Tutorial 8: Introducing Ecological Networks Dynamics (END)"
    ]
  },
  {
    "objectID": "01_download_setup.html",
    "href": "01_download_setup.html",
    "title": "Tutorial 1: Downloads, Setups and Your First Project",
    "section": "",
    "text": "Julia\nNavigate to this page and follow the platform-specific instructions to download and install Julia (we recommend installing the current stable release).\nDuring the installation process, you may be prompted to add Julia to the PATH, this box should be ticked.\n\n\n\n\n\n\nUsing Juliaup\n\n\n\n\n\nJuliaup is an alternative platform to install and manage multiple versions of Julia you run on your computer. This is useful if you need to run different versions of Julia for different projects but probably not essential for a casual Julia user, although there is also something to be said about setting yourself up with the best toys on the market…\n\n\n\nVSCode\nNavigate to this page to download and install your platform specific Visual Studio Code (not Visual Studio or Visual Studio for Mac).",
    "crumbs": [
      "Setting Up",
      "Tutorial 1: Downloads, Setups and Your First Project"
    ]
  },
  {
    "objectID": "01_download_setup.html#downloading-and-installing-julia-and-vscode",
    "href": "01_download_setup.html#downloading-and-installing-julia-and-vscode",
    "title": "Tutorial 1: Downloads, Setups and Your First Project",
    "section": "",
    "text": "Julia\nNavigate to this page and follow the platform-specific instructions to download and install Julia (we recommend installing the current stable release).\nDuring the installation process, you may be prompted to add Julia to the PATH, this box should be ticked.\n\n\n\n\n\n\nUsing Juliaup\n\n\n\n\n\nJuliaup is an alternative platform to install and manage multiple versions of Julia you run on your computer. This is useful if you need to run different versions of Julia for different projects but probably not essential for a casual Julia user, although there is also something to be said about setting yourself up with the best toys on the market…\n\n\n\nVSCode\nNavigate to this page to download and install your platform specific Visual Studio Code (not Visual Studio or Visual Studio for Mac).",
    "crumbs": [
      "Setting Up",
      "Tutorial 1: Downloads, Setups and Your First Project"
    ]
  },
  {
    "objectID": "01_download_setup.html#setting-up-vscode-to-use-julia",
    "href": "01_download_setup.html#setting-up-vscode-to-use-julia",
    "title": "Tutorial 1: Downloads, Setups and Your First Project",
    "section": "Setting Up VSCode to use Julia",
    "text": "Setting Up VSCode to use Julia\nVS Code is a free source-code editor, allowing you to code in multiple coding languages all from a platform that is completely customisable to the user - think of it as a more language agnostic version of RStudio. This flexibility is great but it does mean that you need to spend time telling VS Code what it is you want to do and how. This is where extensions come in; extensions are higher level packages that permit the use of a given coding language like Julia, edit your themes and icons, provide helpful applications like spell checker or Bracket Pair Colorizer, and for adding your own VS Code pets (a very important part of the VSCode experience).\nTo install Julia in VS Code do the following (you only need to do this once):\n\nopen VS Code (you’ll see the welcome page)\nnavigate to the ‘Marketplace’ (5th symbol down in the activity bar - vertical panel on the lefthand side of the screen)\n\n\n\n\nThe Marketplace Button\n\n\n\nsearch for Julia in the ‘Search Extensions in Marketplace’ search bar\ninstall Julia, this extension provides support for the Julia programming language and install Julia Formatter, this extension will help you write clean code that is easier to read\n\n\n\n\nSelecting the Julia Language Support and Formatter",
    "crumbs": [
      "Setting Up",
      "Tutorial 1: Downloads, Setups and Your First Project"
    ]
  },
  {
    "objectID": "01_download_setup.html#making-your-first-julia-project",
    "href": "01_download_setup.html#making-your-first-julia-project",
    "title": "Tutorial 1: Downloads, Setups and Your First Project",
    "section": "Making your first Julia project",
    "text": "Making your first Julia project\nAs with working in R and RStudio, we advocate working in a contained project environment when using Julia. Each unique project may require a different setup (e.g. packages, package versions, working directories, data locations, etc.).\nTo set up a project in VS Code:\n\nCreating a folder at a location of your choosing (e.g. within your Documents folder). This can be on GoogleDrive, Dropbox or OneDrive. This is OK.\nName the folder with relevant works. Here we will use Julia - VS code - how to.\nNavigate to VSCode and open your new project by clicking on the ‘Explorer’ symbol (top left symbol on the activity bar) and click Open Folder and navigate your finder or explorer to the Julia - VS code - how to folder.\n\nthis folder becomes the working directory (same as when using an .RProject in R)\n\n\n\n\n\nOpening Your Project\n\n\n\nCreate a new file (a script) in your directory: do this by using cmd-N (mac) or ctrl-N (windows) or File -&gt; New File or by left clicking -&gt; New File within the directory pane\nName your script as your see fit but please remember to include the .jl file extension (e.g. JuliaTuto.jl). the .jl file extension tells VS Code you want to use the Julia programming language. To save your script at any time use cmd-S (MAC) OR ctrl-S (windows) or File &gt; Save.\n\nNote, you can also open a project in VS Code by right-clicking on your folder (in Finder, Windows file explorer or Linux nautilus) and selecting Open with -&gt; Other -&gt; VS Code.\n\n\n\nActivating the REPL and running some code.\nThis sequence of figures aligns with the instructions below.\n\n\n\nInitiating and using the REPL\n\n\nNow that you have an active project and a new script file you can open the Julia REPL. REPL stands for read, execute, print and loop. The REPL is like the console in R and is where the magic happens. In Eva’s words, it’s VS Code’s way of using Julia for a brain.\nTo do this you type F1 or cmd/ctrl - shift-p or View -&gt; Command Palette and choose Julia REPL. The command palette will appear as a drop down menu with a search function at the top of the page.\nNow that you have an interface with Julia as a brain, you can actually do something! Try this: type print(\"Hello world\") in the REPL and press Enter/Return. If you’ve done all of the above correctly, Hello world should print in the REPL.\nNow, you can also make a ‘script’. Type ctrl-n or cmd-n and a document will open at the top. There will be a prompt/link to select your language. Click the link and, yes, search for and choose Julia.\nNext, type print(\"Hello world\") in the script. Just like RStudio, you can send the information in the script to the REPL. There are two ways to do this. First, and probably what you’ll want, is shift-enter(return). This will send the line of code you are on, and move to the next line. ctrl-enter(return) submits the line but does not move the cursor. Try it!",
    "crumbs": [
      "Setting Up",
      "Tutorial 1: Downloads, Setups and Your First Project"
    ]
  },
  {
    "objectID": "01_download_setup.html#activating-your-project-the-project.toml-and-manifest.toml",
    "href": "01_download_setup.html#activating-your-project-the-project.toml-and-manifest.toml",
    "title": "Tutorial 1: Downloads, Setups and Your First Project",
    "section": "Activating your project, the Project.toml and Manifest.toml",
    "text": "Activating your project, the Project.toml and Manifest.toml\nWe mentioned above that it is good practice to work within an environment specific to each project. The Julia package manager (Pkg) allows you to do that easily: Unlike traditional package managers, which install and manage a single global set of packages, Pkg is designed around environments: independent sets of packages that can be local to an individual project or shared and selected by name (text taken directly from the documentation).\n\nGetting started: activating your project.\nActivating your project is something that only needs doing once per computer. It allows you to add packages and dependencies to the project.\nIf you move the project to a new computer, or share the project, activation will be needed again.\nThere are two ways to activate your project.\n\ntype Pkg.activate(\".\") in the REPL.\ntype ] in the REPL and then activate .\n\nThe ] is a shorthand for using the Pkg package and opens the package manager. To get out of this, you press the backspace/delete button on your keyboard.\nThere are two ways to double check that you are actually working within your project:\n\ncheck/click the ‘Julia env:…’ on the bottom of your screen (blue bar), it should match your project name\nenter the package manager by typing ] in the Julia REPL, you should see (your-project-name) pkg&gt; instead of julia&gt;. Again, exit the package manager using backspace/delete button.\n\n\n\nWorking with the package manager and growing the project and manifest files\nOnce your project is activated, there are two ways to use the package manager (Pkg):\n\ndirectly from the REPL:\n\n\nnavigate to the REPL\ntype ]\nyou will see that instead of seeing julia&gt; you now see (your-project-name) pkg&gt;, indicating that all the packages that you now install (or update) will be installed (or updated) within this specific project\nto add a package, use the function add: ] add Plots\n\n\nusing Pkg (this is useful when you want to install packages or manage them from within your script):\n\n\nfirst type import Pkg and execute this line using shift-Enter\non subsequent lines, add, remove and update packages from your script using Pkg functions such as Pkg.add(), Pkg.remove() or Pkg.update().\nTo add a packages, the name of the package need to be written with quotes (Pkg.add(\"Plots\")).\n\n\nAn example using the Plots package\nNow that we are all set up, we are going to install a package, check the project’s status and remove a package. As this might be your first time installing a package (e.g., Plots), don’t be concerned if it takes a couple of minutes to run.\n\ntype ] add Plots in the REPL (or Pkg.add(\"Plots\")) in your script and execute using Ctrl-Enter.\n\nyou just installed the Plots package and a whole bunch of dependencies that Plots needs to work. This is equivalent to Base plots in R.\n\n\n\n\n\nPackage Installing\n\n\n\ntype ] st in the REPL. This will check the status of your project and print the content of your Project.toml file, which is the list of main packages, in this case, just Plots.\n\nyou should see something like:\n\n\n\nPackage Status Check\n\n\n\n\n\n\n\n\nTip\n\n\n\nPackages can removed in the same way i.e. ] rm Plots (or Pkg.rm(\"Plots\")) will remove the Plots package from your project environment (and its record in the Project.toml and Manifest.toml files)",
    "crumbs": [
      "Setting Up",
      "Tutorial 1: Downloads, Setups and Your First Project"
    ]
  },
  {
    "objectID": "01_download_setup.html#gearing-up-to-do-more-stuff-what-packages-do-i-need.",
    "href": "01_download_setup.html#gearing-up-to-do-more-stuff-what-packages-do-i-need.",
    "title": "Tutorial 1: Downloads, Setups and Your First Project",
    "section": "Gearing up to Do More Stuff (what packages do I need).",
    "text": "Gearing up to Do More Stuff (what packages do I need).\nThere are a core set of packages we use for all of our work. These 10 packages are almost always installed when we make a project.\nGo ahead and use either the ] or Pkg.add(\"package.name\") method to add all of these to your project.\n\nFor working with data\nCSV DataFrames DelimitedFiles\n\n\nFor plotting\nPlots\n\n\nFor statistical things\nDistributions Random Statistics StatsBase StatsPlots\n\n\nFor Modelling\nDifferentialEquations",
    "crumbs": [
      "Setting Up",
      "Tutorial 1: Downloads, Setups and Your First Project"
    ]
  },
  {
    "objectID": "01_download_setup.html#your-first-script-setup.",
    "href": "01_download_setup.html#your-first-script-setup.",
    "title": "Tutorial 1: Downloads, Setups and Your First Project",
    "section": "Your first script setup.",
    "text": "Your first script setup.\nAt this stage, you should have a good understanding about how to create a project folder, activate a project, start the REPL, open a script and add packages to the project.\nNow you are ready to ‘setup’ your first script.\n\ncreate a new script file (ctrl-n or cmd-n).\nchoose Julia as the language\nType some informative information at the top of the script\n\njust like in R and other programming languages, the # is a commenter.\n\nThe first section of your script is where you declare the packages you’ll be using.\n\nthe function to do this is using.\nmake Plots, Random and DataFrames available.\n\n\nNow you are ready to do something really simple. Let’s make some variables, data frames and a few simple plots.\nFirst, lets get the setup sorted and packages available\n\n# This is my first example script\n# 25 Jan 2023\n\n# packages I need\nusing DataFrames, Plots, Random, StatsPlots\n\nSecond, let’s make some variables and see how Julia prints them to the screen\n\n# make two variables using the rand function\n# because we are using random numbers, we'll set the seed here for reproducibility\n\nRandom.seed!(12345)\n\nx = rand(10)\ny = rand(10)\n\n10-element Vector{Float64}:\n 0.3302627700323072\n 0.4219866389257305\n 0.6853069230253171\n 0.29579983859112813\n 0.9736588395655787\n 0.24458973555203245\n 0.46875054050900267\n 0.27705458732580956\n 0.6299157011197652\n 0.12180466275080659\n\n\nCool. Now, lets create two data frames, one made of the x and y variables, and another with three variables made directly in a call to DataFrame.\n\n# combine into a data frame using the DataFrame function\ndf = DataFrame(x = x, y = y)\ndf\n\n10×2 DataFrame\n\n\n\nRow\nx\ny\n\n\n\nFloat64\nFloat64\n\n\n\n\n1\n0.791805\n0.330263\n\n\n2\n0.159579\n0.421987\n\n\n3\n0.334191\n0.685307\n\n\n4\n0.811392\n0.2958\n\n\n5\n0.796629\n0.973659\n\n\n6\n0.917814\n0.24459\n\n\n7\n0.311327\n0.468751\n\n\n8\n0.752906\n0.277055\n\n\n9\n0.633848\n0.629916\n\n\n10\n0.899951\n0.121805\n\n\n\n\n\n\n…and the second\n\n# make a second data frame with three variables\n# using DataFrame directly to create variables\ndf2 = DataFrame(a=1:10, b=10*rand(10), c=10*rand(10))\ndf2\n\n10×3 DataFrame\n\n\n\nRow\na\nb\nc\n\n\n\nInt64\nFloat64\nFloat64\n\n\n\n\n1\n1\n0.563403\n9.77384\n\n\n2\n2\n7.22679\n3.58869\n\n\n3\n3\n0.466642\n3.76688\n\n\n4\n4\n4.59489\n9.03599\n\n\n5\n5\n0.491108\n8.73964\n\n\n6\n6\n6.99192\n1.36299\n\n\n7\n7\n1.58122\n0.815793\n\n\n8\n8\n4.70745\n3.75399\n\n\n9\n9\n4.97572\n0.599761\n\n\n10\n10\n4.58675\n2.14792\n\n\n\n\n\n\nGreat. Now, lets see how to plot the ‘solo’ variables. Note how we specify the seriestype. Try getting rid of this….\n\n# plot the data using x and y, as a scatterplot\nplot(x, y, seriestype=:scatter)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSuperb. So, StatsPlots provides a special macro to use a dataframe with plots. It’s a three step process:\n\ndeclare the @df macro\ndefine the data frame\ndeclare the columns, using the :\n\n\n# plot the data using the data frame macro\n# declare the df macro, declare the data frame, use : to signify columns\n@df df plot(:x, :y)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAnd here, we use the df2, and plot variable b and c vs. a.\n\n# the same, and plotting two y variables\n@df df2 plot(:a, [:b, :c])\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nA quick briefing about data frames in Julia versus R and dplyr is here\nDataFrames Comparison R dplyr",
    "crumbs": [
      "Setting Up",
      "Tutorial 1: Downloads, Setups and Your First Project"
    ]
  },
  {
    "objectID": "05_plotting.html",
    "href": "05_plotting.html",
    "title": "Tutorial 5: Plotting in Julia",
    "section": "",
    "text": "In R, the plotting of data is either done in base R or via the {ggplot2} package. If you’re a base R person, you’ll probably feel more comfortable with the Plots package. Alternatively, if you prefer {ggplot2}, the StatsPlots and Gadfly package is the closest thing you’ll find in Julia. We’ll introduce both in the following sections.\nIt is worth noting that Julia is based on a ‘Just in Time’ compiler (or JIT) so the first time you call a function it needs to compile, and can take longer than expected. This is especially true when rendering a plot. Consequently, the first plot you make might take some time but it gets significantly faster after that.",
    "crumbs": [
      "Programming, Plotting and Extra Tips",
      "Tutorial 5: Plotting in Julia"
    ]
  },
  {
    "objectID": "05_plotting.html#plots",
    "href": "05_plotting.html#plots",
    "title": "Tutorial 5: Plotting in Julia",
    "section": "Plots",
    "text": "Plots\nAs you saw in Tutorial 2, we can make plots out of variables very easily with the plot function.\n\nRandom.seed!(12345)\nx = 1:100\ny = rand(100)\n\n# label is for the legend/key\n# lw = linewidth\nplot(x, y, label = \"amazing\", title = \"not amazing\", lw = 3)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIf you want to add more data to a plot, the plot!() function is super valuable, and complemented by the xlabel!() and ylabel!() function to update the x-axis\n\ny2 = rand(100) # another 100 randoms\nplot!(x, y2, label = \"less amazing\")\nxlabel!(\"time is not your friend\")\nylabel!(\"ooh la la la\")\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nRecall too that there is a seriestype argument to shift between the default line and, perhaps a scatterplot. Note that we can deliver both y and y2.\n\nplot(x, y, seriestype = [:line,:scatter], markershape = :diamond, lc = :orange, mc = :black, msc = :orange, label = \"Y\")\nplot!(x, y2, seriestype = [:line,:scatter], markershape = :diamond, lc = :blue, mc = :black,  msc = :blue, label = \"Y2\")\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nmc is for marker colour, msc is the colour of the line around the marker/shape and lc is for line colour.\nOf course, there is a scatter() plot function\n\nscatter(x, y)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGrouping Variables in Plots\nJulia’s Plots.jl library does some basic work with grouping variables too, linking to key ideas about tidy data. Let’s look at some sample data where we have 12 data points.\n\nsample_data = DataFrame([rand(12), repeat([\"Network_1\",\"Network_2\",\"Network_3\"],4)], [\"stability\", \"network\"])\n\n12×2 DataFrame\n\n\n\nRow\nstability\nnetwork\n\n\n\nFloat64\nString\n\n\n\n\n1\n0.0491108\nNetwork_1\n\n\n2\n0.699192\nNetwork_2\n\n\n3\n0.158122\nNetwork_3\n\n\n4\n0.470745\nNetwork_1\n\n\n5\n0.625568\nNetwork_2\n\n\n6\n0.997392\nNetwork_3\n\n\n7\n0.572846\nNetwork_1\n\n\n8\n0.580858\nNetwork_2\n\n\n9\n0.141685\nNetwork_3\n\n\n10\n0.764872\nNetwork_1\n\n\n11\n0.690545\nNetwork_2\n\n\n12\n0.137958\nNetwork_3\n\n\n\n\n\n\nPlotting the data, by group, is accomplished like this (note the use of the . to connect the dataframe to the variable name)\n\nplot(sample_data.stability, group = sample_data.network)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThis is a pretty silly plot because the x-axis makes no sense. We might have wanted a bar-chart instead.\n\ngroupedbar(sample_data.stability, group = sample_data.network)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWe’ll see below how the package StatsPlots makes this easier and more flexible (a bit more like {ggplot2}).\n\n\nSaving Plots\nPlots can be saved and outputted using savefig or by using an output marco (e.g. png or pdf). savefig saves the most recent plot (.png is default format) or you can name figures e.g., p1, and use that reference name to save the plot object at any time:\n\n#not run\nsavefig(p1, \"path/to/file/p1.png\")\npng(p1, \"path/to/file/p1\")\npdf(p1, \"path/to/file/p1\")\n\nOnce you’ve created a plot it can be viewed or reopened in VS Code by navigating to the Julia explorer: Julia workspace symbol in the activity bar (three circles) and clicking on the plot object (e.g., p1). We advise that you always name and assign your plots (e.g. p1, p2, etc). The Plots package also has it’s own tutorial for plotting in Julia.",
    "crumbs": [
      "Programming, Plotting and Extra Tips",
      "Tutorial 5: Plotting in Julia"
    ]
  },
  {
    "objectID": "05_plotting.html#statsplots",
    "href": "05_plotting.html#statsplots",
    "title": "Tutorial 5: Plotting in Julia",
    "section": "StatsPlots",
    "text": "StatsPlots\nAs you saw in the Setup introduction, we can also use the StatsPlots package for plotting. This approach invokes a background macro that allows you to use the DataFrames structure to deliver nice plots.\n\n# make a second data frame with three variables\n# using DataFrame directly to create variables\ndf2 = DataFrame(a=1:10, b=10*rand(10), c=10*rand(10))\ndf2\n\n10×3 DataFrame\n\n\n\nRow\na\nb\nc\n\n\n\nInt64\nFloat64\nFloat64\n\n\n\n\n1\n1\n0.815793\n6.88707\n\n\n2\n2\n3.75399\n2.40944\n\n\n3\n3\n9.76062\n1.53078\n\n\n4\n4\n9.96435\n3.45292\n\n\n5\n5\n4.1957\n1.77534\n\n\n6\n6\n8.54517\n1.37223\n\n\n7\n7\n7.83373\n4.74956\n\n\n8\n8\n8.6949\n2.89649\n\n\n9\n9\n5.10112\n0.930789\n\n\n10\n10\n7.89956\n8.68376\n\n\n\n\n\n\nThe use of the @df macro from StatsPlots is a three step process:\n\ndeclare the @df macro\ndefine the data frame\ndeclare the columns, using the : symbol.\n\n\n# plot the data using the data frame macro\n# declare the df macro, declare the data frame, use : to signify columns\n# note that the default is `x then y`.\n@df df2 plot(:a, :b)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nOne of the handy things about the @df macro and StatsPlots is the ability to add two or more variables at once:\n\n# the same, and plotting two y variables (b and c)\n@df df2 plot(:a, [:b, :c])\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThere are several helper functions too. For example, instead of the [[:b, :c] approach to multiple columns, there is a cols argument.\n\n@df df2 plot(:a, cols(2:3), colour = [:red :blue])\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFinally, coming back to the example above for plots using the sample_data dataframe with a grouping variable, we can see how StatsPlots mimics some of the faceting options and group options from ggplot2.\nFirst, the three groups in the same figure with an informative legend.\n\n@df sample_data plot(:stability, group = :network, legend = :topleft)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSecond, the same data but in three panels.\n\n@df sample_data plot(:stability, group = :network, layout = 3)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAnd following the standard Plots.jl example for grouped bars….\n\n@df sample_data groupedbar(:stability, group = :network)",
    "crumbs": [
      "Programming, Plotting and Extra Tips",
      "Tutorial 5: Plotting in Julia"
    ]
  },
  {
    "objectID": "05_plotting.html#gadfly",
    "href": "05_plotting.html#gadfly",
    "title": "Tutorial 5: Plotting in Julia",
    "section": "Gadfly",
    "text": "Gadfly\nThere is a actively developed package called Gadfly which implements an interpretation of the [ggplot2] grammar of graphics. It has been finicky and unstable for us in the past, but you are welcome to try it. To use it, you need to install the package with the ] add Gadfly first step, and then using Gadfly in the top of your script.\nA tutorial and set of examples can be found here",
    "crumbs": [
      "Programming, Plotting and Extra Tips",
      "Tutorial 5: Plotting in Julia"
    ]
  },
  {
    "objectID": "05_plotting.html#makie",
    "href": "05_plotting.html#makie",
    "title": "Tutorial 5: Plotting in Julia",
    "section": "Makie",
    "text": "Makie\nFinally Makie is another alternative to consider. It allows you to make very complex figure layout as well as 2D or 3D plots. Same as above to use this you’ll need to first install the package - ] add Makie and then call in you script with using Makie\nThe documentation can be found here",
    "crumbs": [
      "Programming, Plotting and Extra Tips",
      "Tutorial 5: Plotting in Julia"
    ]
  },
  {
    "objectID": "10_complex_experiments_end.html",
    "href": "10_complex_experiments_end.html",
    "title": "Tutorial 10: Complex Experiments with the END",
    "section": "",
    "text": "Warning\n\n\n\nStability was replaced by Shannon diversity - need to review context as well as if we want that or rather re-integrate stability\nThe previous tutorial focused on experiments where we manipulated the number of networks and various network parameters. This is one set of things we can change/vary in an in silico experiment. The other set of things we can change are features of the model, such as the shape of the functional response (see Tutorial 7), features of the environment such as the carrying capacity, or even empirical relationships that drive trophic structure and interaction strengths, such as the predator-prey mass ratio.\nIn this tutorial, we are going to implement three experiments. The first two will be ‘simple’ in that they vary only two things. The final example will implement a large experiment changing five features of the model.\nYou may want to start a new script in the project. We’ll need the following packages (they are already installed… so we just need using).\nusing Random, Plots, Distributions, DataFrames, StatsPlots\nusing EcologicalNetworksDynamics",
    "crumbs": [
      "Intro to the BEFW model",
      "Tutorial 10: Complex Experiments with the END"
    ]
  },
  {
    "objectID": "10_complex_experiments_end.html#experiment-5-multiple-networks-replicates",
    "href": "10_complex_experiments_end.html#experiment-5-multiple-networks-replicates",
    "title": "Tutorial 10: Complex Experiments with the END",
    "section": "Experiment 5: Multiple networks (replicates)",
    "text": "Experiment 5: Multiple networks (replicates)\nTo Do: run S (3 values), C (3 values) and h (3 values) where there are 5 replicate networks per combination. Note we need 45 networks…",
    "crumbs": [
      "Intro to the BEFW model",
      "Tutorial 10: Complex Experiments with the END"
    ]
  },
  {
    "objectID": "CONTRIBUTING.html",
    "href": "CONTRIBUTING.html",
    "title": "Welcome!",
    "section": "",
    "text": "report a bug or suggest an improvement – open an issue on GitHub\nwrite a tutorial – have a new example for using END? create a new .qmd file and add it to the overall website structure in _quarto.yml\nimprove the documentation – all functions have a docstring where they are declared, and improving them is a great way to get started\n\n\n\n\nHave a look at the current Julia documentation.\n\n\n\nPlease use emojis, this helps visually sorting through the commits (and makes for a fun time). Inspiration taken from sciencegitmojis\n\n\n\n\n\n\n\n\nIf the commit is about…\n…then use\nExample\n\n\n\n\nWork in progress\n:construction:\n:construction: new output structure\n\n\nBug fix\n:bug:\n:bug: mean fails if NA\n\n\nFixing typos\n:pencil2:\n:pencil2: README\n\n\nCode maintenance\n:wrench:\n:wrench: fix variable names\n\n\nNew test\n:clapper:\n:clapper: wget JSON resource\n\n\nPlot figures\n:bar_chart:\n:bar_chart: example boundaries\n\n\nNew data\n:cd:\n:cd: example pollination network\n\n\nNew feature\n:sparkles:\n:sparkles: (insert achievement)\n\n\nDocumentation\n:books:\n:books: lattice function\n\n\nPerformance improvement\n:racehorse:\n:racehorse: parallelizes models by default\n\n\nUpcoming release\n:package:\n:package: v1.0.6\n\n\nUgly but working code\n:dragon:\n:dragon: added lattice function\n\n\nWorking on code that doesn’t work but I want to go home\n:neutral_face:\n:neutral_face: for triangulation\n\n\nI forgot to save everything before committing\n:sandwich:\n:sandwich: what is saving\n\n\nJettisoned something\n:boom:\n:boom: manifest\n\n\n\n\n\n\nThis section describes the general steps to make sure that your contribution is integrated rapidly. The general workflow is as follows:\n\nFork the repository (see Branches, etc. below)\nCreate an explicitly named branch from develop (if present) or master\nCreate a pull request as soon as you make the first commit\nBe as explicit as possible on your goals\nDo not squash / rebase commits while you work – we will do so when merging\n\n\n\nCreating a pull request before you push any code will signal that you are interested in contributing to the project. Once this is done, push often, and be explicit about what the commits do (see commits, below). This gives the opportunity for feedback during your work, and allow for tweaks in what you are doing.\nA good pull request (in addition to satisfying to all of the criteria below) is:\n\nSingle purpose - it should do one thing, and one thing only\nShort - it should ideally involve less than 250 lines of code\nLimited in scope - it should ideally not span more than a handful of files\nWell tested and well documented\nWritten in a style similar to the rest of the codebase\n\nThis will ensure that your contribution is rapidly reviewed and evaluated.\n\n\n\nThe tagged versions of anything on master are stable releases. The master branch itself is the latest version, but it must always work (after the first tagged release). For more intensive development, use the develop branch, or feature-specific branches. All significant branches are under continuous"
  },
  {
    "objectID": "CONTRIBUTING.html#dont-know-where-to-start",
    "href": "CONTRIBUTING.html#dont-know-where-to-start",
    "title": "Welcome!",
    "section": "",
    "text": "report a bug or suggest an improvement – open an issue on GitHub\nwrite a tutorial – have a new example for using END? create a new .qmd file and add it to the overall website structure in _quarto.yml\nimprove the documentation – all functions have a docstring where they are declared, and improving them is a great way to get started"
  },
  {
    "objectID": "CONTRIBUTING.html#setting-up-your-environment",
    "href": "CONTRIBUTING.html#setting-up-your-environment",
    "title": "Welcome!",
    "section": "",
    "text": "Have a look at the current Julia documentation."
  },
  {
    "objectID": "CONTRIBUTING.html#emojis",
    "href": "CONTRIBUTING.html#emojis",
    "title": "Welcome!",
    "section": "",
    "text": "Please use emojis, this helps visually sorting through the commits (and makes for a fun time). Inspiration taken from sciencegitmojis\n\n\n\n\n\n\n\n\nIf the commit is about…\n…then use\nExample\n\n\n\n\nWork in progress\n:construction:\n:construction: new output structure\n\n\nBug fix\n:bug:\n:bug: mean fails if NA\n\n\nFixing typos\n:pencil2:\n:pencil2: README\n\n\nCode maintenance\n:wrench:\n:wrench: fix variable names\n\n\nNew test\n:clapper:\n:clapper: wget JSON resource\n\n\nPlot figures\n:bar_chart:\n:bar_chart: example boundaries\n\n\nNew data\n:cd:\n:cd: example pollination network\n\n\nNew feature\n:sparkles:\n:sparkles: (insert achievement)\n\n\nDocumentation\n:books:\n:books: lattice function\n\n\nPerformance improvement\n:racehorse:\n:racehorse: parallelizes models by default\n\n\nUpcoming release\n:package:\n:package: v1.0.6\n\n\nUgly but working code\n:dragon:\n:dragon: added lattice function\n\n\nWorking on code that doesn’t work but I want to go home\n:neutral_face:\n:neutral_face: for triangulation\n\n\nI forgot to save everything before committing\n:sandwich:\n:sandwich: what is saving\n\n\nJettisoned something\n:boom:\n:boom: manifest"
  },
  {
    "objectID": "CONTRIBUTING.html#workflow",
    "href": "CONTRIBUTING.html#workflow",
    "title": "Welcome!",
    "section": "",
    "text": "This section describes the general steps to make sure that your contribution is integrated rapidly. The general workflow is as follows:\n\nFork the repository (see Branches, etc. below)\nCreate an explicitly named branch from develop (if present) or master\nCreate a pull request as soon as you make the first commit\nBe as explicit as possible on your goals\nDo not squash / rebase commits while you work – we will do so when merging\n\n\n\nCreating a pull request before you push any code will signal that you are interested in contributing to the project. Once this is done, push often, and be explicit about what the commits do (see commits, below). This gives the opportunity for feedback during your work, and allow for tweaks in what you are doing.\nA good pull request (in addition to satisfying to all of the criteria below) is:\n\nSingle purpose - it should do one thing, and one thing only\nShort - it should ideally involve less than 250 lines of code\nLimited in scope - it should ideally not span more than a handful of files\nWell tested and well documented\nWritten in a style similar to the rest of the codebase\n\nThis will ensure that your contribution is rapidly reviewed and evaluated.\n\n\n\nThe tagged versions of anything on master are stable releases. The master branch itself is the latest version, but it must always work (after the first tagged release). For more intensive development, use the develop branch, or feature-specific branches. All significant branches are under continuous"
  },
  {
    "objectID": "03_dataframes.html",
    "href": "03_dataframes.html",
    "title": "Tutorial 3: Building and Working with DataFrames",
    "section": "",
    "text": "Working with vectors, arrays and matrices is important. But quite often, we want to collect high-dimension data (multiple variables) from our simulations and store them in a spreadsheet type format.\nAs you’ve seen in Tutorial 1, there are plotting macros (@df) within the StatsPlots package that allow us to work with data frame objects from the DataFrames package. A second benefit of the data frame object is that we can export it as a csv file and import this into R where we may prefer working on plotting and statistics.\nTo this end, here we will also introduce the CSV package, which is very handy for exporting DataFrame objects to csv files, and importing them as well, if you’d like.",
    "crumbs": [
      "Basic Calculations and Objects",
      "Tutorial 3: Building and Working with DataFrames"
    ]
  },
  {
    "objectID": "03_dataframes.html#the-data-frame",
    "href": "03_dataframes.html#the-data-frame",
    "title": "Tutorial 3: Building and Working with DataFrames",
    "section": "The Data Frame",
    "text": "The Data Frame\nTo initialise a dataframe you use the DataFrame function from the DataFrames package:\n\ndat = DataFrame(col1=[], col2=[], col3=[]) # we use [] to specify an empty column of any type and size.\n\n0×3 DataFrame\n\n\n\nRow\ncol1\ncol2\ncol3\n\n\n\nAny\nAny\nAny\n\n\n\n\n\n\n\n\nAlternately, you can specify the data type for each column.\n\ndat1 = DataFrame(col1=Float64[], col2=Int64[], col3=Float64[])\n\n0×3 DataFrame\n\n\n\nRow\ncol1\ncol2\ncol3\n\n\n\nFloat64\nInt64\nFloat64\n\n\n\n\n\n\n\n\nOf course, col1 is not the only label you provide: variable names are super important and the conventions we use in R are also important here in Julia, e.g. a_b or AaBa but not a b (no spaces allowed) or a.b (because the (dot) . functions as an operator).\n\n# provide informative column titles using:\ndat2 = DataFrame(species=[], size=[], rate=[])\n\n0×3 DataFrame\n\n\n\nRow\nspecies\nsize\nrate\n\n\n\nAny\nAny\nAny\n\n\n\n\n\n\n\n\n\nAllocating or adding data to a data frame.\nTo add data to a dataframe, we use the push! (read as push bang) command.\n\nspecies = \"D.magna\"\nsize = 2.2\nrate = 4.2\n\n4.2\n\n\n\n# push!() arguments: data frame, data\npush!(dat2, [species, size, rate])\n\n1×3 DataFrame\n\n\n\nRow\nspecies\nsize\nrate\n\n\n\nAny\nAny\nAny\n\n\n\n\n1\nD.magna\n2.2\n4.2\n\n\n\n\n\n\nOf course, the push!() function can append data to the existing data frame. It is worth noting that push! can only append one row at a time. But since Julia is so good with loops (compared to R), this will make adding data to a dataframe really easy, and we’ll learn how to do this in the next tutorial. What makes the ! (bang) function very useful is that you can append (or remove, with pop!()) items to an object without having to assign it.\n\nspecies2 = \"D.pulex\"\nsize2 = 1.8\nrate2 = 3.1\n\n# push!() arguments: data frame, data\npush!(dat2, [species2, size2, rate2])\n\n2×3 DataFrame\n\n\n\nRow\nspecies\nsize\nrate\n\n\n\nAny\nAny\nAny\n\n\n\n\n1\nD.magna\n2.2\n4.2\n\n\n2\nD.pulex\n1.8\n3.1\n\n\n\n\n\n\n\n\nHelper Functions for Data Frames\nYou can print data frames using println\n\nprintln(dat2)\n\n2×3 DataFrame\n Row │ species  size  rate \n     │ Any      Any   Any  \n─────┼─────────────────────\n   1 │ D.magna  2.2   4.2\n   2 │ D.pulex  1.8   3.1\n\n\nThere are first and last function that are like head and tail in R and elsewhere, with a first argument the data frame and the second argument the number of rows.\n\nfirst(dat2, 2)\n\n2×3 DataFrame\n\n\n\nRow\nspecies\nsize\nrate\n\n\n\nAny\nAny\nAny\n\n\n\n\n1\nD.magna\n2.2\n4.2\n\n\n2\nD.pulex\n1.8\n3.1\n\n\n\n\n\n\n\nlast(dat2,2)\n\n2×3 DataFrame\n\n\n\nRow\nspecies\nsize\nrate\n\n\n\nAny\nAny\nAny\n\n\n\n\n1\nD.magna\n2.2\n4.2\n\n\n2\nD.pulex\n1.8\n3.1\n\n\n\n\n\n\nAnd as we learned with matrices and arrays, the [row, column] method also works for data frames:\n\ndat2[1,2]\n\n2.2\n\n\n\ndat2[1,:]\n\nDataFrameRow (3 columns)\n\n\n\nRow\nspecies\nsize\nrate\n\n\n\nAny\nAny\nAny\n\n\n\n\n1\nD.magna\n2.2\n4.2\n\n\n\n\n\n\n\ndat2[:,3]\n\n2-element Vector{Any}:\n 4.2\n 3.1",
    "crumbs": [
      "Basic Calculations and Objects",
      "Tutorial 3: Building and Working with DataFrames"
    ]
  },
  {
    "objectID": "03_dataframes.html#the-csv",
    "href": "03_dataframes.html#the-csv",
    "title": "Tutorial 3: Building and Working with DataFrames",
    "section": "The CSV",
    "text": "The CSV\nAs with R, there are functions to read and write .csv files to and from dataframes. This makes interoperability with tools in R and standard data storage file formats easy.\nTo write our daphnia data to a csv file, we use a familiar syntax, but a function from the CSV package.\n\nCSV.write(\"daphniadata.csv\", dat2)\n\nOf course, you can read files in using…. yes, CSV.read. Note the second argument declares the data to go into a data frame.\n\ndaph_in = CSV.read(\"betterDaphniaData.csv\", DataFrame)",
    "crumbs": [
      "Basic Calculations and Objects",
      "Tutorial 3: Building and Working with DataFrames"
    ]
  },
  {
    "objectID": "06_tips_tricks.html",
    "href": "06_tips_tricks.html",
    "title": "Tutorial 6: Extra Tips and Tricks",
    "section": "",
    "text": "Some quick tips that we’ve learnt the hard way…\n\nIn the REPL, you can use the up arrow to scroll through past code\nYou can even filter through your past code by typing the first letter of a line previously executed in the REPL. For example, try typing p in the REPL and using the up arrow to scroll through your code history, you should quickly find the last plot command you executed.\nToggle word wrap via View&gt;Toggle Word Wrap or alt-Z\nTo interrupt Julia while it is running through code use ⌘/Ctrl + C\nRed wavy line under code in your script = error in code\nBlue wavy line under code in your script = possible error in code\nErrors and possible errors can be viewed in the PROBLEMS section of the REPL\nYou can view your current variables (similar to the top right hand panel in RStudio) by clicking on the Julia explorer: Julia workspace symbol in the activity bar (three circles). You can then look at them in more detail by clicking the sideways arrow (when allowed).\nThe copy function in Julia does not behave as one intuitively expects and if you want to make changes to a copied item without altering the original use deepcopy instead\n\n\n\n\n\n\n\nCOPYING versus DEEP COPYING\n\n\n\n\n\nJulia has a strange copying behaviour where if a = b, any change in b will automatically cause the same change in a. For example, let’s make an array of three numbers:\n\naa = [1,2,3]\n\n3-element Vector{Int64}:\n 1\n 2\n 3\n\n\nHere we make a copy of aa and call it bb.\n\nbb = aa\nprint(bb)\n\n[1, 2, 3]\n\n\nNow, we replace the second element of bb with the value 41.\n\nbb[2] = 41\nbb\n\n3-element Vector{Int64}:\n  1\n 41\n  3\n\n\nThe default behaviour of = in Julia is to UPDATE any copy of the array, so we see the same change in aa:\n\naa\n\n3-element Vector{Int64}:\n  1\n 41\n  3\n\n\nWhoa… that’s not what we expect, though it’s pretty cool. This approach is advantageous because it lets Julia save memory, however, it is not ideal.\nTo remedy this, and create copies that don’t update their parent or other offspring, we can force c to be an independent copy of a using the deepcopy function:\n\ncc = deepcopy(aa)\n\n3-element Vector{Int64}:\n  1\n 41\n  3\n\n\n\ncc[3] = 101\n\n101\n\n\nSee how only the third element of cc s changed but not aa?\n\naa,cc\n\n([1, 41, 3], [1, 41, 101])\n\n\n\n\n\n\nYou can view a .csv or .txt file by clicking on a file name in the project directory (left panel) - this opens a viewing window. CSV’s also have a built in ‘Preview’ mode - try using right click&gt;Open Preview on a .csv file and check it out.\nDocstrings are a supplement to #-based comments for documenting your workflow. Basically, any string that appears just before an object will be interpreted as documenting it. When you use a docstring it is possible to call that description using help (? in the REPL) or hovering over the object in VSCode. This can be very useful when you start declaring variables or building your own functions.\n\n\n\n\n\n\n\nDocstrings\n\n\n\n\n\nBelow is an examle of a docstring for a global variable as well as how it would look for a function\n\n\"a wonderfully documented and described variable\"\nvar = 101\n\nyou can (should) also do this with functions\n\n\"\"\"\n    _rategradient(∂X, ∂Y)\n\nReturns the rate of change in units of the values stored in the grid, and the\nangle of the change in wind direction, *i.e.* an angle of 180 means that the\nvalue is increasing *from* the south. When both ∂X and ∂Y are equal to 0, the\nangle is assumed to be 0.\n\"\"\"\nfunction _rategradient(∂X::T, ∂Y::T) where {T &lt;: Number}\n    if ∂X == ∂Y == 0.0\n        return (0.0, 0.0)\n    end\n    m = sqrt(∂X^2 + ∂Y^2)\n    Δ = ∂X &gt;= 0.0 ? 0.0 : 180.0\n    θ = rad2deg(atan(∂X, ∂Y)) + Δ\n    θ = ∂X &gt; 0.0 ? θ + 180.0 : θ\n    return (m, θ)\nend",
    "crumbs": [
      "Programming, Plotting and Extra Tips",
      "Tutorial 6: Extra Tips and Tricks"
    ]
  },
  {
    "objectID": "07_differential_equations.html",
    "href": "07_differential_equations.html",
    "title": "Tutorial 7: Introducing Differential Equations",
    "section": "",
    "text": "This document illustrates how to construct and solve differential equations in Julia using the DifferentialEquations.jl package.\nIn particular, we are interested in modelling a two species Lotka-Volterra like (predator-prey/consumer-resource) system. Such systems are fundamental in ecology and form the building blocks of complex networks and the models that represent them.\nFor this tutorial you’ll need the following two packages:\nWhile we already have Plots.jl in this project, we just need to ] add DifferentialEquations.\nThe DifferentialEquations.jl can be a tad clunky so the below code might take a while to compile. If you hit errors, we recommend removing (] rm DifferentialEquations) and reinstalling (] add DifferentialEquations) the package.\nYou probably want to start a new script for this exercise. File -&gt; New File -&gt; julia",
    "crumbs": [
      "Intro to Differential Equations",
      "Tutorial 7: Introducing Differential Equations"
    ]
  },
  {
    "objectID": "07_differential_equations.html#references",
    "href": "07_differential_equations.html#references",
    "title": "Tutorial 7: Introducing Differential Equations",
    "section": "References",
    "text": "References\n\n\nDelmas, Eva, Ulrich Brose, Dominique Gravel, Daniel B. Stouffer, and Timothée Poisot. 2017. “Simulations of Biomass Dynamics in Community Food Webs.” Edited by Richard Fitzjohn. Methods in Ecology and Evolution 8 (7): 881–86. https://doi.org/10.1111/2041-210x.12713.",
    "crumbs": [
      "Intro to Differential Equations",
      "Tutorial 7: Introducing Differential Equations"
    ]
  },
  {
    "objectID": "04_programming_basics.html",
    "href": "04_programming_basics.html",
    "title": "Tutorial 4: The Basics of Programming",
    "section": "",
    "text": "This section of the tutorials introduces programming basics, including the art of simple functions, positional arguments, keyword arguments, loops, if-else-break usage and continue-while usage.\nIt is important to note that if you have experience programming R, there is a major difference in Julia - the use of loops is very much advocated in Julia where as vectorising loops is advocated in R.\nBasically, we write loops in Julia. We try to avoid them in R, if we want speed.",
    "crumbs": [
      "Programming, Plotting and Extra Tips",
      "Tutorial 4: The Basics of Programming"
    ]
  },
  {
    "objectID": "04_programming_basics.html#functions",
    "href": "04_programming_basics.html#functions",
    "title": "Tutorial 4: The Basics of Programming",
    "section": "Functions",
    "text": "Functions\nFunctions work exactly like they do in R, however, there are three fundamental differences:\n\nthere is no need for {} brackets (thank god)\nindenting (Julia requires seperate parts of a function to be indented - don’t worry, VS Code should do this for you)\nscoping (we’ll attempt to explain this later)\nfunctions always start with the word function and end with the word end. -to store something that is calculated in a function, you use the return command.\n\nLet’s begin with a simple function - adding 2 to any number\n\nfunction plus_two(x)\n    return x+2\nend\n\nplus_two (generic function with 1 method)\n\n\nLet’s use it now by providing an defining and x value, and asking for the function to return the new value.\n\nx_in = 33\nx_out = plus_two(x_in)\n\n35\n\n\nBecause we’ve defined x_out, we can request it…\n\nx_out\n\n35\n\n\n\nPositional Arguments\nAs in R, input variables for functions have a specified and fixed order unless they have a default value which is explicitly specified. For instance, we can build a function that measures body weight on different planets, but defaults to estimating weight on earth with a gravitational force of 9.81:\n\nfunction bodyweight(BW_earth, g = 9.81)\n    # bw should be in kg.\n    return BW_earth*g/9.81\nend\n\nbodyweight (generic function with 2 methods)\n\n\nNote that the function is called bodyweight, it requires in the first position a weight in kg on earth and then defaults to estimating weight on earth by using g = 9.81\n\nbodyweight(75)\n\n75.0\n\n\nNow, if we want to estimate they same bodyweight on Mars, where gravity is 3.72, you can specify the g-value.\n\nbodyweight(75, 3.72)\n\n28.44036697247706\n\n\n\n\nKeyword Arguments\n\n# function with keyword arguments:\n# here, b and d are fixed = 2\n# a is positional\n# c is a keyword argument\n# the addition of ; before c means that c is an keyword argument and can be specified in any order, but must be named\nfunction key_word(a, b=2; c, d=2) \n    return a + b + c + d\nend\n\nkey_word (generic function with 2 methods)\n\n\nHere we specify position 1 (a) and that c = 3\n\nkey_word(1, c = 3)\n\n8\n\n\nHere we specify c = 3, and then position 1\n\nkey_word(c=3, 1)\n\n8\n\n\nHere we specify position 1 (a), redefine position 2 (b = 6) and declare c = 7.\n\nkey_word(1, 6, c=7)\n\n16\n\n\nNote that this DOES NOT work, because we’ve failed to define c. (and or b)\n\nkey_word(1, 8, d=4)\n\nUndefKeywordError: UndefKeywordError(:c)\nUndefKeywordError: keyword argument `c` not assigned\nStacktrace:\n [1] top-level scope\n   @ ~/Library/Mobile Documents/com~apple~CloudDocs/Documents/Uni/JuliaTutorials_BecksLab/04_programming_basics.qmd:154\n\n\nTo redefine d, you’d need to define c and d.\n\nkey_word(1, c = 8, d = 4)\n\n15",
    "crumbs": [
      "Programming, Plotting and Extra Tips",
      "Tutorial 4: The Basics of Programming"
    ]
  },
  {
    "objectID": "04_programming_basics.html#loops",
    "href": "04_programming_basics.html#loops",
    "title": "Tutorial 4: The Basics of Programming",
    "section": "Loops",
    "text": "Loops\n\nFor loops\nFor loops work by iterating over a specified range (e.g. 1-10) at specified intervals (e.g. 1,2,3…). For instance, we might use a for loop to fill an array:\n\nFilling an array\nTo fill an array, we first define an object as an array using [].\n\nI_array = []\n\nAny[]\n\n\nLike with function, all loops start with for and end with end. Here we iteratively fill I_array with 1000 random selections of 1 or 2.\n\n# for loop to fill an array:\nfor i in 1:1000\n    # pick from the number 1 or 2 at random \n    # for each i'th step\n    for_test = rand((1,2)) \n    # push! and store for_test in I_array2\n    # Julia is smart enough to do this iteratively\n    # you don't necessarily have to index by `[i]` like you might do in R\n    push!(I_array, for_test) \nend\n\nLet’s look at I_array now\n\nI_array\n\n1000-element Vector{Any}:\n 1\n 1\n 1\n 2\n 2\n 2\n 2\n 1\n 1\n 2\n ⋮\n 2\n 2\n 1\n 1\n 1\n 1\n 2\n 2\n 2\n\n\nLet’s try something more complex, iterating over multiple indices\nA new storage container:\n\ntab = []\n\nAny[]\n\n\nNow, we fill the storage container with values of i, j and k. Can you tell which in which order this will happen? The first entry will be [1,1,1]. The second will be [2,1,1]. Do you understand why? Mess around to check.\n\n# nested for loop to fill an array:\nfor k in 1:4\n    for j in 1:3\n        for i in 1:2\n            append!(tab,[[i,j,k]]) # here we've use append! to allocate iteratively to the array as opposed to using push! - both work. \n        end\n    end\nend\n\nLet’s look…\n\ntab\n\n24-element Vector{Any}:\n [1, 1, 1]\n [2, 1, 1]\n [1, 2, 1]\n [2, 2, 1]\n [1, 3, 1]\n [2, 3, 1]\n [1, 1, 2]\n [2, 1, 2]\n [1, 2, 2]\n [2, 2, 2]\n ⋮\n [2, 2, 3]\n [1, 3, 3]\n [2, 3, 3]\n [1, 1, 4]\n [2, 1, 4]\n [1, 2, 4]\n [2, 2, 4]\n [1, 3, 4]\n [2, 3, 4]\n\n\nWe can also allocate to a multiple dimensional matrix. When working with matrices, we can build them out of zeros and the replace the values.\nHere we start with a three dimensional array with 4 two x three matrices.\n\nthreeDmatrix = zeros(2,3,4)\n\n2×3×4 Array{Float64, 3}:\n[:, :, 1] =\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n\n[:, :, 2] =\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n\n[:, :, 3] =\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n\n[:, :, 4] =\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n\n\nNow, let’s do a nested loop again, but this time into the matrices. The element we are adding each iteration is the sum of i+j+k.\nCan you guess how this works?\n\nfor k in 1:4\n    for j in 1:3\n        for i in 1:2\n            # note default is by column....\n            # first element allocated is 1+1+1, then 2+1+1 and this is first col\n            # then 1+2+1 and 2+2+1 into the second col\n            # then 1+3+1 and 2+3+1 into the third col\n            threeDmatrix[i,j,k] = i+j+k\n        end\n    end\nend\n\n\nthreeDmatrix\n\n2×3×4 Array{Float64, 3}:\n[:, :, 1] =\n 3.0  4.0  5.0\n 4.0  5.0  6.0\n\n[:, :, 2] =\n 4.0  5.0  6.0\n 5.0  6.0  7.0\n\n[:, :, 3] =\n 5.0  6.0  7.0\n 6.0  7.0  8.0\n\n[:, :, 4] =\n 6.0  7.0  8.0\n 7.0  8.0  9.0\n\n\nFinally, note that we can use println to provide a basic marker what what is happening: we show two ways to do this in the code.\n\nfor k in 1:4\n    for j in 1:3\n        for i in 1:2\n            #println(i,\"-\",j,\"-\",k) # multiple quotes\n            println(\"$i-$j-$k\") # one quote, $ to grab variables\n            \n            # note default is by column....\n            # first element allocated is 1+1+1, then 2+1+1 and this is first col\n            # then 1+2+1 and 2+2+1 into the second col\n            # then 1+3+1 and 2+3+1 into the third col\n            threeDmatrix[i,j,k] = i+j+k\n        end\n    end\nend\n\nAnd just for fun… this println trick can be handy for verbose tracking. Note how person in unique(persons) iterates and how you can embed a variable’s value in a text string.\n\npersons = [\"Alice\", \"Alice\", \"Bob\", \"Bob2\", \"Carl\", \"Dan\"]\n\nfor person in unique(persons)\n    println(\"Hello $person\")\nend\n\nHello Alice\nHello Bob\nHello Bob2\nHello Carl\nHello Dan\n\n\nThere are tons of different functions that can be helpful when building loops. Take a few minutes to look into the help files for eachindex, eachcol, eachrow and enumerate. They all provide slightly different ways of telling Julia how you want to loop over a problem. Also, remember that loops aren’t just for allocation, they can also be very useful when doing calculations.\n\n\n\nif, else, breaks\nWhen building a loop, it is often meaningful to stop or modify the looping process when a certain condition is met. For example, we can use the break, if and else statements to stop a for loop when i exceeds a given value (e.g. 10):\n\n# if and break:\nfor i in 1:100\n    println(i) # print i\n    if i &gt;10\n        break # stop the loop with i &gt;10\n    end   \nend\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# this loop can be modified using an if-else statement:\n# even though we are iterating to 100, it stops at 10.\nfor j in 1:100\n    if j &gt;10\n        break # stop the loop with i &gt;10\n    else\n        crj = j^3\n        println(\"J is = $j\") # print i\n        println(\"The Cube of $j is $crj\")\n    end\nend\n\nJ is = 1\nThe Cube of 1 is 1\nJ is = 2\nThe Cube of 2 is 8\nJ is = 3\nThe Cube of 3 is 27\nJ is = 4\nThe Cube of 4 is 64\nJ is = 5\nThe Cube of 5 is 125\nJ is = 6\nThe Cube of 6 is 216\nJ is = 7\nThe Cube of 7 is 343\nJ is = 8\nThe Cube of 8 is 512\nJ is = 9\nThe Cube of 9 is 729\nJ is = 10\nThe Cube of 10 is 1000\n\n\nYou’ll notice that every statement requires it’s own set of for and end points, and is indented as per Julia’s requirements. if and else statements can be very useful when building experiments: for example we might want to stop simulating a network’s dynamics if more than 50% of the species have gone extinct.\n\n\ncontinue and while\n\ncontinue\nThe continue command is the opposite to break and can be useful when you want to skip an iteration but not stop the loop:\n\nfor i in 1:30\n    # this reads: is it false that i is a multiple of 3?\n    if i % 3 == false\n        continue # makes the loop skip iterations that are a multiple of 3\n    else println(\"$i is not a multiple of 3\")\n    end\nend\n\n1 is not a multiple of 3\n2 is not a multiple of 3\n4 is not a multiple of 3\n5 is not a multiple of 3\n7 is not a multiple of 3\n8 is not a multiple of 3\n10 is not a multiple of 3\n11 is not a multiple of 3\n13 is not a multiple of 3\n14 is not a multiple of 3\n16 is not a multiple of 3\n17 is not a multiple of 3\n19 is not a multiple of 3\n20 is not a multiple of 3\n22 is not a multiple of 3\n23 is not a multiple of 3\n25 is not a multiple of 3\n26 is not a multiple of 3\n28 is not a multiple of 3\n29 is not a multiple of 3\n\n\nCan you figure out what the code would be for keeping even numbers only? Note the change of logic from false above to true here.\n\nfor i in 1:10\n    # where is it true that i is a multiple of 2?\n    if i % 2 == true\n        continue # makes the loop skip iterations that are odd\n    else println(\"$i is even\")\n    end\nend\n\n2 is even\n4 is even\n6 is even\n8 is even\n10 is even\n\n\n\n\nwhile\nwhile loops provide an alternative to for loops and allow you to iterate until a certain condition is met:\n\n# counter that is globally scoped (see next section)\n# testval -- try changing this to see how this global variable can be used in \n# the local process below\nglobal j=0\nglobal testval = 17\n\n# note that we started with j = 0!!!\n# justify a condition\nwhile(j&lt;testval) \n    println(\"$j is definitely less than $testval\") # prints j until j &lt; 17\n    # step forward\n    j += 1 # count\nend\n\n0 is definitely less than 17\n1 is definitely less than 17\n2 is definitely less than 17\n3 is definitely less than 17\n4 is definitely less than 17\n5 is definitely less than 17\n6 is definitely less than 17\n7 is definitely less than 17\n8 is definitely less than 17\n9 is definitely less than 17\n10 is definitely less than 17\n11 is definitely less than 17\n12 is definitely less than 17\n13 is definitely less than 17\n14 is definitely less than 17\n15 is definitely less than 17\n16 is definitely less than 17\n\n\nwhile loops don’t require you to specify a looping sequence (e.g. i in 1:100). But you do specify the starting value. The while loop can be very useful because sometimes you simply don’t know how many iterations you might need.\nIn the above code, you might have spotted the word global. Variables can exist in the local or global scope. If a variable exists inside a loop or function it is local and if you want to save it beyond the loop (i.e., in your workspace) you have to make it global - more on this below.",
    "crumbs": [
      "Programming, Plotting and Extra Tips",
      "Tutorial 4: The Basics of Programming"
    ]
  },
  {
    "objectID": "04_programming_basics.html#combine-a-function-and-a-loop",
    "href": "04_programming_basics.html#combine-a-function-and-a-loop",
    "title": "Tutorial 4: The Basics of Programming",
    "section": "combine a function and a loop",
    "text": "combine a function and a loop\nLet’s get a bit more complicated. Above, you created a function that added 2 to any number. Let’s embed that in a loop and introduce enumerate. Quite often, there are functions you may want to apply to multiple things, and this is the example of how to do that!\n\n# make a vector - these are input values to our function\nvv = [1,2,3,7,9,11]\n\n# enumerate takes a special two variable starter: \"(index, value)\"\n# note how we print the index, then the output and then a line break with \\n\nfor (i, v) in enumerate(vv)\n    out = plus_two(v)\n    println(\"this is element $i of vv\")\n    println(\"$v plus 2 is equal to $out\\n\")\nend\n\nthis is element 1 of vv\n1 plus 2 is equal to 3\n\nthis is element 2 of vv\n2 plus 2 is equal to 4\n\nthis is element 3 of vv\n3 plus 2 is equal to 5\n\nthis is element 4 of vv\n7 plus 2 is equal to 9\n\nthis is element 5 of vv\n9 plus 2 is equal to 11\n\nthis is element 6 of vv\n11 plus 2 is equal to 13",
    "crumbs": [
      "Programming, Plotting and Extra Tips",
      "Tutorial 4: The Basics of Programming"
    ]
  },
  {
    "objectID": "04_programming_basics.html#scoping",
    "href": "04_programming_basics.html#scoping",
    "title": "Tutorial 4: The Basics of Programming",
    "section": "Scoping",
    "text": "Scoping\nScoping refers to the accessibility of a variable within your project. The scope of a variable is defined as the region of code where a variable is known and accessible. A variable can be in the global or local scope.\n\nGlobal\nA variable in the global scope is accessible everywhere and can be modified by any part of your code. When you create (or allocate to) a variable in your script outside of a function or loop you’re creating something that is global:\n\n# global allocation to A\nA = 7\nB = zeros(1:10)\n\n10-element OffsetArray(::Vector{Float64}, 1:10) with eltype Float64 with indices 1:10:\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n\n\nOf course you can be super literate and force a variable to be global\n\nglobal(c = 7)\n\n7\n\n\n\n\nLocal\nA variable in the local scope is only accessible in that scope or in scopes eventually defined inside it. When you define a variable within a function or loop that isn’t returned then you create something that is local:\n\n# global\nC2 = zeros(10)\n\n10-element Vector{Float64}:\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n\n\n\n# local:\nfor i in 1:10\n    local_varb = 2 # local_varb is defined inside the loop and is therefore local (only accessible within the loop)\n    C2[i] = local_varb*i # in comparison, C is defined outside of the loop and is therefore global \nend\n\nNow, let’s see what we can see.\nC2 is global and it had numbers assigned to it, and we can see it.\n\nC2\n\n10-element Vector{Float64}:\n  2.0\n  4.0\n  6.0\n  8.0\n 10.0\n 12.0\n 14.0\n 16.0\n 18.0\n 20.0\n\n\nHowever, local_varb is local, and we can’t ask for anything about it. If we wanted to know about it, we’d have to ask for it to be println-ed to monitor it, or written (as it was to C2)\n\nlocal_varb\n\nUndefVarError: UndefVarError(:local_varb, Main.Notebook)\nUndefVarError: `local_varb` not defined in `Main.Notebook`\nSuggestion: check for spelling errors or missing imports.",
    "crumbs": [
      "Programming, Plotting and Extra Tips",
      "Tutorial 4: The Basics of Programming"
    ]
  },
  {
    "objectID": "02_maths_vector_stuff.html",
    "href": "02_maths_vector_stuff.html",
    "title": "Tutorial 2: Using Julia for Maths and Vector Stuff",
    "section": "",
    "text": "This second document follows on from Tutorial 1: “Getting started” and assumes that you’re still working in your active project.\nThere is also a section at the end with some “Quick tips”.",
    "crumbs": [
      "Basic Calculations and Objects",
      "Tutorial 2: Using Julia for Maths and Vector Stuff"
    ]
  },
  {
    "objectID": "02_maths_vector_stuff.html#sec-basic-maths",
    "href": "02_maths_vector_stuff.html#sec-basic-maths",
    "title": "Tutorial 2: Using Julia for Maths and Vector Stuff",
    "section": "Basic Maths",
    "text": "Basic Maths\nAs you probably can guess, the REPL is an interface onto a large calculator. Julia does all the things R does… and you can find the basic maths operations defined The Julia Manual\nsums\n\n1+1\n\nexponents\n\n10^3\n\nsequences in a vector\n\n\n# From 0, by 1, to 10...\n\nx = collect(0:1:10)\n\n# see it\nx\n\n11-element Vector{Int64}:\n  0\n  1\n  2\n  3\n  4\n  5\n  6\n  7\n  8\n  9\n 10\n\n\nmultiply vector by scalar value\n\n\nx*10\n\n11-element Vector{Int64}:\n   0\n  10\n  20\n  30\n  40\n  50\n  60\n  70\n  80\n  90\n 100",
    "crumbs": [
      "Basic Calculations and Objects",
      "Tutorial 2: Using Julia for Maths and Vector Stuff"
    ]
  },
  {
    "objectID": "02_maths_vector_stuff.html#sec-getting-help",
    "href": "02_maths_vector_stuff.html#sec-getting-help",
    "title": "Tutorial 2: Using Julia for Maths and Vector Stuff",
    "section": "Getting Help",
    "text": "Getting Help\nBefore we move on, lets talk about the help files and how to access them. As in R, the help files associated with a given package, function or command can be accessed using ? followed by the function name (e.g. type ? pi in the REPL).\nSimilar to when you entered Julia’s package manager (using ]) you’ll notice that the ? command causes a change in the REPL with help?&gt;replacing julia&gt; as the prompt. This informs you that you’ve entered the help mode. As an exercise, use the help mode to find the difference between print and println.",
    "crumbs": [
      "Basic Calculations and Objects",
      "Tutorial 2: Using Julia for Maths and Vector Stuff"
    ]
  },
  {
    "objectID": "02_maths_vector_stuff.html#preamble-to-objects-like-scalars-vectors-and-arrays",
    "href": "02_maths_vector_stuff.html#preamble-to-objects-like-scalars-vectors-and-arrays",
    "title": "Tutorial 2: Using Julia for Maths and Vector Stuff",
    "section": "Preamble to Objects like scalars, vectors and arrays",
    "text": "Preamble to Objects like scalars, vectors and arrays\nBefore we start creating arrays and matrices, we’d like to demonstrate how you allocate numbers and strings to objects in Julia and check an object’s type. We’d also like to highlight some simple mathematical operations.\n\nAllocating data to objects\nAllocating in Julia is useful as it means that variables can be stored and used elsewhere. You allocate numbers to objects using the following:\nFirst note that we use the = in Julia, not the &lt;- as in R.\n\n# allocate an Integer number to a variable\nn = 5\n\nJulia, like other languages, has some built in values, like pi. We can allocate these to variable names we will use. Notice that Julia converts pi into the unicode symbol!\n\n\n\n\n\n\nCapitalising on unicode\n\n\n\n\n\nJulia has built in unicode support that allows you to use mathematical symbols (and emojis!). This is vary useful when describing models and variables as you don’t have to specify a ‘wordy’ variable but rather the actual mathematical symbol. Making for cleaner and more ‘readable’ code!\nTo ‘access’ different unicode symbols start by typing \\ and the standard name of the symbol you wish to use\n\n\n\n\n# allocate a pre-defined number of importance to a variable\n# note that pi is converted to π\n\npi_sum = pi\npi_sum\n\nπ = 3.1415926535897...\n\n\nWe can use these unicode symbols (and emojis!), as a variable and assign them a value - meaning that 🐺 is totally a usable variable name!\n\n🐺 = 4\n🐺\n\n4\n\n\nYou can also assign multiple values to separate variables in a concise manner. Julia can manage something like this:\n\nαi, βi, γi = 1.3, 2.1, exp(39)\n\n# confirm...\nαi, βi, γi\n\n(1.3, 2.1, 8.659340042399374e16)\n\n\n\nAllocating strings\nOf course you can also allocate strings of text to objects. You must use the \"\" and not '' to define strings.\n\nsob = \"School of Biosciences\"\n\n\"School of Biosciences\"\n\n\nYou can combine strings and numbers to print like this. Note how you use $object.name within the text string you are writing… and this works for objects that are text or numeric.\n\nprintln(\"The favourite number in $sob is $n\")\n\nThe favourite number in School of Biosciences is 5\n\n\n\n\n\nIdentifying the Type of object you’ve made\nJulia is very specific about types of objects. Most programming languages are. One way to learn about them is to look at what is made when you make things in different ways.\n\ntypeof(n), typeof(sob), typeof(pi)\n\n(Int64, String, Irrational{:π})\n\n\nJulia is like R and Python in that it can infer the type of object (Integer, Float, etc) on the left hand side of the equals sign - you don’t have to justify it like you do in C. However, you can declare the type if needed e.g.\n\npi_custom = Float64(3.141592)\n\n3.141592\n\n\nFor those of you that are interested, a floating-point object (a Float) is a number that has a decimal place. An Int object is an integer, a number without a decimal place, whereas an Irrational object is a specific type of Float used only for representing some irrational numbers of special significance (e.g. π and γ). The 64 purely refers to 64-bit which is the type of processor your computer uses, most modern computers are 64-bit.\nOccasionally it will be valuable to convert an object from one type to another. For example, n is currently an Integer (Int64), and we might want it to be Float (Float64). To be clear, this is a distinction between 5 and 5.0!\n\ntypeof(n)\n\nInt64\n\n\n\nn2 = convert(Float64, n)\ntypeof(n2)\n\nFloat64\n\n\n\n\n\n\n\n\nMultiple dispatch using types\n\n\n\n\n\nThe strict type system of Julia means that it is possible to define multiple ‘methods’ for functions depending on the type of the input object. Which allows you to have function behave different for different input types. This blog post provides a nice overview of multiple dispatch using Pokemon types but the take-home message here is that it is important that you specify the correct type of an object and that often times when you run into an error it is because of that… This may seem annoying at first but it does mean that in the long run your code is much ‘safer’ because you won’t (unknowingly) be converting and combining objects that are of different types unless you specifically specify it.",
    "crumbs": [
      "Basic Calculations and Objects",
      "Tutorial 2: Using Julia for Maths and Vector Stuff"
    ]
  },
  {
    "objectID": "02_maths_vector_stuff.html#understanding-arrays-vectors-and-sequences.",
    "href": "02_maths_vector_stuff.html#understanding-arrays-vectors-and-sequences.",
    "title": "Tutorial 2: Using Julia for Maths and Vector Stuff",
    "section": "Understanding Arrays, Vectors and Sequences.",
    "text": "Understanding Arrays, Vectors and Sequences.\nAs you saw above, we created a sequence of numbers using collect(0:1:10). Let’s look at what type of object this is:\n\ntypeof(x)\n\nVector{Int64} (alias for Array{Int64, 1})\n\n\nThis is a vector. Let’s step back to see the difference between arrays and vectors. Arrays, for the R users, are best thought of as lists - they are storage boxes for any type of variables and can contain collections of various types. The general way to create an array, in this case and empty one, is the [ ].\n\nempty_array = []\n\nAny[]\n\n\nWe will first create an array with the same values as x and then see how collect is the function that converts this to a vector, and actually lets us see the numbers too!\nFirst, range can be used to make an array. This is very similar to seq() in R and has the two variations - by and length that the R function has. The difference is that by is replaced by the argument step. Note how a very concise summary of this array is presented using information in square brackets [ ]:\n\nx_array1 = range(start = 1, step = 1, stop = 10)\nx_array2 = range(start = 1, stop = 10, length = 5)\n\nx_array1, x_array2\n\n(1:1:10, 1.0:2.25:10.0)\n\n\nYou can also now see that creating arrays is possible with [ ] and the use of the : :\n\nx_array3 = [1:1:10]\n\n1-element Vector{StepRange{Int64, Int64}}:\n 1:1:10\n\n\nQuite often, you want to either see the values, or specifically be using a vector. To do this, you can use the function collect():\n\ncollect(x_array1)\n\n10-element Vector{Int64}:\n  1\n  2\n  3\n  4\n  5\n  6\n  7\n  8\n  9\n 10",
    "crumbs": [
      "Basic Calculations and Objects",
      "Tutorial 2: Using Julia for Maths and Vector Stuff"
    ]
  },
  {
    "objectID": "02_maths_vector_stuff.html#indices-of-arrays.",
    "href": "02_maths_vector_stuff.html#indices-of-arrays.",
    "title": "Tutorial 2: Using Julia for Maths and Vector Stuff",
    "section": "Indices of Arrays.",
    "text": "Indices of Arrays.\nYou should recall from R that values in arrays and vectors and dataframes have addresses that we call indices. Julia works with indexing very similarly.\nLet’s make a simple array of 5 numbers and another simple array of five words. Note that the [] array function is a but like the c() function in R.\n\nar = [6,7,8,9,10]\nbr = [\"Pint\", \"of\", \"Moonshine\", \"please\"]\n\n4-element Vector{String}:\n \"Pint\"\n \"of\"\n \"Moonshine\"\n \"please\"\n\n\nYou can get any address in these using… square brackets!\n\nar[2] # gets the number 7!\n\n7\n\n\n\nbr[3] # gets the word Moonshine\n\n\"Moonshine\"\n\n\nIf you want two addresses in a sequence, you can just provide the sequence:\n\nar[2:3]\n\n2-element Vector{Int64}:\n 7\n 8\n\n\nBut if you want non-adjacent values, you need to provide the ‘list of indices’ as an array, which results in the use of [[ ]].\n\nar[[2,4]]\n\n2-element Vector{Int64}:\n 7\n 9\n\n\nNote this would be like using in R ar[c(2,4)].\nAnother nice indexing feature is that you can simply specify end as a means to index the final element. This is quite useful when you e.g., want to pull the final output of a series without needing to know how long the series is.\n\nar[end]\n\n10",
    "crumbs": [
      "Basic Calculations and Objects",
      "Tutorial 2: Using Julia for Maths and Vector Stuff"
    ]
  },
  {
    "objectID": "02_maths_vector_stuff.html#broadcasting-something-very-special",
    "href": "02_maths_vector_stuff.html#broadcasting-something-very-special",
    "title": "Tutorial 2: Using Julia for Maths and Vector Stuff",
    "section": "Broadcasting: something VERY special",
    "text": "Broadcasting: something VERY special\nBroadcasting allows you to apply a function, like a log() or exp(), in an element-wise manner to an array (in other words apply the function to every element of an array).\nWe saw above that we can create a vector using collect() and multiply this by a scalar\n\n# sequences in a vector\n# From 0, by 1, to 10...\n\nx = collect(0:1:10)\n\n# see it\nx\n\n11-element Vector{Int64}:\n  0\n  1\n  2\n  3\n  4\n  5\n  6\n  7\n  8\n  9\n 10\n\n\n\n# multply scaler x vector.\nx*10\n\n11-element Vector{Int64}:\n   0\n  10\n  20\n  30\n  40\n  50\n  60\n  70\n  80\n  90\n 100\n\n\nYou can work directly with arrays and pre-built functions to do things like this. To do-so, we combine the function with the (dot) . operator. Let’s work with x_array1 from above. Note how broadcasting the function across the array returns a vector.\n\n# Look at the help file for exp10\nexp_array1 = exp10.(x_array1)\n\n10-element Vector{Float64}:\n     10.0\n    100.0\n   1000.0\n  10000.0\n 100000.0\n      1.0e6\n      1.0e7\n      1.0e8\n      1.0e9\n      1.0e10\n\n\nIf you try to do this without the (dot) . operator what happens?\n\n# look at the help file for log - what is the default!?\nlog_array1 = log.(x_array1)\n\n10-element Vector{Float64}:\n 0.0\n 0.6931471805599453\n 1.0986122886681098\n 1.3862943611198906\n 1.6094379124341003\n 1.791759469228055\n 1.9459101490553132\n 2.0794415416798357\n 2.1972245773362196\n 2.302585092994046\n\n\nDid you check the help file for log? Is it the same default as we find in R?",
    "crumbs": [
      "Basic Calculations and Objects",
      "Tutorial 2: Using Julia for Maths and Vector Stuff"
    ]
  },
  {
    "objectID": "02_maths_vector_stuff.html#matrices",
    "href": "02_maths_vector_stuff.html#matrices",
    "title": "Tutorial 2: Using Julia for Maths and Vector Stuff",
    "section": "Matrices",
    "text": "Matrices\nSometimes we’ll be interested in a 2-dimensional or higher version of the array/vector, and this is a matrix. Making a matrix in Julia uses the [ ] again, an separates rows of numbers with the ;\n\nmat = [1 2 3; 4 5 6]\n\n2×3 Matrix{Int64}:\n 1  2  3\n 4  5  6\n\n\nNote how there are NO commas between the numbers in each row! This is read as ‘rows are separated by ; and columns by spaces’!\nYou can also ‘pre-fill’ a matrix with zeros. This is good practice in loops and programming as pre-filling and replacing variables in a matrix is more efficient than creating the matrix on the fly. Here we demonstrate how to pre-fil a vector, matrix and high dimension array! Matrices can have more than two dimensions!\n\nvec0 = zeros(2) # 2 zeros allocated in a vector\n\n2-element Vector{Float64}:\n 0.0\n 0.0\n\n\n\nmat0 = zeros(2,3) # zeros allocated to 2 rows and 3 columns!\n\n2×3 Matrix{Float64}:\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n\n\n\narr0 = zeros(2,3,4) # 2 rows, 3 columns and 4 dimensions!\n\n2×3×4 Array{Float64, 3}:\n[:, :, 1] =\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n\n[:, :, 2] =\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n\n[:, :, 3] =\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n\n[:, :, 4] =\n 0.0  0.0  0.0\n 0.0  0.0  0.0\n\n\nAccessing values in a matrix follows the same convention as with the vector. The convention is [row, column]\n\nmat[1,2] # value in the first row and second column\n\n2\n\n\n\nmat[1:2, 3] # rows 1 AND 2 in the 3rd column\n\n2-element Vector{Int64}:\n 3\n 6\n\n\nFinally, to get a row or column, you need to know that we need a placeholder for the missing bit of what you are asking for. If we want the second row, we ask for row 2, and stick the : placeholder in the column spot:\n\nmat[2,:]\n\n3-element Vector{Int64}:\n 4\n 5\n 6\n\n\nFor a column, we reverse this.\n\nmat[:,2]\n\n2-element Vector{Int64}:\n 2\n 5\n\n\n\nA quick interlude on types\nAs discussed earlier Julia is able to infer the type of an object based on the input. So the mat object we created earlier will be a matrix of integers i.e. Matrix{Int64}.\n\ntypeof(mat)\n\nMatrix{Int64} (alias for Array{Int64, 2})\n\n\nSo what happens if we want to replace one of the elements with a Float?\n\nmat[1,2] = 1.5\n\nThis is because we are trying to add a Float to an object that is of the type Integer. What happens if we convert mat to be a matrix of floats and then try again?\n\nmat = convert(Matrix{Float64}, mat)\nmat[1,2] = 1.5\n\n1.5",
    "crumbs": [
      "Basic Calculations and Objects",
      "Tutorial 2: Using Julia for Maths and Vector Stuff"
    ]
  },
  {
    "objectID": "02_maths_vector_stuff.html#dictionaries",
    "href": "02_maths_vector_stuff.html#dictionaries",
    "title": "Tutorial 2: Using Julia for Maths and Vector Stuff",
    "section": "Dictionaries",
    "text": "Dictionaries\nDictionaries are another way to collect information in Julia, these look-up tables allow you to organise information (the key) with corresponding data (value). When we create a dictionary we specify it as ‘value’ =&gt; ‘key’. Dictionaries are useful if you need to store a collection of parameters or outputs, especially because the values for each pair can be of a different type.\n\nparameters = Dict{Symbol,Any}(\n        :growth_rate =&gt; 0.4,\n        :response =&gt; :logistic,\n        :carry_capacity =&gt; 0.28,\n    )\n\nDict{Symbol, Any} with 3 entries:\n  :growth_rate    =&gt; 0.4\n  :response       =&gt; :logistic\n  :carry_capacity =&gt; 0.28\n\n\nWe can also add an ‘entry’ to our dictionary very easily (or change the value)\n\nparameters[:abundance] = collect(1:10)\n\n10-element Vector{Int64}:\n  1\n  2\n  3\n  4\n  5\n  6\n  7\n  8\n  9\n 10\n\n\n\nLooking things up\nTo get a value, if you have the key:\n\nparameters[:growth_rate]\n\n0.4\n\n\nYou can also get all values using values() (and the same for keys using keys()). Note that these functions are iterators and they have one job: to iterate through a dictionary value by value (or key by key) so if we want to turn these into an array we need to also call collect()\n\nparam_vals = collect(values(parameters))\n\nparam_keys = collect(keys(parameters))\n\n4-element Vector{Symbol}:\n :growth_rate\n :response\n :carry_capacity\n :abundance",
    "crumbs": [
      "Basic Calculations and Objects",
      "Tutorial 2: Using Julia for Maths and Vector Stuff"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Julia and using VSCode",
    "section": "",
    "text": "This set of tutorials is designed to help you use an integrated coding tool, VSCode, to run experiments with the Bioenergetic Foodweb Model, built in the coding language Julia.\nIt will cover four core objectives\n\nAcquire/install the Julia programming language, the Integrated Development Environment called VSCode.\nLearn how to work with Julia programming, from installing packages to understanding arithmetic and plotting and data frames\nLearn how to simulate a simple predator-prey (consumer-resource) model using the DifferentialEquations package in Julia\nLearn how to implement and use the multi-species EcologicalNetworksDynamics in Julia\n\nHaving done these, you will then be introduced to further complexities and opportunities.\n\n\nFor users of R and RStudio, VSCode and Julia can be thought of as the same working team, i.e. VSCode/RStudio are the text editors that allow you to create a ‘rich text’ environment from which to run Julia/R. That being said (as to be expected) there are a few differences in the workflow that it might be worth familiarising yourself with. You can also keep Table 1 handy to help with getting over the first initial stumbling blocks.\nRStudio users might be familiar with the concept of working with projects (i.e. a way of ‘containerising’ your work within a specific directory), Julia works in a similar manner. Broadly a Julia project is much more localised in that any packages that you use (install) are downloaded locally for that specific project (environment), meaning that it is possible to have multiple versions of a package installed for different projects - which is very handy from a reproducibility perspective. The details of the packages (dependencies) that you install are recorded in the Project.toml (a records of packages that have been installed and their versions - very useful when sharing code as any user can see exactly what version of a package has been used) and the Manifest.toml (all the package dependencies installed - i.e. packages that for a part of the other packages that you have installed) files, these files are machine generated and will update as you add or removed packages while you work so you don’t need to worry too much about interacting with them but its good to know what they mean/do. For an R specific analogy these files can be thought as the equivalents of the renv.lock file generated from the {renv} package.\n\n\n\nTable 1: A moving from R to Julia cheatsheet\n\n\n\n\n\n\n\n\n\n\naction\nR\nJulia\n\n\n\n\nchecking current working directory\ngetwd()\npwd()\n\n\ninstall a package\ninstall.package(“PACKAGE_NAME”)\nPkg.add(“PACKAGE_NAME”)\n] add PACKAGE_NAME\n\n\ncall/import a package\nlibrary(PACKAGE_NAME)\nusing PACKAGE_NAME\n\n\nresolving naming conflicts (functions from different packages with the same name)\nPACKAGE_NAME::function()\nPACKAGE_NAME.function()\n\n\ncalling column from dataframe\ndf$COL_NAME\ndf.COL_NAME\n\n\ncalling the first elements of a dataframe\nhead()\nfirst()\n\n\ncalling the last elements of a dataframe\ntail()\nlast()\n\n\n\n\n\n\n\n\n\nThe simple idea here is to make a Julia script and add the code in these tutorials to your scripts. Make sure you annotate using the # symbol, as we do in R Scripts. We suggest that You have a script associated with each section of the table of contents on the left.",
    "crumbs": [
      "Setting Up",
      "Julia and using VSCode"
    ]
  },
  {
    "objectID": "index.html#welcome-to-the-tutorials",
    "href": "index.html#welcome-to-the-tutorials",
    "title": "Julia and using VSCode",
    "section": "",
    "text": "This set of tutorials is designed to help you use an integrated coding tool, VSCode, to run experiments with the Bioenergetic Foodweb Model, built in the coding language Julia.\nIt will cover four core objectives\n\nAcquire/install the Julia programming language, the Integrated Development Environment called VSCode.\nLearn how to work with Julia programming, from installing packages to understanding arithmetic and plotting and data frames\nLearn how to simulate a simple predator-prey (consumer-resource) model using the DifferentialEquations package in Julia\nLearn how to implement and use the multi-species EcologicalNetworksDynamics in Julia\n\nHaving done these, you will then be introduced to further complexities and opportunities.\n\n\nFor users of R and RStudio, VSCode and Julia can be thought of as the same working team, i.e. VSCode/RStudio are the text editors that allow you to create a ‘rich text’ environment from which to run Julia/R. That being said (as to be expected) there are a few differences in the workflow that it might be worth familiarising yourself with. You can also keep Table 1 handy to help with getting over the first initial stumbling blocks.\nRStudio users might be familiar with the concept of working with projects (i.e. a way of ‘containerising’ your work within a specific directory), Julia works in a similar manner. Broadly a Julia project is much more localised in that any packages that you use (install) are downloaded locally for that specific project (environment), meaning that it is possible to have multiple versions of a package installed for different projects - which is very handy from a reproducibility perspective. The details of the packages (dependencies) that you install are recorded in the Project.toml (a records of packages that have been installed and their versions - very useful when sharing code as any user can see exactly what version of a package has been used) and the Manifest.toml (all the package dependencies installed - i.e. packages that for a part of the other packages that you have installed) files, these files are machine generated and will update as you add or removed packages while you work so you don’t need to worry too much about interacting with them but its good to know what they mean/do. For an R specific analogy these files can be thought as the equivalents of the renv.lock file generated from the {renv} package.\n\n\n\nTable 1: A moving from R to Julia cheatsheet\n\n\n\n\n\n\n\n\n\n\naction\nR\nJulia\n\n\n\n\nchecking current working directory\ngetwd()\npwd()\n\n\ninstall a package\ninstall.package(“PACKAGE_NAME”)\nPkg.add(“PACKAGE_NAME”)\n] add PACKAGE_NAME\n\n\ncall/import a package\nlibrary(PACKAGE_NAME)\nusing PACKAGE_NAME\n\n\nresolving naming conflicts (functions from different packages with the same name)\nPACKAGE_NAME::function()\nPACKAGE_NAME.function()\n\n\ncalling column from dataframe\ndf$COL_NAME\ndf.COL_NAME\n\n\ncalling the first elements of a dataframe\nhead()\nfirst()\n\n\ncalling the last elements of a dataframe\ntail()\nlast()\n\n\n\n\n\n\n\n\n\nThe simple idea here is to make a Julia script and add the code in these tutorials to your scripts. Make sure you annotate using the # symbol, as we do in R Scripts. We suggest that You have a script associated with each section of the table of contents on the left.",
    "crumbs": [
      "Setting Up",
      "Julia and using VSCode"
    ]
  }
]